\section{Introduction}
\label{sec:introduction}


%\pg{This is what we should answer by the introduction: 
%What's the problem with the current state of the art?
%What is our solution?
%Why is the problem we're solving hard?
%How do we solve the challenges?
%Why do we do better than existing work?
%What are the lessons learnt from the paper?}

\pgcomment{Remember to do abstract}

A key difficulty in verifying properties of fine-grained concurrent
programs is being able to reason compositionally about each thread in
isolation, even though in reality the correctness of the whole system
is the collaborative result of intricately intertwined actions of the
threads.  Such compositional reasoning is essential for: verifying
large concurrent systems, since it allows them to be verified
component-wise;  verifying library code and incomplete programs,
since one does not need to know about the context of execution; and 
replicating a programmer's intuition about why their implementations
are correct, since their informal arguments are typically  kept local and do
not bring the whole system into the reasoning.


Rely-guarantee reasoning~\cite{rg} and various combinations of
rely-guarantee and separation-logic
reasoning~\cite{viktor-marriage,dg,lrg,cap-ecoop10,icap,tada} achieve
compositional reasoning for increasingly difficult inter-thread
interactions. However, we believe that, despite substantial progress, there are many
examples where the specifications and proofs are not as natural as
they might be; they  are either too coarse or
too 
contrived. 
We explore a different approach, introducing the
program logic, \colosl, using which we can give natural small
specifications and proofs which correspond to the  programmer's intuition of what shared
resource
is required by the thread. 




Small specifications were emphasised  in the work of O'Hearn, Reynolds
and Yang on separation logic~\cite{paperincludesYang}. 
The original separation logic~\cite{rey02,seplog} achieves
compositional reasoning for sequential heap-manipulating programs by
spliting the heap into disjoint heaplets for describing the local
resource required by a program. Compositionality rests on two
powerful mechanisms: a program  can be specified using only those
resources that it actually accesses; and this specification can be
simply reused in any context that contains these resources.
By making the specification
as small  as possible, we can ensure that it
can be reused in a large set of possible contexts using  the {\em frame
rule}. 
 Specification reuse is paramount to achieve compositional
reasoning: if the specification of a piece of code can be reused in
any valid context, we only have  to prove it once and for all. 


Concurrent separation logic extends this compositional reasoning  to concurrent programs
using the {\em disjoint concurrency rule}, where individual threads
  use both local resource which is private to the thread and static
invariant shared regions which can be accessed by all threads through
critical regions. Since
then, there have been many extensions combining rely-guarantee
reasoning with ideas from concurrent separation logic to reason about
fine-grained concurrency: RGSep~\cite{viktor-marriage} and then
deny-guarantee reasoning~\cite{dg} introduce local resource and shared
disjoint regions which are stable with respect to a static  interference
relation stating how the current thread and the environment can effect
the region; CAP~\cite{cap-ecoop10} and its
extensions~\cite{hocap,icap,tada} in addition abstract the
regions. This work has achieved substantial success; see related work
for more details. However,  we believe these approaches sometimes   give
specifications and proofs which are either too coarse  or unnatural.



The problem is due to the rigid nature of the shared disjoint regions and
their static interference, which   limit how we can  work
with a
concurrent data structure. A disjoint region typically either describes 
the entire data structure such as a linked list,  or contains
individual 
components on which the data structure is built such as the nodes of a
linked list. However, threads may have shared access to arbitray 
parts of the data structure, and we would like directly express this
access  in
the reasoning. 
The   static interference relation of a region 
 is defined when
the region  is created and    is fixed throughout the entire lifetime of
the region. However, 
threads having access to parts of a shared region need  only
 know about the interference associated with those parts of the
region. In addition, 
at the time  of creation, it is not necessarilly possible
to predict all future interactions  associated with  a shared
region. Just as the original separation logic  uses the frame rule to
obtain small specifications for the local state, we would like to be
able to have some analogous framing of the shared state and its
interference  to obtain small
specifications of the shared state. 


For example, consider a linked list consisting of $n+1$ nodes accessed
concurrently by $n$ threads (numbered $1$ to $n$) where the $i$th
thread requires access to the $i$th and $(i+1)$th nodes. Current
approaches cannot reason directly about the two shared nodes being accessed
by the threads. 
Now consider a binary graph accessed by a concurrent
spanning tree algorithm. Current approaches cannot reason directly
about such  data structures with intrinsic sharing which are
accessed concurrently. Finally, consider a concurrent set library
with just  an
insert function. Current approaches cannot extend their reasoning to
include a remove function, withouthaving to  redo their
proofs. In summary, disjoint regions with static interference ........





%. As such, upon its creation, provision
%has to be made for all future extensions of it and it is generally not
%possible to arbitrarily grow it with extra state under new
%interference rules.  As we discuss in \S\ref{sec:examples}, this
%results in unnatural specifications when dynamically-allocated
%resources become shared during execution, such as in the concurrent
%set module example of~\cite{cap-ecoop10}.


%\pgcomment{Not sure should be in:These issues, in particular the first one, not only affect the
%locality of the reasoning, but also impede \emph{modularity} and proof
%reuse. When the implementation of a module $M_1$ is verified against
%its specification, its proof can only be reused from within another
%module $M_2$ if either the parts of the shared state accessed by $M_2$
%are disjoint from those of $M_1$, or the shared state is partitioned
%identically for both modules. The probability that several modules
%agree on the exact partition and shape of the shared resources is slim.}

This paper introduces the program logic, \colosl, which stands for 
\underline{Co}ncurrent \underline{Lo}cal \underline{S}ubjective
\underline{L}ogic. \colosl is based on one global shared state with
each thread verified with respect to its partial {\em subjective view}
of this global state. Each subjective (personalised) view comprises an assertion which
describes  \emph{parts} of the shared global resource used by a thread, 
and an interference relation which describes   how the thread and
the environment may affect these parts.  
Subjective views may arbitrarily overlap with
each other, with both their resource and interference expanding and
contracting  in accordance with what is required by the
thread. Interestingly, this
sometimes requires rewriting  the  interference relation so that 
the interference on the smaller state captures the same 
information as the interference on the bigger state. 


%\pgcomment{Not for here, section3:We give the main ideas behind the semantic model and the soundness of
%\colosl in \S\ref{sec:colosl}. In this section, we also provide proof
%rules to discharge \colosl-specific proof obligations by reducing them
%to regular separation logic validity checks. Thus one can use \colosl
%without having to reason directly in the model.}

\pgcomment{damn, out of time, chanllenge to say not too much but
  something of token ring, main points: resource of individual threads
is two cells, interferences requires three cells, and extendsion, feel
free to have a go Jules}

 We demonstrate 
\colosl reasoning on a range of
examples.  The first example in \S\ref{sec:intuition} is 
 Dijkstra's token-ring mutual exclusion
algorithm~\cite{dijkstra74}. Once the ring has achieved a stable
state, the overall  behaviour of the token
ring is that the master increments its cell when the cell at the otehr
end of the ring is  equal
and all other threads increments their  cells when the 
previous cell is one bigger. \colosl can reason compositionally about
this example. 
.....



This example is interesting because the
threads access two shared overlapping cells, much like the list example described
earlier, whose intereference depends on three cells. The global shared reourse of the whole token ring describes 



demonstrates the use of
subjective views to only work with the shared resource being accessed
by an individual thread. 


, with each
thread responsible for changing one heap cell but constrained by the
behaviour of the two thread. 


As well as the local knowledge about how
each thread behaves, the programmer also has global knowledge about
how threads constrain one another. Pleasantly, our reasoning captures
just that. 


In \S\ref{sec:examples}, we study two further examples. The first is a concurrent spanning tree
algorithm for graphs, where threads are recursively spawned on 
potentially overlapping sub-graphs. We demonstrate that the flexible,
overlapping subjective views of \colosl are just what we need.  We
also verify a concurrent set module implemented using a hand-over-hand
list-locking algorithm.



 that significantly improves over the existing
proof~\cite{cap-ecoop10}.

Most of the technical details have been left out due to space
constraints, and are provided in the appendix as well as in an
accompanying technical report~\cite{colosl-tr14}.

%This paper presents the program logic \colosl, which achieves
%compositional reasoning for concurrent programs by enabling
%\emph{subjective} views of the shared state. Subjective views may be
%composed arbitrarily and manipulated so as to retain only the portions
%of local and shared state actually accessed by each thread in the
%program, and to consider only the interferences relevant to that piece
%of shared state. \colosl achieves a greater degree of compositionality
%than existing work by enabling \emph{finer-grained} sharing: the
%program logic can consider that threads share only what is relevant to
%their function, a key ingredient of compositionality.
%
%
%
%Driven by the ever-increasing need for concurrency in software,
%%  spurred by recent hardware developments, 
%program logics for shared-memory concurrency have progressed towards
%the twin ideals of fine-grain reasoning and compositionality. The
%former enables elegant proof techniques about increasingly subtle
%concurrency idioms~\cite{vv06popl,vv07msc,todo}, while the latter
%allows programs to be proved component-wise and their proofs to be
%reusable as-is in any client
%program~\cite{csl-tcs,cap-ecoop10,icap}.
%%  Central to these compositional verification frameworks is the
%% formalism used to describe both the state shared between program
%% threads and the possible interference on that state.
%%
%% dating back from Owicki~\cite{owicki}, and later Jones who
%% integrated the notion of interference in the logic
%% itself~\cite{rg}.
%% 
%
%% Consider for instance
%% a program where threads operate on subgraphs of a global graph.
%
%
%%  dubbed their \emph{subjective states}.  One may then reuse these
%%   specifications in the context of any larger local state (as is
%%   standard in separation logic~\cite{rey02}), and, crucially for
%%   compositional reasoning about concurrent programs, any larger
%%   shared state. The subjective states of different threads in a
%%   program are allowed to overlap arbitrarily, ensuring maximum
%%   reusability of proofs.
%
%
%
%
% Subjective views can expand or contract depending on the resources required by the thread, which has subtle consequences for the logical reasoning. In particular, it is possible to strengthen actions in $I$ to record  some global information known to the subjective view.
%Then, the view can be weakened to just the resources and possibly strengthened actions appropriate to  the thread. The strengthened actions retain  some global information despite the weakened view. 


\pgcomment{Not touched related work} 

\paragraph{Related work}

--------------

Jones' rely-guarantee reasoning~\cite{rg} provided a
breakthrough in compositional reasoning about concurrent programs. It
describes permitted interferences between threads using rely and
guarantee conditions: the current thread guarantees that it will only
interfere in ways described by the guarantee relation; it relies on
the other threads (the environment) to interfere only  in ways
described by the rely relation. However, the original work is based on
first-order logic for reasoning aboutn
a single global heap. O'Hearn and Reynold's
work on separation logic~\cite{2001popland john's survey} demonstrated that such reasoning is not
fully compositional and does not scale. 

------------
\colosl stems from a long lineage of program logics for shared-memory
concurrency, dating back to the Owicki-Gries logic~\cite{owicki}, each of
which made substantial advances in fine-grained compositional
reasoning about more and more complex concurrent programs. As noted by
Jones, and motivating his definition of rely-guarantee~\cite{rg},
Owicki-Gries's system is fundamentally non-compositional as assertions
at each program point in each thread have to be checked against every
instruction of every other thread. While rely-guarantee addresses
this concern by summarising potential interferences in terms of rely
and guarantee conditions, its model of the shared state is global,
even encompassing the threads' private state. Later techniques
combined rely-guarantee with separation logic, starting with
RGSep~\cite{viktor-marriage}, which separates private (local) and
shared state, allowing further compositionality. However, the view of
the shared state and interference on it is still globally shared
across threads. 

The next breakthrough as far as compositionality is
concerned came from LRG~\cite{lrg}, wherein the shared state may be
split into completely independent pieces, thus partially solving the
first problem outlined above. This provides a way to frame off parts
of the shared state but, as noted by its author, the strong
disjointness restrictions make this applicable only at the level of
disjoint modules in the code. Independently from LRG, the reasoning
framework of CAP~\cite{cap-ecoop10}
and its extended variants~\cite{icap,tada} introduced the notion
of \emph{regions} of the shared state. Much like LRG, the division into
regions is only possible for entirely disjoint pieces of state, with
fixed and disjoint interference relations.

Finally, Subjective Concurrent Separation Logic (SCSL)~\cite{SCSL}
uses \emph{subjective auxiliary states}, similar in spirit to our
subjective views for the shared state, to reason about \emph{coarse-grained}
concurrency. As noted by its authors, while CAP (and by design \colosl) can
be employed to reason about their studied examples, SCSL cannot be
used to reason about the fine-grained concurrency scenarios that \colosl tackles.
