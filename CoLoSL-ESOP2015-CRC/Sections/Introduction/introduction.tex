\section{Introduction}
\label{sec:introduction}


%\pg{This is what we should answer by the introduction: 
%What's the problem with the current state of the art?
%What is our solution?
%Why is the problem we're solving hard?
%How do we solve the challenges?
%Why do we do better than existing work?
%What are the lessons learnt from the paper?}

A key difficulty in verifying properties of fine-grained concurrent
programs is being able to reason compositionally about each thread in
isolation, even though in reality the correctness of the whole system
is the collaborative result of intricately intertwined actions of the
threads.  Such compositional reasoning is essential for: verifying
large concurrent systems, since it allows them to be verified
component-wise;  verifying library code and incomplete programs,
since one does not need to know about the context of execution; and 
replicating a programmer's intuition about why their implementations
are correct, since their informal arguments are typically  kept local and do
not bring the whole system into the reasoning.


Rely-guarantee reasoning~\cite{rg} and various combinations of
rely-guarantee and separation-logic
reasoning~\cite{viktor-marriage,dg,lrg,cap-ecoop10,icap,tada} achieve
compositional reasoning for increasingly difficult inter-thread
interactions. However, despite substantial progress, we believe that
none of these approaches are fully compositional and question whether
some are as natural as they might be. They are all based on global
shared memory usually comprising disjoint regions with static
interference on these regions. Each thread is verified with respect to
these  regions.  


In contrast, we introduce the program
logic, \colosl, which is based on one global shared state with each
thread verified with respect to its partial {\em subjective view} of
this global state. The dynamic overlapping nature of subjective views
enables us to provide small natural specifications of previously
explored examples, as well as again increasing the kinds of examples
that can be verified.


Jones' rely-guarantee reasoning~\cite{rg} provided a
breakthrough in compositional reasoning about concurrent programs. It
describes permitted interferences between threads using rely and
guarantee conditions: the current thread guarantees that it will only
interfere in ways described by the guarantee relation; it relies on
the other threads (the environment) to only interfere in ways
described by the rely relation. However, the original work is based on
first-order logic for reasoning aboutn
a single global heap. O'Hearn and Reynold's
work on separation logic~\cite{2001popland john's survey} demonstrated that such reasoning is not
compositional and does not scale. 

The original separation logic~\cite{rey02,seplog} achieves
compositional reasoning for sequential heap-manipulating programs by
spliting the heap into disjoint heaplets for describing the local
disjoint resource required by a program. Compositionality rests on two
powerful mechanisms: a program  can be specified using only those
resources that it actually accesses; and this specification can be
simply reused in any context that contains these resources.
By making the specification
as small  as possible, we can ensure that it
can be reused in a large set of possible contexts using  the {\em frame
rule}. 
 Specification reuse is paramount to achieve compositional
reasoning: if the specification of a piece of code can be reused in
any valid context, we only have  to prove it once and for all. 


Concurrent separation logic extends this work to concurrent programs
using the {\em disjoint concurrency rule}, where individual threads
use both local resource and static invariant shared regions. Since
then, there has been many extensions combining rely-guarantee
reasoning with ideas from concurrent separation logic to reason about
fine-grained concurrency: RGSep~\cite{viktor-marriage} and then deny-guarantee reasoning~\cite{dg}
introduce local resource and shared disjoint regions which are stable
with respect to an interference relation stating how the current
thread and the environment can effect the region; CAP~\cite{cap-ecoop10} and its
extensions~\cite{hocap,icap,tada} in addition abstract the regions. This work has achieved substantial
success; see related work for more details. However, we believe that
none of these approaches are as natural and as  compositional as they
might be.  The problem is that the regions and their interference is
too static. 

First, the focus on static disjoint shared regions is too rigid.
Consider a binary graph accessed by a concurrent spanning tree
algorithm, as an example of a data structure with intrinsic sharing
which is accessed concurrently. Disjoint shared regions cannot
naturally be used to reason about such algorithms due to the arbitrary
sharing associated with the subgraphs. It might be possible to do some
coding trick with capabilities, but we wonder whether it will be
natural. Now consider a linked list consisting of $n+1$ nodes accessed
concurrently by $n$ threads (numbered $1$ to $n$) where the $i$th
thread requires access to the $i$th and $(i+1)$th nodes.  There is a
natural overlapping of the resources accessed by the threads which
cannot be mimicked by the reasoning. Since shared regions must be
disjoint, the reasoning can only work either with the entire linked
list or with individual nodes. This is in contrast with the code of a
thread which naturally touches two nodes.



Second, the focus on static interference on the regions is too rigid. 
The interference associated with each region is defined when
the region  is created and is fixed throughout the entire lifetime of
the region. However, the static interference  on a region might 
become irrelevant, either because the resources it acts on have been
deallocated or extra knowledge gained about the shared state
falsifies its requirements.  This incurs
a burden in the proof effort, as stability against these irrelevant
actions still has to be checked at every program point.
Also, the static interference on  a region has to predict all future 
uses of the region at the time of creation. 

\pgcomment{OK, I don't find this next bit convincing yet.}

. As such, upon its creation, provision
has to be made for all future extensions of it and it is generally not
possible to arbitrarily grow it with extra state under new
interference rules.  As we discuss in \S\ref{sec:examples}, this
results in unnatural specifications when dynamically-allocated
resources become shared during execution, such as in the concurrent
set module example of~\cite{cap-ecoop10}.



 \pgcomment{NOt touched from ehre.} 

\pgcomment{Not sure should be in:These issues, in particular the first one, not only affect the
locality of the reasoning, but also impede \emph{modularity} and proof
reuse. When the implementation of a module $M_1$ is verified against
its specification, its proof can only be reused from within another
module $M_2$ if either the parts of the shared state accessed by $M_2$
are disjoint from those of $M_1$, or the shared state is partitioned
identically for both modules. The probability that several modules
agree on the exact partition and shape of the shared resources is slim.}

This paper introduces the program logic \colosl,
\underline{Co}ncurrent \underline{Lo}cal \underline{S}ubjective
\underline{L}ogic, which addresses all three issues. \colosl models
shared resources as a single state, with a twist: the assertion
language allows threads to hold their own \emph{subjective views} of
this state. Each subjective (personalised) view is an assertion which
describes of \emph{parts} of the shared state, and how the thread and
the environment may affect these shared resources.  The subjective
views of different threads represent potentially \emph{overlapping}
parts of the shared state, in contrast with previous approaches that
either mandate that all threads view the same entire shared state, or
strictly disjoint parts of it. This allows us to provide a framing
mechanism both on shared resources as well as their interferences even
in the presence of overlapping footprints and entangled resources, and
resolve the first issue outlined above. Subjective views expand and
contract to the natural resources and the interference required by the
current thread, solving the second issue. Finally, the description of
the interference affecting a subjective view can be rewritten based on
the current knowledge of a thread, allowing one to forget once and for
all about irrelevant interference to address the third issue. These
features provide truly compositional reasoning for shared-memory
concurrency.


\pgcomment{Not for here, section3:We give the main ideas behind the semantic model and the soundness of
\colosl in \S\ref{sec:colosl}. In this section, we also provide proof
rules to discharge \colosl-specific proof obligations by reducing them
to regular separation logic validity checks. Thus one can use \colosl
without having to reason directly in the model.}

\pgcomment{now examples, we need to beef this up much more, will remove
  sections, we need to understand the examples story more.}

 We demonstrate how
\colosl allows local reasoning about the shared state on a range of
examples.  The first example in \S\ref{sec:intuition} admittedly
serves as a showroom for \colosl's main reasoning principles. It is a
variant of Dijkstra's token-ring mutual exclusion
algorithm~\cite{dijkstra74}. As well as the local knowledge about how
each thread behaves, the programmer also has global knowledge about
how threads constrain one another. Pleasantly, our reasoning captures
just that. In \S\ref{sec:examples}, we study two further, more
challenging examples. The first is a concurrent spanning tree
algorithm for graphs, where threads are recursively spawned on each
(potentially overlapping) sub-graph. We demonstrate that the flexible,
overlapping subjective views of \colosl are just what we need.  We
also verify a concurrent set module implemented using a hand-over-hand
list-locking algorithm that significantly improves over the existing
proof~\cite{cap-ecoop10}.
%
%Finally, we demonstrate how the mutual exclusion ring of \S\ref{sec:intuition} can be generalised to synchronise access to a concurrent database.

Most of the technical details have been left out due to space
constraints, and are provided in the appendix as well as in an
accompanying technical report~\cite{colosl-tr14}.

%This paper presents the program logic \colosl, which achieves
%compositional reasoning for concurrent programs by enabling
%\emph{subjective} views of the shared state. Subjective views may be
%composed arbitrarily and manipulated so as to retain only the portions
%of local and shared state actually accessed by each thread in the
%program, and to consider only the interferences relevant to that piece
%of shared state. \colosl achieves a greater degree of compositionality
%than existing work by enabling \emph{finer-grained} sharing: the
%program logic can consider that threads share only what is relevant to
%their function, a key ingredient of compositionality.
%
%
%
%Driven by the ever-increasing need for concurrency in software,
%%  spurred by recent hardware developments, 
%program logics for shared-memory concurrency have progressed towards
%the twin ideals of fine-grain reasoning and compositionality. The
%former enables elegant proof techniques about increasingly subtle
%concurrency idioms~\cite{vv06popl,vv07msc,todo}, while the latter
%allows programs to be proved component-wise and their proofs to be
%reusable as-is in any client
%program~\cite{csl-tcs,cap-ecoop10,icap}.
%%  Central to these compositional verification frameworks is the
%% formalism used to describe both the state shared between program
%% threads and the possible interference on that state.
%%
%% dating back from Owicki~\cite{owicki}, and later Jones who
%% integrated the notion of interference in the logic
%% itself~\cite{rg}.
%% 
%
%% Consider for instance
%% a program where threads operate on subgraphs of a global graph.
%
%
%%  dubbed their \emph{subjective states}.  One may then reuse these
%%   specifications in the context of any larger local state (as is
%%   standard in separation logic~\cite{rey02}), and, crucially for
%%   compositional reasoning about concurrent programs, any larger
%%   shared state. The subjective states of different threads in a
%%   program are allowed to overlap arbitrarily, ensuring maximum
%%   reusability of proofs.
%
%
%
%
% Subjective views can expand or contract depending on the resources required by the thread, which has subtle consequences for the logical reasoning. In particular, it is possible to strengthen actions in $I$ to record  some global information known to the subjective view.
%Then, the view can be weakened to just the resources and possibly strengthened actions appropriate to  the thread. The strengthened actions retain  some global information despite the weakened view. 


\paragraph{Related work}
\colosl stems from a long lineage of program logics for shared-memory
concurrency, dating back to the Owicki-Gries logic~\cite{owicki}, each of
which made substantial advances in fine-grained compositional
reasoning about more and more complex concurrent programs. As noted by
Jones, and motivating his definition of rely-guarantee~\cite{rg},
Owicki-Gries's system is fundamentally non-compositional as assertions
at each program point in each thread have to be checked against every
instruction of every other thread. While rely-guarantee addresses
this concern by summarising potential interferences in terms of rely
and guarantee conditions, its model of the shared state is global,
even encompassing the threads' private state. Later techniques
combined rely-guarantee with separation logic, starting with
RGSep~\cite{viktor-marriage}, which separates private (local) and
shared state, allowing further compositionality. However, the view of
the shared state and interference on it is still globally shared
across threads. 

The next breakthrough as far as compositionality is
concerned came from LRG~\cite{lrg}, wherein the shared state may be
split into completely independent pieces, thus partially solving the
first problem outlined above. This provides a way to frame off parts
of the shared state but, as noted by its author, the strong
disjointness restrictions make this applicable only at the level of
disjoint modules in the code. Independently from LRG, the reasoning
framework of CAP~\cite{cap-ecoop10}
and its extended variants~\cite{icap,tada} introduced the notion
of \emph{regions} of the shared state. Much like LRG, the division into
regions is only possible for entirely disjoint pieces of state, with
fixed and disjoint interference relations.

Finally, Subjective Concurrent Separation Logic (SCSL)~\cite{SCSL}
uses \emph{subjective auxiliary states}, similar in spirit to our
subjective views for the shared state, to reason about \emph{coarse-grained}
concurrency. As noted by its authors, while CAP (and by design \colosl) can
be employed to reason about their studied examples, SCSL cannot be
used to reason about the fine-grained concurrency scenarios that \colosl tackles.
