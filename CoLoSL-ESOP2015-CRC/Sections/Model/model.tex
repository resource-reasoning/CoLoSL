\section{\colosl}\label{sec:colosl}
We now give a more formal overview of how to use \colosl for program
verification, eschewing some details of the semantics for lack of
space, while still providing enough ingredients to carry program
proofs. We describe the underlying model of \colosl, give the
semantics of \colosl assertions, then present proof rules to reduce
the various obligations typically encountered in proofs (namely, the
side-conditions of \shiftRule and \extendRule, and stability checks)
to classical separation logic entailments that, in
particular, do not mention subjective views.


\subsection{\colosl worlds}
\label{subsec:model}

A \emph{world} is a triple $(l, g, \lmod)$ where $l$ and $g$ are
\emph{logical states} and $\lmod$ is an \emph{action model}. The
\emph{local logical state} (or local state) $l$ represents the
locally owned resources of a thread, in the standard separation logic
sense, while the \emph{global logical state} (or shared state)
$g$ represents shared resources. An action model records all possible interferences on the shared state.

Logical states have two components: one describes machine states
(e.g.\ stacks and heaps); the other represents
\emph{capabilities}. The latter are inspired by the capabilities in
deny-guarantee reasoning~\cite{dg}: a thread in possession of a given
capability is allowed to perform the associated actions (as prescribed
by the \emph{action model} component of each world, defined below),
while any capability \emph{not} owned by a thread means that the
environment can perform the action. This can be seen as a unified
treatment of the rely and guarantee relations in rely-guarantee
reasoning~\cite{rg}: a capability fully owned (resp.\ fully not owned)
during the entire lifetime of a thread represents its guarantee
(resp.\ its rely), while a partially-owned capability means that the
corresponding action is both in the rely and the
guarantee. Capabilities go beyond the rely-guarantee model~\cite{dg};
in particular, they may be transferred between a thread and its
environment just like any other resource to temporarily block or enable certain actions. See the presentation of
deny-guarantee~\cite{dg} (or CAP~\cite{cap-ecoop10}) for further details
and motivation.

In general, each component of a logical state is taken from an
arbitrary \emph{separation algebra}~\cite{asl} (i.e.\ a cancellative,
partial commutative monoid) that satisfies the
\emph{cross-split} property\footnote{A monoid
  $(\mathbb{A}, +, \mathbf{1})$ satisfies the cross-split property iff
  for all $a, b, c, d \in \mathbb{A}$, if $a + b = c + d$, there
  exists $x, y, z, w \in \mathbb{A}$ s.t.\ $a = x + y$, $b = z + w$,
  $c = x + z$, and $d = y + w$.}\cite{dockins2009fresh} (this is
needed for $**$ to be associative~\cite{ramification}).  As we demonstrate in the examples of
\S\ref{sec:examples}, our programs often call for a more complex model
of machine states and capabilities than that presented here. For instance, we may need our
capabilities to be fractionally owned, where ownership of a
\emph{fraction} of a capability grants the right to perform the action
to both the thread and the environment, while a fully-owned capability
by the thread \emph{denies} the right to the environment to perform
the associated action.  For ease of presentation, the focus of this
paper is on the standard stack and heap model for machine states, and
finite sets of \emph{tokens} (which are simple names) for
capabilities. We assume a set of program values $\set{Val}$, as well as infinite disjoint sets $\set{PVar}$, $\set{Loc}$, and $\set{Token}$ of program variables, memory locations, and tokens, respectively.

\begin{definition}[Logical states]
  A \emph{logical state} is a tuple $((@s, h), \ca{}) \in \LStates$, also written
  $(@s,h,\ca{})$, of a finite partial \emph{stack} $@s\in \set{Stack}$ associating
  program variables with values, a \emph{heap} $h \in \set{Heap}$ associating heap
  locations with values, and a \emph{capability} $\ca{} \in \Caps$:
  \begin{mathpar}
    \set{Stack} == \set{PVar} --`_{\m{fin}} \set{Val}
    
    \set{Heap} == \set{Loc} --`_{\m{fin}} \set{Val}
    
    \Heaps == \set{Stack}\times \set{Heap}
    
    \Caps == \powerset_{\m{fin}}(\set{Token})
    
    \LStates == \Heaps\times \Caps
  \end{mathpar}
\end{definition}

The local and global logical states of a world are always
\emph{compatible}: they can be composed with one another. This captures the intuition that locally-owned resources are disjoint from shared resources. The composition of logical states is defined component-wise as disjoint function union $\uplus$ over stacks and heaps, and disjoint set union $\uplus$ on capabilities.

\begin{definition}[Logical state composition]
  The \emph{composition of logical states} $ \composeL : \LStates
  \times \LStates \rightharpoonup \LStates $ is defined
  as:
  \[
  ((@s, h),\ca{}) \composeL ((@s', h'), \ca{}') \eqdef
  ((@s\uplus @s', h\uplus h'), \ca{}\uplus \ca{}')
  \]
  %% The \emph{separation algebra of logical states} is given by
  %% $(\LStates, \composeL, \unitL)$.
\end{definition}

We write $l$ to range over either arbitrary logical states or just
local states, and $g$ to range over logical states representing global
states. The empty logical state $(\emptyset, \emptyset, \emptyset)$ is
written $\unitL$. We write $l_1 \leq l_2$ when there exists $l$ such
that $l\composeL l_1 = l_2$, and write $l_2 - l_1$ to denote the
unique such $l$ (by cancellativity) when it exists. When $l_1\composeL
l_2$ is defined, we say that $l_1$ and $l_2$ are \emph{compatible} and
write $l_1\compatL l_2$.
%% Given a logical state $l= (@s, h, \ca{})$, we write $l_{@s}, l_h$
%% and $l_{\ca{}}$ for the first, second, and third projections,
%% respectively and write $l_{\textsf{M}}$ for $(@s, h)$.

An action is a triple $(p, q, c)$ of logical states where $p$ and $q$
<<<<<<< HEAD
are the action \emph{pre-} and \emph{post-states} describing how the
shared state is modified by the action; and $c$ is the action
\emph{catalyst}. An action catalyst has to be present for the action
to take effect, but is left unchanged by the action. It is maximal in
the sense that no further, non-empty catalyst $c'$ can be found such
that $c' \leq p$ and $c' \leq q$\footnote{Alternatively, the catalyst
could be computed a posteriori for each action.  However, we often
need to isolate the part of the state that is modified by an action,
hence our technical choice of recording the catalyst in the model.}. 
For instance, \label{ex:sxsem} as we shall shortly
see, $s_x$ in \fig\ref{fig:concurrentInc} will be interpreted as the
set of actions $S=\{((\emptyset, \{\ell:v\}, \emptyset),
(\emptyset, \{\ell:v{+}1\}, \emptyset), (\emptyset, \{\ell{-}1:v{+}1\},
\emptyset))\mid v \in \Nats\}$, where $\ell$ is the value of $x$ in the
current logical environment. 
%We record the action catalyst separately
%for technical convenience. As we will shortly demonstrate (see
%\emph{worlds} below), we often need to refer to the action pre-state
%in isolation, i.e. only those parts of the shared state modified by
%the action.

An action model is a partial function from \emph{capabilities} to sets
of \emph{actions}. It corresponds to the semantic interpretation of an interference assertion.
%
\begin{definition}[Action models]
  The set $\set{Action}$ of \emph{actions}, ranged over by $a$, and
  the set $\AMods$ of \emph{action models}, ranged over by $\lmod$,
  are defined as:
  \begin{mathpar}
    \set{Action} == \LStates \times \LStates \times \LStates
    
    \AMods == \Caps \rightharpoonup \pset{\set{Action}}
  \end{mathpar}
%  We write $\unitAM$ for an action model with empty domain.
\end{definition}

Worlds are triples $(l,g,\lmod)\in\LStates\times\LStates\times\AMods$
that satisfy several well-formedness conditions: the local and shared
states are compatible; the capabilities owned by $l$ and $g$ are in
the domain of $\lmod$; and actions in $\lmod$ are \emph{confined} to
$g$ (written $g\containI\lmod$).  An action $a = (p, q, c)$ is
confined to $g$ if and only if whenever it is enabled ($p \composeL c$
is compatible with $g$), then its pre-state $p$ is contained in $g$
($p \leq g$). We motivate the need for the confinement condition in
\S\ref{subsec:prules}.
%We provide an informal description of confinement in
%\S\ref{subsec:prules}. The formal definition of confinement is given in~\cite{colosl-tr14}.

\begin{definition}[Well-formedness]
  \label{def:wf}
  A triple $(l, g, \lmod)\in\LStates\times\LStates\times\AMods$ is \emph{well-formed},
  written $\wf{l, g, \lmod}$, iff $l \compatL g$, $l_{\ca{}} \cup
  g_{\ca{}} \subseteq \bigcup \m{dom}(\lmod)$, and $g \containI \lmod$.
%%   \vspace{-1ex}
%%   \[
%%   \begin{array}{L}
%%     l \compatL g
%%     /|
%%     l_{\ca{}} \cup g_{\ca{}} \subseteq \bigcup \m{dom}(\lmod)
%%     /|
%%     g \containI \lmod
%%   \end{array}
%% \vspace{-1ex}
%% \]
\end{definition}

\begin{definition}[Worlds]\label{def:worlds}
The set $\Worlds$ of \emph{worlds} consists of all well-formed triples.
%% \[
%% 	\Worlds \eqdef 
%% 	\{w\in \LStates\times\LStates\times\AMods ||| \wf{w}\}
%% \]
\end{definition}

%% Worlds do not put further constraints on the
%% relationship between $\lmod$ and $g$, they are however linked more tightly in
%% the semantics of assertions (\S\ref{subsec:assertions}).

Finally, the composition of two worlds is defined when their local states are compatible, their global shared states and action models are the same, and the resulting tuple is well-formed.

\begin{definition}[World composition]
  The \emph{composition} of worlds, $\composeW: \Worlds \times \Worlds \rightharpoonup \Worlds$, is defined as:
  \[
	(l,g,\lmod) \composeW (l',g',\lmod') \eqdef
	\begin{cases}
		(l\composeL l', g, \lmod) &
		\begin{array}[t]{L}
			\text{if }
			g = g' \text{, and }
			\lmod = \lmod' \text{, and }\p{wf}((l\composeL l', g, \lmod))
		\end{array}\\
		\textit{undefined}&\text{otherwise}
	\end{cases}
\]
\end{definition}

%% The set of well-formed worlds with composition $\composeW$ forms a
%% separation algebra with multiple units: all well-formed worlds of the
%% form $(\unitL,g,\lmod)$.

\subsection{\colosl Assertions}
\label{subsec:assertions}

Our assertion language extends separation logic with \emph{subjective
  views} and \emph{capability assertions}.

\colosl is parametric in the assertions of machine states and
capabilities and can be instantiated with any assertion language over
machine states $\Heaps$ and capabilities $\Caps$. In this paper, we
use standard heap and stack assertions for machine state assertions,
and single-token assertions of the form $[\token{a}]$ for capability
assertions where $\token{a} \in \set{Token}$. We write $[\token{A}]$
as a shorthand for $\bigvarstar_{\token{a} \in \token{A}} [\token{a}]$.
We assume an infinite set $\set{LVar}$ of \emph{logical variables},
disjoint from $\set{PVar}$.

\begin{definition}[Assertion syntax]\label{def:assertions}
Given $x \in \set{LVar}$, $\li{x} \in \set{PVar}$, and $\token{a} \in \set{Token}$, \emph{the assertions of \colosl}, $\Assertions$, are described by the grammars below:
%
\begin{align*}	 
  \LAssertions \ni \lass{p}, \lass{q} & ::=
  \begin{array}[t]{@{}l@{}}
  \m{false} \mid E_1 = E_2
  \mid \emp \mid \li{x} \harpoonything E \mid E_1 |-> E_2 \mid [E]\\
  \null\mid \lass{P} \lor \lass{Q} \mid  \neg\lass{P} \mid \exsts{x} \lass{P}
  \mid \lass{P} * \lass{Q} \mid \lass{P} ** \lass{Q} \mid
  \lass{P} \septraction \lass{Q}
  \end{array}\\
  \Assertions \ni P,Q & ::= \lass{P} \mid \exsts{x} P \mid P \lor Q \mid P * Q \mid P ** Q \mid \shared{P}{I}  \\
  I &::= \emptyset \mid \{\interAss{[\token{A}]}{\bar{x}}{P}{Q}\} \cup I
  \qquad
  E ::= x \mid \token a \mid E_1 + E_2 \mid \cdots
\end{align*}
\end{definition}

The syntax and semantics of \emph{local assertions} $\LAssertions$ are
as in standard separation logic with
variables-as-resource~\cite{variablesAsResource}.\footnote{Note in
  particular that expressions $E$ do not allow program variables: they
  can only appear on the left-hand side of $\li{x} \harpoonything E$.}
Local assertions are interpreted over a world's local state. The assertion $\li{x}
\harpoonything E$ denotes a singleton stack where \li{x} has value
$E$. Similarly, $E_1|->E_2$ is true of the singleton heap where only
address $E_1$ is allocated and has value $E_2$.  The capability
assertion $[E]$ is true of the singleton capability $\{\token{a}\}$ if
$E$ evaluates to $\token a$. The empty local state $\unitL$ is denoted
by $\emp$. The \emph{separating conjunction} $\lass{P} * \lass{Q}$ is
true when the local state can be split into two according to
$\composeL$ such that one state satisfies $\lass{P}$ and the other
satisfies $\lass{Q}$. The \emph{overlapping conjunction}
$\lass{P}**\lass{Q}$ is true when the local state can be split
three-ways according to $\composeL$, such that the
$\composeL$-composition of the first two states satisfies $\lass{P}$
and the $\composeL$-composition of the last two satisfy
$\lass{Q}$~\cite{ramification,gareth-js12,rey-slnotes}. \emph{Septraction}
(or \emph{existential magic wand}) $\lass{P}\septraction\lass{Q}$ is
true when there exists a local state satisfying $\lass{P}$ that can be
$\composeL$-composed with the current one to yield a state satisfying
$\lass{Q}$. Classical predicates and connectives have their standard
classical meaning.

As in RGSep~\cite{viktor-marriage}, our assertions $\Assertions$ are
defined on top of local assertions. For simplicity, assertions do not
include negation nor septraction. The interpretation of assertions
is a simple lift from that of local assertions, with the exception
of the subjective views $\shared P I$.  First, an \emph{interference
  assertion} $I$ describes actions enabled by a given capability, in
the form of a pre- and postcondition.
%Following the RGSep style~\cite{viktor-marriage}, interference assertions $I$ describe actions enabled by a given capability, in the form of a pre- and postcondition ($P$ and $Q$ respectively) as well as a side-condition ($R$). We write $P \swap Q$ as a shorthand for $\action{P}{Q}{\emp}$.
A subjective view $\shared P I$ is then true of $(l,g,\lmod)$ when $l =
\unitL$ and a \emph{subjective state} $s$ can be found in the global
shared state $g$ (i.e.\ $g = s\composeL r$ for some
$r$), such that $s$ satisfies $P$ in the standard separation logic
sense, and $\lmod$ and $I$ \emph{agree} given the decomposition $s$,
$r$, in the following sense, which we write as
$\extendsAM{\lmod}{s}{r}{\semI{I}}$:
%Appendix~\ref{sec:model-continued}):
\begin{enumerate}
	\item every action in $I$ is reflected in $\lmod{}$;
	
	\item every action in $\lmod$ that has a visible effect on $s$ is reflected in $I$;
	
	\item the above holds after any number of actions in $\lmod$ takes place.
%	\item the above is true for any state resulting from any number of actions of $\lmod$ applied to $g$.
%	\item the above is true after any number of action applications in $I$ that affect $g$ and any number of action applications in $\gmod$ that affect $r$ but not $s$.
\end{enumerate}
Thus, given a world $(l,g,\lmod)$ and a subjective view $\shared P I$,
$P$ describes a subjective state $s$ that is \emph{parts} of $g$ and
$I$ describes \emph{all parts} of $\lmod$ concerning $s$, while
$\lmod$ describes the overall interference on $g$.  We refer to the
above agreement between the action model and the subjective view as
the \emph{action model closure property}. We omit its formal
definition for lack of space.
%; it can be found in~\cite{colosl-tr14}.

The semantics of \colosl assertions is given by a forcing relation
$w,\lenv|= P$ between a world $w$, a logical environment
$\lenv\in\LEnv$, and an assertion $P$. We use two auxiliary forcing
relations. The first one $l,\lenv\slsat p$ interprets local assertions
$p\in\LAssertions$ in the usual separation logic sense over a logical
state $l$. The second one $s,\lenv|=_{g,\lmod} P$ interprets
assertions $P\in\Assertions$ over a \emph{subjective state} $s$ that
is part of the global shared state $g$, subject to action model
$\lmod$. This third form of satisfaction is needed to deal with the
nesting of subjective views.\footnote{This presentation with several
  forcing relations differs from the usual CAP
  presentation~\cite{cap-ecoop10}, where formulas are first
  interpreted over worlds that are not necessarily well-formed, and
  then cut down to well-formed ones. The advantage of our presentation
  is that the semantics of assertions is \emph{compositional},
  e.g.\ the semantics of $P * Q$ follows directly from the semantics
  of $P$ and $Q$.}  Since logical connectives are interpreted
uniformly in all cases, we write $|=_\dagger$ for any of the three
satisfaction relations, $u$ for elements of either $\Worlds$ or
$\LStates$, and $\grey$ for either $\composeW$ or $\composeL$, as
appropriate.

\begin{definition}[Assertion semantics]\label{def:assertion-semantics}
Given a logical environment $\lenv: \set{LVar} --> \set{Val}$, the
semantics of \colosl assertions is defined below, using a semantics of
interference assertions $\semI[(.)]{.}: \LEnv \rightarrow \AMods$ also
defined below.
\vspace{-1ex}
\[
\begin{array}{R>{\null}l@{\ \,}c@{\ \,}l}
  (l,g,\lmod), \lenv &|= \lass{P}  &\text{iff}& l,\lenv \slsat \lass{P}\\
  
  (l,g,\lmod), \lenv &|= \shared P I &\text{iff}&
  l = \unitL \text{ and }
  \exsts{s,r}
  g = s\composeL r\text{ and }
  s, \lenv |=_{g,\lmod} P\text{ and }
  \extendsAM{\lmod}{s}{r}{\semI[\lenv]{I}}
\end{array}
\]
\vspace{-3.0ex}
\[
\begin{array}{R>{\null}l@{\ \,}c@{\ \,}l}
  s, \lenv &|=_{g,\lmod} \lass{P} &\text{iff}& s, \lenv \slsat \lass{P}\\
  
  s, \lenv &|=_{g,\lmod} \shared P I &\text{iff}&
  (s,g,\lmod), \lenv |= \shared P I\\

  u,\lenv &|=_\dagger \exsts x P
  &\text{iff}& \exsts v u, [\lenv|||x:v] |=_\dagger P\\
%  
%  u,\lenv &|=_\dagger \for{x} P
%  &\text{iff}& \for{v}u, [\lenv|||x:v] |=_\dagger P\\
  u,\lenv &|=_\dagger P \lor Q
  &\text{iff}& u,\lenv |=_\dagger P\text{ or }u,\lenv |=_\dagger Q\\
  u, \lenv &|=_\dagger P_1 * P_2 &\text{iff}&
  \exsts{u_1,u_2} u = u_1 \grey u_2\text{ and }
  u_1, \lenv |=_\dagger P_1 \text{ and }u_2, \lenv |=_\dagger P_2\\

  u, \lenv &|=_\dagger P_1 ** P_2 &\text{iff}&
  \exsts{u',u_1,u_2} u = u'\grey u_1\grey u_2\text{ and}\\
  &&&
  u' \grey u_1, \lenv |=_\dagger P_1 \text{ and }
  u' \grey u_2, \lenv |=_\dagger P_2\\	
  
%  l, \lenv &\slsat [E]
%  &\text{iff}&
%  l = (\emptyset,\emptyset, \{[|E|]_{\lenv}\})\\
%  &&\cdots\\
  
  l,\lenv &\slsat \m{false}  && \text{never}\\
  
  l, \lenv &\slsat \emp &\text{iff}&l = \unitL\\
  
  l,\lenv &\slsat E_1 = E_2
  &\text{iff}& [|E_1|]_{\lenv} = [|E_2|]_{\lenv}\\
  
  l, \lenv &\slsat \li{x} \harpoonything E
  &\text{iff}&
  l = (\{\li x: [|E|]_{\lenv}\}, \emptyset, \emptyset)\\
  
  l, \lenv &\slsat E_1|->E_2 
  &\text{iff}&
  l =
  (\emptyset, \{[|E_1|]_{\lenv}: [|E_2|]_{\lenv}\}, \emptyset)\\
  
%%   \end{array}
%% \]
%% \vspace{-3.0ex}
%% \[
%% \begin{array}{R>{\null}l@{\ \,}c@{\ \,}l}
  l, \lenv & \slsat [E]
  & \text{iff} &
  l = (\emptyset, \emptyset, \{[|E|]_{\lenv}\})\\
  
  l,\lenv &\slsat \neg \lass{P}
  &\text{iff}& l,\lenv \not\slsat \lass{P}\\
  
  l, \lenv &\slsat \lass{P} \septraction \lass{Q} &\text{iff}&
  \exsts{l'} l', \lenv \slsat \lass{P} \text{ and }
  l \compatL l'
  \text{ and }l \composeL l', \lenv \slsat \lass{Q}
\end{array}
\]
\vspace{-1em}
%
\begin{align*}
%\semI[\lenv]{I}(\token{A}) &==
%  \left\{
%  \begin{array}{@{}l@{\ }|@{\ }r@{}}
%    (p \composeL r, q \composeL r)&
%    \begin{array}{@{}l@{}}
%      \interAss{[\token{A}]}{\bar x}{P}{Q}{} \in I /|  \exsts{\bar{v}, \lmod} \\
%%      \lenv' = [\lenv|||\bar y:\bar v] \\
%%      /| (p \composeL r), \lenv'\slsat \sumA{P} 
%%      /| (q \composeL r), \lenv' \slsat \sumA{Q} \\
%      \quad p, [\lenv|||\bar x:\bar v]  |=_{p \composeL r, \lmod} P 
%      /| q, [\lenv|||\bar x:\bar v]  |=_{q \composeL r, \lmod} Q 
%    \end{array}
%  \end{array}
%  \right\}
\semI[\lenv]{I}(\token{A}) &==
  \left\{
  \begin{array}{@{}l@{\ }|@{\ }r@{}}
    (p, q, c )&
    \begin{array}{@{}l@{}}
      \interAss{[\token{A}]}{\bar x}{P}{Q} \in I /| \exsts{\bar{v}, \lmod, r, r'} \\
      \quad c = r \composeL r' \land \for{l} l \leq p \land l \leq q \implies l = \unitL/|\null\\
      \quad p \composeL r, [\lenv|||\bar x:\bar v]  |=_{p \composeL c, \lmod} P 
      /| q \composeL r,  [\lenv|||\bar x:\bar v]  |=_{q \composeL c, \lmod} Q 
    \end{array}
  \end{array}
  \right\}
%\semI[\lenv]{I}(\token{A}) &==
%  \left\{
%  \begin{array}{@{}l@{\ }|@{\ }r@{}}
%    (p, q, r \composeL c)&
%    \begin{array}{@{}l@{}}
%      \interAss{[\token{A}]}{\bar x}{P}{Q}{R} \in I /| \exsts{\bar{v}, \lmod} \\
%      \quad p, [\lenv|||\bar x:\bar v]  |=_{p \composeL r \composeL c, \lmod} P 
%      /| q, [\lenv|||\bar x:\bar v]  |=_{q \composeL r \composeL c, \lmod} Q \\
%      \quad r, [\lenv|||\bar x:\bar v]  |=_{p \composeL r \composeL c, \lmod} R /|
%      r, [\lenv|||\bar x:\bar v]  |=_{q \composeL r \composeL c, \lmod} R \\
%    \end{array}
%  \end{array}
%  \right\}
\end{align*}
\end{definition}

Note that, as in the CAP family~\cite{cap-ecoop10,icap,tada}, \colosl
cannot ensure that proved programs do not leak memory. This is because
of the following property of the semantics with respect to the shared
state (sometimes called ``intuitionistic semantics''~\cite{rey02}): if
$(l,g,\lmod), \lenv |= P$ then $(l,g\circ g',\lmod), \lenv |= P$.


Five of the principles of \fig\ref{fig:principles} are direct
consequences of the semantics.

\begin{lemma}
  \label{lem:assertion-facts}
  The \colosl reasoning principles 
  \forgetRule, \mergeRule, \shiftRule, \weakenRule, and \copyRule are valid.
  %% \begin{mathpar}
  %%       \infer{
  %%       	\shared{P}{I} * \shared{Q}{I'} \entails \shared{R}{I} * \shared{Q}{I'}
  %%       }
  %%       {
  %%       	R \entails P
  %%       	&
  %%       	P \sepish Q \entails R \sepish Q
  %%       }
  %% \end{mathpar}
\end{lemma}
\begin{proof}[sketch]
  The cases of \weakenRule and \copyRule are straightforward. For
  \forgetRule, \mergeRule, and \shiftRule, we note
  in~\cite{colosl-tr14} that action model closure is preserved by
  picking a smaller subjective state, taking the union of subjective
  states and their interference assertions, and shifting the
  interference assertion, respectively.
  %The full proof is provided in~\cite{colosl-tr14}.
  \qed
\end{proof}


\subsection{Reducing \colosl principles to separation logic entailments}
\label{subsec:prules}



We turn to the remaining two principles, \extendRule and \shiftRule,
and to the stability condition. These involve reasoning outside our
assertion language, potentially requiring semantic reasoning 
in the model. Fortunately, it is enough to work
with a partial 
axiomatisation  for all three conditions to verify
our examples. In this section, we give cut-down versions of these
rules for a fragment of the \colosl assertion language where the 
nesting of subjective views is not permitted   and  interference
assertions cannot mention subjective views. This restriction is easily
lifted: we can always \emph{flatten}
assertions with nested boxes into logically equivalent assertions with
no nesting; and  interference assertions  mentioning  other
subjective views in their actions may be rewritten into ones
that do not.  See~\cite{colosl-tr14} for the full details.% Appendix~\ref{sec:assertions-continued}.

%% Moreover, in the restricted case where actions and fences (see below)
%% can be expressed in a fragment extending the usual \emph{symbolic
%%   heaps} used in automatic tools based on separation logic, starting
%% with Smallfoot~\cite{smallfoot}, without inductive predicates but
%% including the $**$ connective (this corresponds to replacing $p$ with
%% $A$ in the grammar of assertions), the separation logic entailments
%% that need to be discharged once the rules of this section have been
%% applied can be verified automatically. Indeed, for this fragment, we
%% can extend the $--o$-elimination procedure of Calcagno et
%% al. in~\cite{vv07msc} to deal with $**$ as well. We leave the details
%% of this adaptation to Appendix~\ref{sec:assertions-continued}. The following standard definition will
%% be needed in the remainder of this section.


\paragraph{Confinement}

The soundness of \colosl hinges on the fact that the action model
$\lmod$ contains all the actions that could possibly affect the shared
state $g$. This was expressed as a well-formedness condition in the
definition of worlds~\ref{deinition4}, by a confinement relation that
actions in $\lmod$ are confined by a global state $g$, written $g
\confines \lmod$. It is also possible to extend $g$ at any time.  Any
part $l'$ of the local state can to migrate to the shared state under
a new set of actions $\lmod'$, yielding a new shared state $g\composeL
l'$ and action model $\lmod \cup \lmod'$. This migration is only
permitted if $\l ' \confines \lmod'$. This confinement condition means
that that the migration does not invalidate the views  of the threads.


The technical definition of confinement of an action model on a
logical state is given in the technical report~\cite{.}. Intuitively,
it means that whenever an action $a = (p, q, c)$ of
$\lmod'$ is enabled, the state $p$ must be a substate of $l'$.  It is
possible for some of the catalyst $c$ to lie outside $l'$, since the
fact that it does not change during the course of the action means
that it will not have an effect on the views of other threads.
For example, recall the interpretation of $s_x$ described on
page~\pageref{ex:sxsem} as $S=\{a_v \,{=}\, ((\emptyset, \{\ell\,{:}\,v\}, \emptyset), (\emptyset, \{\ell\,{:}\,v{+}1\}, \emptyset), (\emptyset, \{\ell{-}1\,{:}\,v{+}1\})) \mid v \in \Nats\}$. The action $a_0 = ((\emptyset, \{\ell\,{:}\,0\},
\emptyset), (\emptyset, \{\ell\,{:}\,1\}, \emptyset), (\emptyset,
\{\ell{-}1\,{:}\,1\}, \emptyset))$ is confined to the logical state
$l_0=(\emptyset, \{\ell\,{:}\,0\}, \emptyset)$ because $l_0$ is the first component of the
action, and state $(\emptyset, \{\ell{-}1\,{:}\,0\}, \emptyset)$
because it  is incompatible with the
action, but not state $(\emptyset, \{\ell{-}1\,{:}\,1\}, \emptyset)$ because the action can
potentially affect address $\ell$.
%Indeed $p \composeL c$ is compatible with $l_1$ and $l_3$, and the
%modified cells 10 and 12 are fully contained in $l_1$ but not in
%$l_3$; $p \composeL c$ is not compatible with $l_2$, hence $a$ has no effect on
%$l_2$ and is automatically confined to $l_2$. 
%
The definition of confinement also requires that all states resulting from the successive application of actions in $\lmod'$ themselves confine all actions in $\lmod'$. For instance, we also require that $l_1 = (\emptyset, \{\ell\,{:}\,1\}, \emptyset)$,  resulting from the application of $a_0$ on $l_0$, $l_2 = (\emptyset, \{\ell\,{:}\,2\}, \emptyset)$, resulting from the application of $a_1$ on $l_1$, and so forth, \emph{all} confine the actions in $S$. 
%This simple example does not show the full subtlety of confinement. We  also require that all states resulting from the successive application of actions in $\lmod'$ themselves confine all actions in
%$\lmod'$. 
Inspired by the LRG approach~\cite{lrg}, we achieve this by
first finding a set that is invariant under all actions in $\lmod'$
(called a \emph{fence}), then checking the confinement condition for
each action. We provide the technical details of confinement in~\cite{colosl-tr14}.

For our examples in this paper, it is in fact enough to work with confinement in the
logic. We lift the notion of confinement to the assertions and write
$P \confines I$ to denote that the set of states described by $P$
 confine the actions of interface assertion $I$.  In the logic, the shared state is extended by the resources in
$P$ under the interference assertion $I$ via the \extendRule principle,
which requires that $P\containI I$ be
established. 



\fig~\ref{fig:local-fencing-rules} presents a set of
rules which reduces  $P \containI I$ to a series of entailments in
ordinary separation logic. As expressed by the first rule,
$P \containI I$ holds if there is a weaker local assertion $\lass{F}$
that acts as a \emph{local fence} for $I$, written 
$\lass{F}\strictfences I$. This relation states that  $\lass{F}$
must be invariant under all actions of $I$ and must confine the
actions in $f$.  In~\cite{colosl-tr14},
%Appendix~\ref{sec:assertions-continued} 
we show that it is always possible to weaken an arbitrary assertion into a local assertion. This fencing condition is
checked for each action in $I$ (see the second rule). For each action
$\interAss{[\token{A}]}{\bar x}{\lass{P}}{\lass{Q}}$, the three remaining rules of the figure may
apply. In the first of these rules, the action cannot possibly fire,
because its precondition does not agree with $\lass{F}$: no state
satisfying $\lass{F}$ may be extended such that a subpart satisfies
$\lass{P}$. 
%The second of these rules allows one to trim the side-condition as it is left unchanged by the action. 
The second of these rules allows us  to trim neutral parts
$\lass{R}$ of an action $\interAss{[\token{A}]}{\bar x}{\lass{P}}{\lass{Q}}$
appears both in $\lass{P}$ and $\lass{Q}$, and $\lass{R}$ is \emph{exact}, i.e.\ satisfied by at most
one logical state\footnote{$\exact{p} ==
    \for{\lenv, l_1, l_2} l_1, \lenv \slsat p\text{ and }l_2, \lenv
    \slsat p\text{ implies } l_1 = l_2$},
then the part of the state denoted by $\lass{R}$ is uniquely
determined and left unchanged by the action. 
The last rule finally reduces local fencing to entailment checking, provided the fence
$\lass{F}$ can be expressed as a disjunction of \emph{precise}
assertions, i.e.\ assertions satisfied by at most one substate of each
logical state\footnote{$\precise{p} ==
    \for{\lenv, l, l_1, l_2} l_1\leq l\text{, }l_2\leq l\text{, }l_1,
    \lenv \slsat p\text{, and }l_2, \lenv \slsat p
    \text{ implies } l_1 = l_2$}. The
first premise states that $\lass{F}$ is invariant under the action
$\interAss{[\token{A}]}{\bar x}{\lass{P}}{\lass{Q}}$, similar to the way that RGSep encodes
stability checks as separation-logic entailments. Informally, it
reads: for any state in $f$, remove a part satisfying $p$,  add a
state satisfying $q$, and  the result should still be in $f$. The third
premise checks the confinement condition: given a state in local
assertion $f_i$ ($l_1\composeL l_2|= \lass{F}_i$), and 
a state in $p$ ($l_2 \composeL   l_3 |= p$ with $l_1$ and $l_3 $
disjoint), the the combined state ($l = l_1 \composeL \l_2 \composeL l_3$)
must also be in $f_i$.

\pgcomment{Have I got the last bit right???? Given time constraints, haven't followed:  (Hence, by precision of $\lass{F}_i$, we have $l_2\composeL
l_3\leq l_1\composeL l_2\composeL l_3 = l_1\composeL l_2$.) If
correct, should be in.} 



%an extension of it ($l = l_1 \composeL l_2 \composeL l_3$) where a subpart of $l$ satisfies $\lass{P}$ ($l_2 \compo%seL l_3 |= f_i$), the extension $l$ itself is also in $f_i$ ($l_1\composeL l_2\composeL
%l_3|=\lass{F}_i$,hence by precision of $\lass{F}_i$, we have $l_2\composeL
%l_3\leq l_1\composeL l_2\composeL l_3 = l_1\composeL l_2$)

%if a subpart of an extension of a state in $\lass{F}_i$ satisfies $\lass{P}$
%($l_1\composeL l_2|= \lass{F}_i$ and $l_2\composeL l_3 |= \lass{P}$),
%then it is also a subpart of that state ($l_1\composeL l_2\composeL
%l_3|=\lass{F}_i$, hence by precision of $\lass{F}_i$, $l_2\composeL
%l_3\leq l_1\composeL l_2\composeL l_3 = l_1\composeL l_2$).

\begin{figure}
\hrule\vspace{5pt}
\begin{mathpar}
	\infer{
	  P \confines I	
	}
	{
	  P \entails \fenceAss{}&
	  \fenceAss{} \strictfences I
	}
	
	\infer{
		\fenceAss{} \strictfences I
	}
	{
          \for{\left(\interAss{[\token{A}]}{\bar x}{\lass{P}}{\lass{Q}}\right)\in I}\fenceAss{} \strictfences \left\{\interAss{[\token{A}]}{\bar x}{\lass{P}}{\lass{Q}} \right\}
	}		

	\infer{
		\fenceAss{} \!\strictfences\! \left\{\interAss{[\token{A}]}{\bar x}{\lass{P}}{\lass{Q}} \right\}		
	}
	{
		\fenceAss{} \sepish \lass{P} \slentails \m{false}
	}	

	\infer{
		\fenceAss{} \strictfences \left\{\interAss{[\token{A}]}{\bar x}{\lass{P}}{\lass{Q}}\right\}	
	}
	{
    \lass{P} \slentails \lass{P'} * \lass{R}\\
    \lass{Q} \slentails \lass{Q'} * \lass{R}\\
	  \exact{\lass{R}}\\
	  \fenceAss{} \strictfences \left\{[\token{A}]\!\!: \exsts{\bar x} \lass{P'} \swap \lass{Q'} \right\}
	}	
		
%	\infer{
%		\fenceAss{} \strictfences \left\{\capAss{}: \lass{P} \swap \lass{Q} \right\}		
%	}
%	{
%		\fenceAss{}' \slentails \fenceAss{}
%		&
%		\fenceAss{} \sepish \lass{P} \slentails \fenceAss{}' \sepish \lass{P}
%		&
%		\fenceAss{}' \strictfences \left\{\capAss{}: \lass{P} \swap \lass{Q} \right\}		
%	}
%		
	\infer{
		\fenceAss{} \strictfences \left\{\interAss{[\token{A}]}{\bar x}{\lass{P}}{\lass{Q}} \right\}		
	}
	{	
%		\separate{\lass{P}}{\lass{Q}}
%		&
		\left(\lass{P} \septraction \fenceAss{} \right) * \lass{Q} \slentails \fenceAss{}	
		\\
		\fenceAss{} \!<=>\! \bigvee_{i \in J}\fenceAss{i} 		
		\\
		(\precise{\fenceAss{i}}
		\land
		\fenceAss{i} \sepish \lass{P} \slentails \fenceAss{i}
		\;\;\text{for } i \in J)
	}	
%	{
%		\begin{array}{@{} l @{}}			
%			\separate{\lass{P}}{\lass{Q}}
%			\quad
%			\left(\lass{P} \septraction \fenceAss{} \right) * \lass{Q} \slentails \fenceAss{}	
%			\quad
%			\fenceAss{} <=> \bigvee\limits_{i \in I}\fenceAss{i} 		\\
%			%
%			\precise{\fenceAss{i}}
%			\quad 
%			\fenceAss{i} \sepish \lass{P} \slentails \fenceAss{i}
%			\quad
%			\text{for } i \in I
%		\end{array}
%	}	
%	
\end{mathpar}
\hrule
\caption{Selected confinement and local fencing rules. We assume that variables in
  $\bar x$ do not appear free in $\lass{F}$ and  $\lass{F}_i$ for any $i$.}
\label{fig:local-fencing-rules}
\end{figure}



\paragraph{Shifting and fencing}
\fig\ref{fig:shifting-rules} presents a partial axiomatisation of the
shifting condition $	I \weakenI{P} I'	$ required by the \shiftRule
principle.
As
with confinement, we omit the direct semantic definition.
% Appendix~\ref{sec:model-continued}.
%
%In Appendix~\ref{sec:assertions-continued} we also axiomatise
%non-intersection directly, which provides an alternative way to check
%non-intersection for a restricted fragment of formulas.
%
\begin{figure}
\hrule
\begin{mathpar}
	\infer{
		I \weakenI{P} I'	
	}
	{
		P \entails \fenceAss{}\\
		I \weakenI{\fenceAss{}} I'
	}	
	
	\infer{
	  I\weakenI{\fenceAss{}} I
	}{}
	
	\infer{
		I \cup I_1 \weakenI{\fenceAss{}} I \cup I_2
	}
	{
		\fenceAss{} \fences I \cup I_1	
		\\
		I_1 \weakenI{\fenceAss{}} I_2
	}	

%	\infer{
%		\left\{\interAss{[\token{A}]}{\bar x}{\lass{P}}{\lass{Q}}{\lass{R}} \right\} \equiv^{\fenceAss{}}
%		\left\{\interAss{[\token{A}]}{\bar x}{\lass{P'}}{\lass{Q'}}{\lass{R} * \lass{R}'} \right\}
%	}
%	{
%          \lass{P} \slentails \lass{P'} * \lass{R'}\\
%          \lass{Q} \slentails \lass{Q'} * \lass{R'}\\
%	  \exact{\lass{R'}}\\
%	}	
%	
%%	\infer{
%%		\left\{ [\token{A}]: \exsts{\bar x}\lass{P}  \swap \lass{Q} \right\} \weakenI{\fenceAss{}}
%%		\emptyset
%%	}
%%	{
%%          \lass{P} \slentails \lass{P'} * \lass{R}\\
%%          \lass{Q} \slentails \lass{Q'} * \lass{R}\\
%%	  \exact{\lass{R}}\\
%%	  \separate{\fenceAss{}}{\lass{P'}}
%%	}	
	\infer{
		\left\{\interAss{[\token{A}]}{\bar x}{\lass{P}}{\lass{Q}} \right\} \weakenI{\fenceAss{}}
		\emptyset
	}
	{
		\lass{P} \slentails \lass{P'} * \lass{R}\\
    \lass{Q} \slentails \lass{Q'} * \lass{R}\\
	  \exact{\lass{R}}\\
	  \separate{\fenceAss{}}{\lass{P'}}
	}	

	\infer
%	[\proofRule{False-R}]
	{	
		\left\{[\token{A}]: \exsts{\bar x}\lass{P} \swap \lass{Q} \right\} \weakenI{\fenceAss{}} 
		\emptyset 	
	}
	{
%		& \fenceAss{} \fences  \left\{ [\token{A}]: \left\{ P \swap Q \right\}\right\}
		\left(\lass{P} \septraction (\fenceAss{} \sepish \lass{P} )\right) * \lass{Q} \slentails \m{false}
	}	
	
	\infer
%	[\proofRule{Expand/Contract}]
	{
		\left\{\interAss{[\token{A}]}{\bar x}{\lass{P}}{\lass{Q}} \right\} \;\equiv^{\fenceAss{}}\;  \bigcup_{i \in J} \left\{\interAss{[\token{A}]}{\bar x}{\lass{P} * \lass{R}_i}{\lass{Q} * \lass{R}_i} \right\}	
	}
	{
		\fenceAss{} \sepish \lass{P} \slentails \bigvee_{i \in J} \fenceAss{} \sepish \left(\lass{P} * \lass{R}_i \right)
		\\
		\exact{\lass{R}_i} \text{ for } i \in J
	}

	\infer
%	[\proofRule{Disj}]
	{
	  \bigcup_{i \in K,j\in J}\!\! \left\{[\token{A}]\!:\!\exsts{\bar{x}} \lass{P}_i \!\swap\! \lass{Q}_j \right\}
	  \mathrel{\equiv^{\m{true}}}
	  \left\{\![\token{A}]\!: \exsts{\bar{x}}
          \bigvee_{i \in K} \lass{P}_i \!\swap\!
          \bigvee_{j\in J}\lass{Q}_j \right\} 
	}
	{
	}

	\infer{
		\m{true} \fences I	
	}{}	

	\infer{
		\fenceAss{} \fences I
	}
	{
          \for{[\token{A}]: \exsts{\bar x}\lass{P} \swap \lass{Q}\in I}\fenceAss{} \fences \left\{[\token{A}]: \exsts{\bar x}\lass{P} \swap \lass{Q} \right\}
	}		

	\infer{
		\fenceAss{} \fences \left\{\interAss{[\token{A}]}{\bar x}{\lass{P}}{\lass{Q}} \right\}		
	}
	{
		\separate{\lass{P}}{\lass{Q}}
                \\
		\left(\lass{P} \septraction (\fenceAss{} \sepish \lass{P}) \right) * \lass{Q} \slentails \fenceAss{}
	}

	\infer{
		\fenceAss{} \fences \left\{[\token{A}]\!\!:\exsts{\bar x} \action{\lass{P}}{\lass{Q}} \right\}	
	}
	{
		\separate{\fenceAss{}}{\lass{P}}
	}	

	\infer{
	  \fenceAss{} \fences \left\{\interAss{[\token{A}]}{\bar x}{\lass{P}}{\lass{Q}} \right\}
	}
	{
		\lass{P} \slentails \lass{P'} * \lass{R}&
    \lass{Q} \slentails \lass{Q'} * \lass{R}&
	  \exact{\lass{R}}&
	  \fenceAss{} \!\fences\! \left\{[\token{A}]\!\!:\exsts{\bar x} \lass{P'} \swap \lass{Q'} \right\}
	}	
%	\infer{
%		\fenceAss{} \fences \left\{[\token{A}]: \lass{P} \swap \lass{Q} \right\}		
%	}
%	{
%		\fenceAss{} \sepish \lass{P} \slentails \m{false}
%	}
\end{mathpar}
\hrule
%\vspace*{5pt}
\caption{Selected action shifting rules. We write $I
  \equiv^{\fenceAss{}} I'$ for $I \weakenI{\fenceAss{}} I' /| I'
  \weakenI{\fenceAss{}} I$,  and $\separate p q$ to denote that states
  satisfying $p$ and $q$ have empty intersections. We 
  assume that variables in $\bar x$ do not appear free in
  $\lass{F}$.}
\label{fig:shifting-rules}
\end{figure}
%
Intuitively, the relation $	I \weakenI{P} I'	$
means that  interference assertion $I$ can be replaced by $I'$,
because $I$ and $I'$ describe the same interference with respect to the
states described by $P$. The first rule weakens the shifting condition
from assertions to local fence assertions. 
The third rule reduces the  shifting judgement $I \cup I_1
\weakenI{\fenceAss{}} I \cup I_2$ to the simpler $I_1
\weakenI{\fenceAss{}} I_2$, provided that $f$ is invariant with
respect to $I\cup I_1$, written $f \fences I\cup I_1$.
This invariant fencing condition is necessary: 
$I_1 \weakenI{\fenceAss{}}
I_2$ only states that $I_1$ and $I_2$ have the same effect with
respect to  $\lass{F}$;  $f \fences I\cup I_1$
states that $\lass{F}$ is an \emph{invariant} of the shared region
under the combined interferences of $I$ and $I_1$. 


The next two rules describe situations where  it is impossible to apply the
action to $\lass{F}$: when the precondition  of the action is
entirely outside  $\lass{F}$; or when the postcondition is
incompatible  with that part of  $\lass{F} $ not associated with the
precondition. 
The notation $\separate{\lass{P}}{\lass{Q}}$ asserts that
states described by $\lass{P}$ and $\lass{Q}$ have \emph{empty
  intersections}: whenever $l_1, \lenv \slsat \lass{P}$ and $l_2,
\lenv \slsat \lass{Q}$, $l_1$ and $l_2$ do not have any non-trivial
common substate ($\for{l} l \leq l_1 \land l \leq l_2 \implies l =
\unitL$). This is expressible in standard separation logic as follows:
\[
\separate{\lass{P}}{\lass{Q}} <=> \lass{P} \slentails \neg\left( \m{true} * (\neg\emp \land (\m{true} \septraction \lass{Q}) ) \right)
\]

The next rule is a shifting quivalence that uses the
knowledge embodied by $\lass{F}$ of all the possible states that the
subjective shared state may be in to rewrite an action into an
equivalent one. More precisely, if whenever the precondition
$\lass{P}$ of the action is compatible with $\lass{F}$ then one of the
$\lass{R}_i$'s is also true, then adding $\lass{R}_i$ as a neutral
part of the action produces the same behaviour. We can use this rule
(with the single $r_0 = x|->v$) to justify the shiftings of
\S\ref{sec:intuition}. The fact that the $\lass{R}_i$'s are exact
guarantees that no piece of state in $\lass{R}_i$ is mutated by the
``larger'' action.  In general, it may not be the case that a
single exact assertion can be added, but it may be the case that a
disjunction of exact facts holds. The last shifting equivalence is
straightforward.

The last five rules partially axiomatise the \emph{fencing} relation
 $\lass{F}\fences I$. Most are similar to those for local
fencing  $\lass{F}\strictfences I$ 
\begin{enumerate}
\item[1, 2.]
  $\m{true}$ fences any interference assertion, and fencing can be
  checked per action.
  \addtocounter{enumi}{2}
\item
  When $\lass{P}$ and $\lass{Q}$ do not intersect in an action $\interAss{[\token{A}]}{\bar x}{\lass{P}}{\lass{Q}} $
(e.g.\ when their common parts have
  been removed according to 5.), then the application of the action
  must preserve the fence $\lass{F}$. Because the action is allowed to
  act partly outside of $\lass{F}$, the state on which the action is
  applied is $\lass{F} ** \lass{P}$, unlike local fencing where
  $\lass{P}$ would be contained in $\lass{F}$. 
\pgcomment{I don't get this yet: The reason why
  $\lass{P}$ and $\lass{Q}$ must not intersect is precisely that we
  consider the action on $\lass{F} ** \lass{P}$ and not just $\lass{F}$;
  if $\lass{P}$ and $\lass{Q}$ have a non-empty intersection $l$ then
  it might be that $l$ is not part of $\lass{F}$ and is added together
  with $\lass{Q}$ by $*$ on the left-hand side of the sequent. But
  there is no guarantee that $I$ accounts for all possible actions on
  that piece of state $l$ since it was not part of $\lass{F}$, hence
  we could end up with an assertion $\shared{\lass{F}}{I}$ that does
  not satisfy the action closure property.}
\item
  Contrarily to local fencing, actions are allowed to have effects
  outside of the fence. If the action precondition does not intersect
  with the fence, then its effect is entirely outside the fence and
  the action may be ignored.
\item
  As for local fencing, neutral parts of actions may be ignored.
\end{enumerate}

\pgcomment{Not touched from here, but minor, }

\paragraph{Stability}
\fig\ref{fig:stability-rules} partially axiomatises the stability of
assertions of the form $\exsts{\bar x}\lass{P} * \bigvarstar_{i\in
  I}\shared{\lass{Q}_i}{I_i}$. We work with a more restricted form of 
assertions than our two previous axiomatisations for simplicity. A
more comprehensive 
set of rules exists for the general case (see~\cite{colosl-tr14}).
%(see Appendix~\ref{sec:assertions-continued}). 
The
first two rules state that local assertions are always stable and
existentials can be eliminated. Then, checking the stability of
$\lass{P} * \bigvarstar_{i\in I}\shared{\lass{Q}_i}{I_i}$ boils down to
establishing, for each subjective view $\shared{\lass{Q}_i}{I_i}$, the
four-place $\mathsf{Stable}$ predicate holds. In this rule, this means that
$\lass{Q}_i$ is stable under the interference assertion $I_i$, a local
context $\lass{P}$, and a shared context made of the $**$-combination
of all the subjective assertions (including $\lass{Q}_i$).  In turn,
checking this fact reduces to checking stability for each action of
$I_i$. The last three rules deal with checking stability for a single
action, in a similar way to fencing rules above.

\begin{figure*}
\hrule
\begin{mathpar}
	\infer{\stable{\lass{P}}}{ }
	
%	\infer{
%		\stable{P}	
%	}
%	{
%		\stable{\un{P}}	
%	}
%
	\infer{
		\stable{\exsts{x} P}
	}
	{
		\stable{P}
	}

	\infer{
	  \stable{\lass{P} * \bigvarstar_{j\in J}\shared{\lass{Q}_j}{I_j}}
	}
	{
          \for{j\in J}
	  \stable{\lass{Q}_j, I_j, \lass{P}, \bigocon_{j\in J} \lass{Q}_j}
	}

%	\infer{
%		\stable{\shared{\lass{P}}{I}}	
%	}
%	{
%		\lass{P} \fences I	
%	}	
%	
%	\infer[?]{
%		\stable{\shared{\lass{P}}{I}}	
%	}
%	{
%		\stable{\shared{\lass{P}}{I'}} 
%		&
%		I' \weakenI{\lass{P}} I
%	}
%	
%	

	\infer{
	  \stable{\lass{Q},I,\lass{P},\lass{R}}
	}
	{
    \for{\interAss{[\token{A}]}{\bar{x}}{\lass{P_1}}{\lass{P}_2} \in I}
          \stable{\lass{Q},\{\interAss{[\token{A}]}{\bar{x}}{\lass{P_1}}{\lass{P}_2} \},\lass{P},\lass{R}}
	}	
	
	\infer{
	  \stable{\lass{Q},\{\interAss{[\token{A}]}{\bar{x}}{\lass{P}_1}{\lass{P}_2}\},\lass{P},\lass{R}}
	}
	{
	  [\token{A}] * \lass{P} * \lass{R} \slentails \m{false}
	}

	\infer{
	  \stable{\lass{Q},\{\interAss{[\token{A}]}{\bar{x}}{\lass{P}_1}{\lass{P}_2} \},\lass{P},\lass{R}}
	}
	{
	  \lass{P} * (\lass{R} ** \lass{P}_1) \slentails \m{false}
	}
	
	
	\infer{
	  \stable{\lass{Q},\{\interAss{[\token{A}]}{\bar{x}}{\lass{P}_1}{\lass{P}_2} \},\lass{P},\lass{R}}
	}
	{
	  \left(\lass{P}_1 \septraction (\lass{P} * (\lass{R} ** \lass{P}_1)\right) * \lass{P}_2 \slentails \lass{Q} * \m{true}
	}
\end{mathpar}
\hrule
%\vspace*{5pt}
\caption{Rules for checking stability (excerpt).
 We assume that variables in
  $\bar x$ do not appear free in $\lass{P}$, $\lass{Q}$, and $\lass{R}$.}
\label{fig:stability-rules}
\end{figure*}

The first of these is new: unlike fencing, stability only has to be
checked against actions for which the environment may hold enough
capabilities. If the capabilities required by the action cannot exist
separately from those held by the whole assertion, which may be summed
up by $\lass{P} * \lass{R}$, then the environment cannot possibly own
them and thus perform the action. Similarly, an action whose
precondition is incompatible with the current knowledge about the
state cannot possibly fire, as seen in the next rule. The current
knowledge consists of the local context $*$-separated with the shared
context, itself overlapped with the precondition of the
action. Indeed, that precondition must hold somewhere in the shared
state, separately from any private state (but possibly partially
outside of the current combined subjective view of the shared
state). The last rule checks that a particular subjective assertion
$\lass{Q}$ is preserved by the effect of an action. Again, there is a
crucial difference with the corresponding check for fencing: the
action is applied to the whole state, but part of the result can be
discarded to re-establish $\lass{Q}$. Indeed, the action may in
particular bring in some newly-shared state, thus exceeding
$\lass{Q}$, but the \forgetRule rule allows us to immediately discard
it.



\paragraph{Proof reuse}
Finally, we note that, once a strict fencing judgement
$\lass{F}\strictfences I$ has been established, it automatically
establishes a fencing judgement $\lass{F}\fences I$, and in turn
$\lass{F}\fences I$ implies that $\lass{F}$ is stable under
$I$. The other directions are not valid in general: stability of $\lass{P}$
under $I$ may omit part of the state resulting from an action
application to re-establish $\lass{P}$, which is not allowed in fencing, and
fencing lacks the confinement condition required by local
fencing. Additionally, a fence $\lass{F}$ for an interference
assertion $I$ is also a fence for any $I'$ that is a shifting of $I$ under
$\lass{F}$.
\vspace{-10pt}
\begin{mathpar}
  \infer{
    \lass{F} \fences I
  }{
    \lass{F} \strictfences I
  }
  
  \infer{
    \stable{\shared{\lass{P}}{I}}
  }{
    \lass{P} \fences I
  }
  
  \infer{
    \lass{F} \fences I'
  }{
    \lass{F} \fences I
    \\
    I \weakenI{\lass{F}} I'
  }
\end{mathpar}
	
%% ALSO I REMOVED THESE ONES
	
	%% \infer{
	%% 	I \cup I_1 \entailsI I \cup I_2
	%% }
	%% {
	%% 	I_1 \entailsI I_2
	%% }	
	
	%% \infer{
	%% 	\left\{ \interAss{[\token{A}]}{\bar{y}}{P}{Q} \right\}	
	%% 	\entailsI
	%% 	\left\{ \interAss{[\token{A}]}{\bar{y}}{\sumA{P}}{\sumA{Q}} \right\}	
	%% }{}
		
	%% \infer{
	%% 	\left\{ \interAss{[\token{A}]}{\bar{y}}{P}{Q} \right\}	
	%% 	\entailsI
	%% 	\left\{ \interAss{[\token{A}]}{\bar{y}}{P'}{Q'} \right\}	
	%% }
	%% {
	%% 	P \entails\! P'
	%% 	&
	%% 	Q \entails Q'	
	%% }
	
	%% \infer{
	%% 	\fenceAss{} \fences I
	%% }
	%% {
	%% 	I \entailsI I' 
	%% 	&
	%% 	\fenceAss{} \fences I'
	%% }

	%% \infer{
	%% 	I  \weakenI{\fenceAss{}} \emptyset
	%% }
	%% {
	%% 	I  \entailsI I'
	%% 	&
	%% 	I' \weakenI{\fenceAss{}} \emptyset
	%% }
%	
%	\infer{
%		I \cup I' \weakenI{\fenceAss{}} I
%	}
%	{
%		I \cup I' \entailsI I''
%		&
%		I'' \weakenI{\fenceAss{}} I
%	}
%		
%	\infer{
%		\left\{ [\token{A}]: P \swap Q \right\} \weakenI{\fenceAss{}} I'
%	}
%	{
%		\left\{ [\token{A}]: \erase{P} \swap \erase{Q} \right\} \weakenI{\fenceAss{}} I'
%	}
		
%% 	\infer
%% %	[\proofRule{Exist}]
%% 	{
%% 		\left\{[\token{A}]: \exists\overline{v_i \in S_i}^{i \in I}.\, P \swap Q \right\} 
%% 		\equiv^{\m{true}}
%% 		\bigcup\limits_{\overline{w_i \in S_i}^{i \in I}} \left\{[\token{A}]: P \overline{[w_i /v_i]}^{i \in I} \swap  Q \overline{[w_i /v_i]}^{i \in I} \right\} 
%% 	}
%% 	{
%% 	}	


	%% \infer{
	%% 	\stable{P \odot Q}	
	%% }
	%% {
	%% 	\stable{P}
	%% 	&
	%% 	\stable{Q}	
	%% }

	%% \infer{
	%% 	\stable{P * Q}	
	%% }
	%% {
	%% 	\stableTo{P}{Q}
	%% 	&
	%% 	\stableTo{Q}{P}	
	%% }

	%% \infer{
	%% 	\stableTo{P}{R}	
	%% }
	%% {
	%% 	\stable{P}
	%% }	

	%% \infer{
	%% 	\stableTo{P * Q}{R}
	%% }
	%% {
	%% 	\stableTo{P}{Q * R}
	%% 	&
	%% 	\stableTo{Q}{P * R}
	%% }	
	
	%% \infer{
	%% 	\stableTo{P}{R * R'}
	%% }
	%% {
	%% 	\stableTo{P}{R}
	%% }	
		
	%% \infer{
	%% 	\stableTo{P \ominus Q}{R}
	%% }
	%% {
	%% 	\stableTo{P}{R}
	%% 	&
	%% 	\stableTo{Q}{R}
	%% }	
	
	%% \infer{
	%% 	\stableTo{\exsts{x} P}{R}
	%% }
	%% {
	%% 	\stableTo{P}{R}
	%% }
	
	%% \infer{
	%% 	\stableTo{\shared{\lass{P}}{I}}{R}
	%% }
	%% {
	%% 	\stableTo{\shared{\lass{P}}{I'}}{R}
	%% 	&
	%% 	I' \weakenI{\lass{P}} I
	%% }
	
	
	%% \infer{
	%% 	\stableTo{\shared{\lass{P}}{I}}{R}
	%% }
	%% {
	%% 	\stableIn{\lass{P}}{I}{R * \shared{\lass{P}}{I}}
	%% }

	%% \infer{
	%% 	\stableIn{\lass{P}}{\left\{\interAss{[\token{A}]}{\bar{y}}{Q_1}{Q_2}\right\}}{R}	
	%% }
	%% {
	%% 	\stableIn{\lass{P}}{\left\{\interAss{[\token{A}]}{\bar{y}}{\sumA{Q_1}}{\sumA{Q_2}}\right\}}{R}	
	%% }	
	
	%% \infer{
	%% 	\stableIn{\lass{P}}{\left\{\interAss{[\token{A}]}{\bar{y}}{Q_1}{Q_2}\right\}}{R}	
	%% }
	%% {
	%% 	Q_1 \entails Q'_1
	%% 	&
	%% 	Q_2 \entails Q'_2
	%% 	&
	%% 	\stableIn{\lass{P}}{\left\{\interAss{[\token{A}]}{\bar{y}}{Q'_1}{Q'_2}\right\}}{R}	
	%% }
	
	%% \infer{
	%% 	\stableIn{\lass{P}}{\left\{\interAss{[\token{A}]}{\bar{y}}{\lass{Q}_1}{\lass{Q}_2}\right\}}{R}	
	%% }
	%% {
	%% 	[\token{A}] * \prodA{R} \slentails \m{false}
	%% }
	
	
	%% \infer{
	%% 	\stableIn{\lass{P}}{\left\{[\token{A}]: \lass{Q}_1 \swap \lass{Q}_2 \right\}} {R}	
	%% }
	%% {
	%% 	\combine{R}{\lass{Q}_1} \slentails \m{false}
	%% }
	
	
	%% \infer{
	%% 	\stableIn{\lass{P}}{\left\{[\token{A}]: \lass{Q}_1 \swap \lass{Q}_2 \right\}}{R}	
	%% }
	%% {
	%% 	\left(\lass{Q}_1 \septraction \combine{R}{\lass{Q}_1} \,\right) * \lass{Q}_2 \slentails \lass{P} * \m{true}
	%% }

\subsection{Soundness}

We prove the soundness of \colosl, parametrised by the underlying models
of machine states ($\Heaps$) and capabilities ($\Caps$). We appeal to
the general soundness result of the views framework, providing
parameters such as the reification function in
\defin~\ref{def:reification} and proving lemmas required to make the
result hold.

The main part of the proof  establishes
the soundness of the following rule for atomic commands, where
$\entails_{\textsf{SL}}$ represents standard sequential separation
logic:
\[
\infer[\proofRule{Atom}]{
  \hoare{P}{\atomic {\mathbb{C}}}{Q}
}{
  \entails_{\textsf{SL}} \{\lass{P}\}\;{\mathbb{C}}\;\{\lass{Q}\} &
  \repartitions{P}{Q}{\lass{P}}{\lass{Q}}
}
\]
This rule  is required in the frameworks from the
CAP family~\cite{cap-ecoop10,icap}. 
For \colosl, the \emph{repartitioning} $\repartitions{P}{Q}{\lass{P}}{\lass{Q}}$
holds if, from any world $(l,g,\lmod)$ satisfying $P$, 
whenever parts of $l \composeL  g$ 
satisfies $\lass{P}$ then substituting that part for any other satisfying
 $\lass{Q}$ will yield a state $l'\composeL g'$ such that there exists $\lmod'$ such
that $(l', g', \lmod')$ satisfies $Q$. 
Moreover, the passage  from $(l,g,\lmod)$ to $(l',g',\lmod')$ can be
achieved via a succession of valid updates  from $\lmod$
 and 
valid extension steps . The details can be found in the accompanying technical
report~\cite{colosl-tr14}.
%Appendix\ref{sec:semantics}.

Semantic validity of Hoare triples depends on the definition of an
operational semantics $\mathbb{C}, m \rightarrow^{\text{*}}
\mathbb{C}', m'$, where $m, m' \in \Heaps$, and a 
reification function that relates  a \colosl world to
a concrete machine state.

\begin{definition}[Reification]\label{def:reification}
  The \emph{reification}, $\reifyW{.}: \Worlds \rightarrow \Heaps$ is
  defined as:
  \[
  \reifyW{((@s_l, h_l, \ca{l}), (@s_g, h_g, \ca{g}), \lmod)} \eqdef  ((@s_l \uplus @s_g), (h_l \uplus h_g))
  \]
\end{definition}

\begin{definition}[Valid triple]
  A triple is \emph{valid}, written $|= \{P\}\ \mathbb{C}\ \{Q\}$, if
  and only if,  for all $\lenv \in \LEnv$, $w \in  \Worlds$ and  $\h{}, \h{}' \in \Heaps$,
  \vspace{-10pt}
  \[
    (w, \lenv |= P  \text{ and } \mathbb{C}, \reifyW{w} \rightarrow^{\text{*}} \li{skip}, \h{}')
    \text{ implies } \exsts{w'} w', \lenv |= Q \text{ and } \h{}' = \reifyW{w'}
  \]
\end{definition}

\begin{theorem}[Soundness]
  If $|-\!\{P\}\ \mathbb{C}\ \{Q\}$ then $|=\!\{P\}\ \mathbb{C}\ \{Q\}$.
\end{theorem}
