\section{\colosl}\label{sec:colosl}
We now give a more formal overview of how to use \colosl for program
verification, eschewing some details of the semantics for lack of space,
while still providing enough ingredients to carry program proofs. We
describe the underlying model of \colosl, give the semantics of
\colosl assertions, then present proof rules to reduce the various
checks one has to perform in the course of \colosl program proofs
(namely, the side-conditions of \shiftRule and \extendRule, and
stability checks) to classical separation logic entailments that, in
particular, do not mention subjective views.


\subsection{\colosl worlds}
\label{subsec:model}

A \emph{world} is a triple $(l, g, \lmod)$ where $l$ and $g$ are
\emph{logical states} and $\lmod$ is an \emph{action model}. The
\emph{local logical state} (local state) $l$ represents the
locally owned resources of a thread, in the standard separation logic
sense, while the \emph{global logical state} (shared state)
$g$ represents shared resources. An action model records all possible interferences on the shared state.

Logical states have two components: one describes machine states
(e.g.\ stacks and heaps); the other represents
\emph{capabilities}. The latter are inspired by the capabilities in
deny-guarantee reasoning~\cite{dg}: a thread in possession of a given
capability is allowed to perform the associated actions (as prescribed
by the \emph{action model} component of each world, defined below),
while any capability \emph{not} owned by a thread means that the
environment can perform the action. This can be seen as a unified
treatment of the rely and guarantee relations in rely-guarantee
reasoning~\cite{rg}: a capability fully owned (resp.\ fully not owned)
during the entire lifetime of a thread represents its guarantee
(resp.\ its rely), while a partially-owned capability means that the
corresponding action is both in the rely and the
guarantee. Capabilities go beyond the rely-guarantee model~\cite{dg};
in particular, they may be transferred between a thread and its
environment just like any other resource to temporarily block or enable certain actions. See the presentation of
deny-guarantee~\cite{dg} (or CAP~\cite{cap-ecoop10}) for further details
and motivation.

In general, each component of a logical state is taken from an
arbitrary \emph{separation algebra}~\cite{asl} (i.e.\ a cancellative,
partial commutative monoid) that satisfies the
\emph{cross-split} property\footnote{A separation algebra
  $(\mathbb{B}, +, \mathbf{1})$ satisfies the cross-split property iff
  for all $a, b, c, d \in \mathbb{B}$, if $a + b = c + d$, there
  exists $x, y, z, w \in \mathbb{B}$ s.t.\ $a = x + y$, $b = z + w$,
  $c = x + z$, and $d = y + w$.}\cite{dockins2009fresh} (this is
needed for $**$ to be associative~\cite{ramification}).  As we demonstrate in the examples of
\S\ref{sec:examples}, our programs often call for a more complex model
of machine states and capabilities than that presented here. For instance, we may need our
capabilities to be fractionally owned, where ownership of a
\emph{fraction} of a capability grants the right to perform the action
to both the thread and the environment, while a fully-owned capability
by the thread \emph{denies} the right to the environment to perform
the associated action.  For ease of presentation, the focus of this
paper is on the standard stack and heap model for machine states, and
finite sets of \emph{tokens} (which are simple names) for
capabilities. We assume a set of program values $\set{Val}$, as well as infinite disjoint sets $\set{PVar}$, $\set{Loc}$, and $\set{Token}$ of program variables, memory locations, and tokens, respectively.

\begin{definition}[Logical states]
  A \emph{logical state} is a tuple $((@s, h), \ca{}) \in \LStates$, also written
  $(@s,h,\ca{})$, of a finite partial \emph{stack} $@s\in \set{Stack}$ associating
  program variables with values, a \emph{heap} $h \in \set{Heap}$ associating heap
  locations with values, and a \emph{capability} $\ca{} \in \Caps$:
  \begin{mathpar}
    \set{Stack} == \set{PVar} --`_{\m{fin}} \set{Val}
    
    \set{Heap} == \set{Loc} --`_{\m{fin}} \set{Val}
    
    \Heaps == \set{Stack}\times \set{Heap}
    
    \Caps == \powerset_{\m{fin}}(\set{Token})
    
    \LStates == \Heaps\times \Caps
  \end{mathpar}
\end{definition}

The local and global logical states of a world are always
\emph{compatible}: they can be composed with one another. This captures the intuition that locally-owned resources are disjoint from shared resources. The composition of logical states is defined component-wise as disjoint function union $\uplus$ over stacks and heaps, and disjoint set union $\uplus$ on capabilities.

\begin{definition}[Logical state composition]
  The \emph{composition of logical states} $ \composeL : \LStates
  \times \LStates \rightharpoonup \LStates $ is defined
  as:
  \[
  ((@s, h),\ca{}) \composeL ((@s', h'), \ca{}') \eqdef
  ((@s\uplus @s', h\uplus h'), \ca{}\uplus \ca{}')
  \]
  %% The \emph{separation algebra of logical states} is given by
  %% $(\LStates, \composeL, \unitL)$.
\end{definition}

We write $l$ to range over either arbitrary logical states or just local states. Given a logical state $l= (@s, h, \ca{})$, we write $l_{@s}, l_h$ and $l_{\ca{}}$ for the first, second, and third projections, respectively and write $l_{\textsf{M}}$ for $(@s, h)$. We write $g$ to range over logical states representing global shared states. The empty logical state
$(\emptyset, \emptyset, \emptyset)$ is written $\unitL$. We write $l_1
\leq l_2$ when there exists $l$ such that $l\composeL l_1 = l_2$, and
write $l_2 - l_1$ to denote the unique such $l$ (by cancellativity) when it
exists. When $l_1\composeL l_2$ is defined, we say that $l_1$ and
$l_2$ are \emph{compatible} and write $l_1\compatL l_2$.

An action is a triple $(p, q, c)$ of logical states where $p$ and $q$
are the action \emph{pre-} and \emph{post-states} describing how the
shared state is modified by the action; and $c$ is the action
\emph{catalyst}. An action catalyst has to be present for the action
to take effect, but is left unchanged by the action. It is maximal in
the sense that no further, non-empty catalyst $c'$ can be found such
that $c' \leq p$ and $c' \leq q$. For instance, \label{ex:sxsem} as we shall shortly
see, $s_x$ in \fig\ref{fig:concurrentInc} will be interpreted as the
set of all actions of the form $((\emptyset, \{\ell:v\}, \emptyset),
(\emptyset, \{\ell:v{+}1\}, \emptyset), (\emptyset, \{\ell{-}1:v{+}1\},
\emptyset))$ for some $v$, where $\ell$ is the value of $x$ in the
current logical environment. We record the action catalyst separately
for technical convenience. As we will shortly demonstrate (see
\emph{worlds} below), we often need to refer to the action pre-state
in isolation, i.e. only those parts of the shared state modified by
the action.

An action model is a partial function from \emph{capabilities} to sets
of \emph{actions}. It corresponds to the semantic interpretation of an interference assertion $I$.
%
\begin{definition}[Action models]
  The set of \emph{actions}, $\set{Action}$, ranged over by $a$, and
  the set of \emph{action models}, $\AMods$, ranged over by $\lmod$, are
  defined as:
  \begin{mathpar}
    \set{Action} == \LStates \times \LStates \times \LStates
    
    \AMods == \Caps \rightharpoonup \pset{\set{Action}}
  \end{mathpar}
%  We write $\unitAM$ for an action model with empty domain.
\end{definition}
%
\paragraph{Worlds}
are triples
$(l,g,\lmod)\in\LStates\times\LStates\times\AMods$ that satisfy several
well-formedness conditions: the local and shared states are compatible ($l\compatL g$); 
the capabilities owned by $l$ and $g$ are in the domain of $\lmod$; 
and actions in $\lmod$ are \emph{confined} to $g$ (written $g\containI\lmod$).
An action $a = (p, q, c)$ is confined to $g$ if and only if whenever it is enabled ($p \composeL c$ is compatible with $g$), then its pre-state $p$ is contained in $g$ ($p \leq g$). We motivate the need for the confinement condition in \S\ref{subsec:prules}.
%We provide an informal description of confinement in
%\S\ref{subsec:prules}. The formal definition of confinement is given in~\cite{colosl-tr14}.

\begin{definition}[Well-formedness]
  \label{def:wf}
  A triple $(l, g, \lmod)\in\LStates\times\LStates\times\AMods$ is \emph{well-formed},
  written $\wf{l, g, \lmod}$, iff
  \vspace{-1ex}
  \[
  \begin{array}{L}
    l \compatL g
    /|
    l_{\ca{}} \cup g_{\ca{}} \subseteq \bigcup \m{dom}(\lmod)
    /|
    g \containI \lmod
  \end{array}
\vspace{-1ex}
\]
%
\end{definition}

\begin{definition}[Worlds]\label{def:worlds}
The set of \emph{worlds} is defined as
%
\[
	\Worlds \eqdef 
	\{w\in \LStates\times\LStates\times\AMods ||| \wf{w}\}
\]
\end{definition}
%
Worlds do not put further constraints on the
relationship between $\lmod$ and $g$, they are however linked more tightly in
the semantics of assertions (\S\ref{subsec:assertions}).

Finally, the composition of two worlds is defined when their local states are compatible, their global shared states and action models are the same, and the resulting tuple is well-formed.

\begin{definition}[World composition]
  The \emph{composition} of worlds, $\composeW: \Worlds \times \Worlds \rightharpoonup \Worlds$, is defined as:
  \[
	(l,g,\lmod) \composeW (l',g',\lmod') \eqdef
	\begin{cases}
		(l\composeL l', g, \lmod) &
		\begin{array}[t]{L}
			\text{if }
			g = g' \text{, and }
			\lmod = \lmod' \text{, and }\p{wf}((l\composeL l', g, \lmod))
		\end{array}\\
		\textit{undefined}&\text{otherwise}
	\end{cases}
\]
\end{definition}

%% The set of well-formed worlds with composition $\composeW$ forms a
%% separation algebra with multiple units: all well-formed worlds of the
%% form $(\unitL,g,\lmod)$.

\subsection{\colosl Assertions}
\label{subsec:assertions}

Our assertion language extends separation logic with \emph{subjective
  views} and \emph{capability assertions}.

\colosl is parametric in the assertions of machine states and
capabilities and can be instantiated with any assertion language over
machine states $\Heaps$ and capabilities $\Caps$. In this paper, we
use standard heap and stack assertions for machine state assertions,
and single-token assertions of the form $[\token{a}]$ for capability
assertions where $\token{a} \in \set{Token}$. We write $[\token{A}]$
as a shorthand for $\bigstar_{\token{a} \in \token{A}} [\token{a}]$.
We assume an infinite set $\set{LVar}$ of \emph{logical variables},
disjoint from $\set{PVar}$.

\begin{definition}[Assertion syntax]\label{def:assertions}
Given $x \in \set{LVar}$, $\li{x} \in \set{PVar}$, and $\token{a} \in \set{Token}$, \emph{the assertions of \colosl}, $\Assertions$, are described by the grammars below:
%
\begin{align*}	 
  \LAssertions \ni \lass{p}, \lass{q} & ::=
  \begin{array}[t]{@{}l@{}}
  \m{false} \mid E_1 = E_2
  \mid \emp \mid \li{x} \harpoonything E \mid E_1 |-> E_2 \mid [E]\\
  \null\mid \lass{P} \lor \lass{Q} \mid  \neg\lass{P} \mid \exsts{x} \lass{P}
  \mid \lass{P} * \lass{Q} \mid \lass{P} ** \lass{Q} \mid
  \lass{P} \septraction \lass{Q}
  \end{array}\\
  \Assertions \ni P,Q & ::= \lass{P} \mid \exsts{x} P \mid P \lor Q \mid P * Q \mid P ** Q \mid \shared{P}{I}  \\
  I &::= \emptyset \mid \{\interAss{[\token{A}]}{\bar{x}}{P}{Q}\} \cup I
  \qquad
  E ::= x \mid \token a \mid E_1 + E_2 \mid \cdots
\end{align*}
\end{definition}

The syntax and semantics of \emph{local assertions} $\LAssertions$ are
that of standard separation logic with
variables-as-resource~\cite{variablesAsResource}\footnote{Note in
  particular that expressions $E$ do not allow program variables: they
  can only appear on the left-hand side of $\li{x} \harpoonything E$.}
interpreted over a world's local state. The assertion $\li{x}
\harpoonything E$ denotes a singleton stack where \li{x} has value
$E$. Similarly, $E_1|->E_2$ is true of the singleton heap where only
address $E_1$ is allocated and has value $E_2$.  The capability
assertion $[E]$ is true of the singleton capability $\{\token{a}\}$ if
$E$ evaluates to $\token a$. The empty local state $\unitL$ is denoted
by $\emp$. The \emph{separating conjunction} $\lass{P} * \lass{Q}$ is
true when the local state can be split into two according to
$\composeL$ such that one state satisfies $\lass{P}$ and the other
satisfies $\lass{Q}$. The \emph{overlapping conjunction}
$\lass{P}**\lass{Q}$ is true when the local state can be split
three-ways according to $\composeL$, such that the
$\composeL$-composition of the first two states satisfies $\lass{P}$
and the $\composeL$-composition of the last two satisfy
$\lass{Q}$~\cite{ramification,gareth-js12,rey-slnotes}. \emph{Septraction}
(or \emph{existential magicwand}) $\lass{P}\septraction\lass{Q}$ is
true when there exists a local state satisfying $\lass{P}$ that can be
$\composeL$-composed with the current one to yield a state satisfying
$\lass{Q}$. Classical predicates and connectives have their standard
classical meaning.

As in RGSep~\cite{viktor-marriage}, our assertions $\Assertions$ are
defined on top of local assertions. For simplicity, assertions do not
include negation nor septraction. The interpretation of assertions
is a simple lift from that of local assertions, with the exception
of the subjective views $\shared P I$.  First, an \emph{interference
  assertion} $I$ describes actions enabled by a given capability, in
the form of a pre- and postcondition.
%Following the RGSep style~\cite{viktor-marriage}, interference assertions $I$ describe actions enabled by a given capability, in the form of a pre- and postcondition ($P$ and $Q$ respectively) as well as a side-condition ($R$). We write $P \swap Q$ as a shorthand for $\action{P}{Q}{\emp}$.
A subjective view $\shared P I$ is then true of $(l,g,\lmod)$ when $l =
\unitL$ and a \emph{subjective state} $s$ can be found in the global
shared state $g$ (i.e.\ $g = s\composeL r$ for some
$r$), such that $s$ satisfies $P$ in the standard separation logic
sense, and $\lmod$ and $I$ \emph{agree} given the decomposition $s$,
$r$, in the following sense, which we write as
$\extendsAM{\lmod}{s}{r}{\semI{I}}$:
%Appendix~\ref{sec:model-continued}):
\begin{enumerate}
	\item every action in $I$ is reflected in $\lmod{}$;
	
	\item every action in $\lmod$ that has a visible effect on $s$ is reflected in $I$;
	
	\item the above holds after any number of actions in $\lmod$ takes place.
%	\item the above is true for any state resulting from any number of actions of $\lmod$ applied to $g$.
%	\item the above is true after any number of action applications in $I$ that affect $g$ and any number of action applications in $\gmod$ that affect $r$ but not $s$.
\end{enumerate}
Thus, given a world $(l,g,\lmod)$ and a subjective view $\shared P I$,
$P$ describes a subjective state $s$ that is \emph{parts} of $g$ and
$I$ describes \emph{all parts} of $\lmod$ concerning $s$, while
$\lmod$ describes the overall interference on $g$.  We refer to the
above agreement between the action model and the subjective view as
the \emph{action model closure property}. We omit its formal
definition for lack of space.
%; it can be found in~\cite{colosl-tr14}.

The semantics of \colosl assertions is given by a forcing relation
$w,\lenv|= P$ between a world $w$, a logical environment
$\lenv\in\LEnv$, and an assertion $P$. We use two auxiliary forcing
relations. The first one $l,\lenv\slsat p$ interprets local assertions
$p\in\LAssertions$ in the usual separation logic sense over a logical
state $l$. The second one $s,\lenv|=_{g,\lmod} P$ interprets
assertions $P\in\Assertions$ over a \emph{subjective state} $s$ that
is part of the global shared state $g$, subject to action model
$\lmod$. This third form of satisfaction is needed to deal with the
nesting of subjective views.\footnote{This presentation with several
  forcing relations differs from the usual CAP
  presentation~\cite{cap-ecoop10}, where formulas are first
  interpreted over worlds that are not necessarily well-formed, and
  then cut down to well-formed ones. The advantage of our presentation
  is that the semantics of assertions is \emph{compositional},
  e.g.\ the semantics of $P * Q$ follows directly from the semantics
  of $P$ and $Q$.}  Since logical connectives are interpreted
uniformly in all cases, we write $|=_\dagger$ for any of the three
satisfaction relations, $u$ for elements of either $\Worlds$ or
$\LStates$, and $\grey$ for either $\composeW$ or $\composeL$, as
appropriate.

\begin{definition}[Assertion semantics]\label{def:assertion-semantics}
Given a logical environment $\lenv: \set{LVar} --> \set{Val}$, the
semantics of \colosl assertions is defined below, using a semantics of
interference assertions $\semI[(.)]{.}: \LEnv \rightarrow \AMods$ also
defined below.
\vspace{-1ex}
\[
\begin{array}{R>{\null}l@{\ \,}c@{\ \,}l}
  (l,g,\lmod), \lenv &|= \lass{P}  &\text{iff}& l,\lenv \slsat \lass{P}\\
  
  (l,g,\lmod), \lenv &|= \shared P I &\text{iff}&
  l = \unitL \text{ and }
  \exsts{s,r}
  g = s\composeL r\text{ and }
  s, \lenv |=_{g,\lmod} P\text{ and }
  \extendsAM{\lmod}{s}{r}{\semI[\lenv]{I}}
\end{array}
\]
\vspace{-3.0ex}
\[
\begin{array}{R>{\null}l@{\ \,}c@{\ \,}l}
  s, \lenv &|=_{g,\lmod} \lass{P} &\text{iff}& s, \lenv \slsat \lass{P}\\
  
  s, \lenv &|=_{g,\lmod} \shared P I &\text{iff}&
  (s,g,\lmod), \lenv |= \shared P I\\
  
  u,\lenv &|=_\dagger \exsts x P
  &\text{iff}& \exsts v u, [\lenv|||x:v] |=_\dagger P\\
%  
%  u,\lenv &|=_\dagger \for{x} P
%  &\text{iff}& \for{v}u, [\lenv|||x:v] |=_\dagger P\\
  
  u,\lenv &|=_\dagger P \lor Q
  &\text{iff}& u,\lenv |=_\dagger P\text{ or }u,\lenv |=_\dagger Q\\
  u, \lenv &|=_\dagger P_1 * P_2 &\text{iff}&
  \exsts{u_1,u_2} u = u_1 \grey u_2\text{ and }
  u_1, \lenv |=_\dagger P_1 \text{ and }u_2, \lenv |=_\dagger P_2\\
  
  u, \lenv &|=_\dagger P_1 ** P_2 &\text{iff}&
  \exsts{u',u_1,u_2} u = u'\grey u_1\grey u_2\text{ and}\\
  &&&
  u' \grey u_1, \lenv |=_\dagger P_1 \text{ and }
  u' \grey u_2, \lenv |=_\dagger P_2\\	
  
%  l, \lenv &\slsat [E]
%  &\text{iff}&
%  l = (\emptyset,\emptyset, \{[|E|]_{\lenv}\})\\
%  &&\cdots\\

  l,\lenv &\slsat \m{false}  && \text{never}\\

  l, \lenv &\slsat \emp &\text{iff}&l = \unitL\\
  
  l,\lenv &\slsat E_1 = E_2
  &\text{iff}& [|E_1|]_{\lenv} = [|E_2|]_{\lenv}\\

  l, \lenv &\slsat \li{x} \harpoonything E
  &\text{iff}&
  l = (\{\li x: [|E|]_{\lenv}\}, \emptyset, \emptyset)\\
  
  l, \lenv &\slsat E_1|->E_2 
  &\text{iff}&
  l =
  (\emptyset, \{[|E_1|]_{\lenv}: [|E_2|]_{\lenv}\}, \emptyset)\\
  
  l, \lenv & \slsat [E]
  & \text{iff} &
  l = (\emptyset, \emptyset, \{[|E|]_{\lenv}\})\\
  
  l,\lenv &\slsat \neg \lass{P}
  &\text{iff}& l,\lenv \not\slsat \lass{P}\\
  
  l, \lenv &\slsat \lass{P} \septraction \lass{Q} &\text{iff}&
  \exsts{l'} l', \lenv \slsat \lass{P} \text{ and }
  l \compatL l'
  \text{ and }l \composeL l', \lenv \slsat \lass{Q}
\end{array}
\]
\vspace{-1em}
%
\begin{align*}
%\semI[\lenv]{I}(\token{A}) &==
%  \left\{
%  \begin{array}{@{}l@{\ }|@{\ }r@{}}
%    (p \composeL r, q \composeL r)&
%    \begin{array}{@{}l@{}}
%      \interAss{[\token{A}]}{\bar x}{P}{Q}{} \in I /|  \exsts{\bar{v}, \lmod} \\
%%      \lenv' = [\lenv|||\bar y:\bar v] \\
%%      /| (p \composeL r), \lenv'\slsat \sumA{P} 
%%      /| (q \composeL r), \lenv' \slsat \sumA{Q} \\
%      \quad p, [\lenv|||\bar x:\bar v]  |=_{p \composeL r, \lmod} P 
%      /| q, [\lenv|||\bar x:\bar v]  |=_{q \composeL r, \lmod} Q 
%    \end{array}
%  \end{array}
%  \right\}
\semI[\lenv]{I}(\token{A}) &==
  \left\{
  \begin{array}{@{}l@{\ }|@{\ }r@{}}
    (p, q, c )&
    \begin{array}{@{}l@{}}
      \interAss{[\token{A}]}{\bar x}{P}{Q} \in I /| \exsts{\bar{v}, \lmod, r, r'} \\
      \quad c = r \composeL r' \land \for{l} l \leq p \land l \leq q \implies l = \unitL/|\null\\
      \quad p \composeL r, [\lenv|||\bar x:\bar v]  |=_{p \composeL c, \lmod} P 
      /| q \composeL r,  [\lenv|||\bar x:\bar v]  |=_{q \composeL c, \lmod} Q 
    \end{array}
  \end{array}
  \right\}
%\semI[\lenv]{I}(\token{A}) &==
%  \left\{
%  \begin{array}{@{}l@{\ }|@{\ }r@{}}
%    (p, q, r \composeL c)&
%    \begin{array}{@{}l@{}}
%      \interAss{[\token{A}]}{\bar x}{P}{Q}{R} \in I /| \exsts{\bar{v}, \lmod} \\
%      \quad p, [\lenv|||\bar x:\bar v]  |=_{p \composeL r \composeL c, \lmod} P 
%      /| q, [\lenv|||\bar x:\bar v]  |=_{q \composeL r \composeL c, \lmod} Q \\
%      \quad r, [\lenv|||\bar x:\bar v]  |=_{p \composeL r \composeL c, \lmod} R /|
%      r, [\lenv|||\bar x:\bar v]  |=_{q \composeL r \composeL c, \lmod} R \\
%    \end{array}
%  \end{array}
%  \right\}
\end{align*}
\end{definition}

Note that, as in the CAP family~\cite{cap-ecoop10,icap,tada}, \colosl
cannot ensure that proved programs do not leak memory. This is because
of the following property of the semantics with respect to the shared
state (sometimes called ``intuitionistic semantics''~\cite{rey02}): if
$(l,g,\lmod), \lenv |= P$ then $(l,g\circ g',\lmod), \lenv |= P$.


Five of the principles of \fig\ref{fig:principles} are direct
consequences of the semantics.

\begin{lemma}
  \label{lem:assertion-facts}
  The \colosl reasoning principles 
  \forgetRule, \mergeRule, \shiftRule, \weakenRule, and \copyRule are valid.
  %% \begin{mathpar}
  %%       \infer{
  %%       	\shared{P}{I} * \shared{Q}{I'} \entails \shared{R}{I} * \shared{Q}{I'}
  %%       }
  %%       {
  %%       	R \entails P
  %%       	&
  %%       	P \sepish Q \entails R \sepish Q
  %%       }
  %% \end{mathpar}
\end{lemma}
\begin{proof}[sketch]
  The cases of \weakenRule and \copyRule are
  straightforward. \forgetRule, \mergeRule and \shiftRule principles are valid as action
  model closure is preserved when picking a smaller subjective state, when taking the union of subjective states and their interference assertions, and when shifting the interference assertion, respectively. The full proof is provided in~\cite{colosl-tr14}.
  \qed
\end{proof}


\subsection{Reducing \colosl principles to separation logic entailments}
\label{subsec:prules}

We turn to the remaining two principles, \extendRule and \shiftRule,
and to the stability condition. These involve reasoning outside our
assertion language, potentially requiring semantic reasoning 
in the model. Fortunately, it is enough to work
with a partial 
axiomatisation  for all three conditions to verify
our examples. In this section, we give cut-down versions of these
rules for a fragment of the \colosl assertion language where the 
nesting of subjective views is not permitted   and  interference
assertions cannot mention subjective views. This restriction is easily
lifted: we can always \emph{flatten}
assertions with nested boxes into logically equivalent assertions with
no nesting, and  interference assertions  mentioning  other
subjective views in their actions may be rewritten into ones
that do not.  See~\cite{colosl-tr14} for the full details.% Appendix~\ref{sec:assertions-continued}.

%% Moreover, in the restricted case where actions and fences (see below)
%% can be expressed in a fragment extending the usual \emph{symbolic
%%   heaps} used in automatic tools based on separation logic, starting
%% with Smallfoot~\cite{smallfoot}, without inductive predicates but
%% including the $**$ connective (this corresponds to replacing $p$ with
%% $A$ in the grammar of assertions), the separation logic entailments
%% that need to be discharged once the rules of this section have been
%% applied can be verified automatically. Indeed, for this fragment, we
%% can extend the $--o$-elimination procedure of Calcagno et
%% al. in~\cite{vv07msc} to deal with $**$ as well. We leave the details
%% of this adaptation to Appendix~\ref{sec:assertions-continued}. The following standard definition will
%% be needed in the remainder of this section.


\paragraph{Confinement}

A \colosl world $(l,g,\lmod)$ descibes the local state $l$ and the
global shared state $g$ with interference given by the action model
$\lmod$.  The soundness of \colosl hinges on the fact that the action
model $\lmod$ contains all the actions that could possibly affect the
shared state $g$. Using the \extendRule principle, it is possible for
any part $l'$ of the local state to migrate to the shared state under
a new set of actions $\lmod'$, yielding a new shared state $g\composeL
l'$ and action model $\lmod \cup \lmod'$, as long as this migration
does not invalidate the views of the other threads. We therefore only
permit this migration if the actions in $\lmod'$ are \emph{confined}
to $l'$. This means that whenever an action $a = (p, q, c)$ of
$\lmod'$ is enabled, the state $p$ must be a substate of $l'$.  It is
possible for some of the catalyse $c$ to lie outside $l'$, since the
fact that it does not change during the course of the action means
that it will not have an effect on the views of other threads.

For example, going back to the interpretation of $s_x$ described on
page~\pageref{ex:sxsem}, the action $a_0 = ((\emptyset, \{\ell:0\},
\emptyset), (\emptyset, \{\ell:1\}, \emptyset), (\emptyset,
\{\ell{-}1:1\}, \emptyset))$ is confined to the state
$l_1=\{\ell:0\}$ because $l_1$ is the first component of the
action, and $l_2=\{\ell{-}1:0\}$ because $l_2$ is incompatible with the
action, but not $l_3=\{\ell{-}1:1\}$ because the action can
potentially affect address $\ell$.
%Indeed $p \composeL c$ is compatible with $l_1$ and $l_3$, and the
%modified cells 10 and 12 are fully contained in $l_1$ but not in
%$l_3$; $p \composeL c$ is not compatible with $l_2$, hence $a$ has no effect on
%$l_2$ and is automatically confined to $l_2$. 

This simple example does not show the full subtlety of containment. We  also require that all states resulting from the successive
application of actions in $\lmod'$ themselves confine all actions in
$\lmod'$. 
Inspired by the LRG approach~\cite{lrg}, this is achieved by
first finding a set that is invariant under all actions in $\lmod'$
(called a \emph{fence}), then checking the confinement condition for
each action. This is complex and detailed in the technical
report. Fortunately, for our examples,  it is in fact enough to work with containment in the
logic. 

-------a paragraph transfering to containment for logic, rather than model------

\pgcomment{Now  what does it mean to transfer to the logic. Might make
  sense to use somewhere: Similarly, the
action model closure ensures that subjective views in assertions have
to account for all actions potentially affecting their piece of the shared
state.}

In the logic, the shared state is extended by the resources in
$P$ under the interference assertion $I$ via the \extendRule principle,
which requires that $P\containI I$ be
established. 

------------------now an explanation of the figure, this can be
improved, esp explanation of  confinement in last rule---------------

\fig~\ref{fig:local-fencing-rules} presents a set of
rules to reduce $P \containI I$ to a series of entailments in
ordinary separation logic. As expressed by the first rule,
$P \containI I$ holds if there is a weaker local assertion $\lass{F}$
that acts as a \emph{local fence} for $I$, denoted by
$\lass{F}\strictfences I$; in particular, this means that $\lass{F}$
must be invariant under all actions of $I$. In~\cite{colosl-tr14}
%Appendix~\ref{sec:assertions-continued} 
we show that it is always possible to weaken an assertion into a local assertion. This fencing condition is
checked for each action in $I$ (see the second rule). For each action
$\lass{P}\swap \lass{Q}$, the three remaining rules of the figure may
apply. In the first of these rules, the action cannot possibly fire,
because its precondition does not agree with $\lass{F}$: no state
satisfying $\lass{F}$ may be extended such that a subpart satisfies
$\lass{P}$. 
%The second of these rules allows one to trim the side-condition as it is left unchanged by the action. 
The second of these rules allows one to trim neutral parts
$\lass{R}$ of an action $\lass{P}\swap \lass{Q}$: if $\lass{R}$
appears both in $\lass{P}$ and $\lass{Q}$, and $\lass{R}$ is \emph{exact}, i.e.\ satisfied by at most
one logical state\footnote{$\exact{p} ==
    \for{\lenv, l_1, l_2} l_1, \lenv \slsat p\text{ and }l_2, \lenv
    \slsat p\text{ implies } l_1 = l_2$},
then the part of the state denoted by $\lass{R}$ is uniquely
determined and left unchanged by the action. 
The last rule finally reduces local fencing to entailment checking, provided the fence
$\lass{F}$ can be expressed as a disjunction of \emph{precise}
assertions, i.e.\ assertions satisfied by at most one substate of each
logical state\footnote{$\precise{p} ==
    \for{\lenv, l, l_1, l_2} l_1\leq l\text{, }l_2\leq l\text{, }l_1,
    \lenv \slsat p\text{, and }l_2, \lenv \slsat p
    \text{ implies } l_1 = l_2$}. The
first premise states that $\lass{F}$ is invariant under the action
$\lass{P}\swap \lass{Q}$, similar to the way that RGSep encodes
stability checks as separation logic entailments. Informally, it
reads: for any state in $f$, remove a part satisfying $p$ and add a
state satisfying $q$; the result should still be in $f$. The third
premise checks the confinement condition: given a state in $f_i$ ($l_1\composeL l_2|= \lass{F}_i$), and an extension of it ($l = l_1 \composeL l_2 \composeL l_3$) where a subpart of $l$ satisfies $\lass{P}$ ($l_2 \composeL l_3 |= f_i$), the extension $l$ itself is also in $f_i$ ($l_1\composeL l_2\composeL
l_3|=\lass{F}_i$, hence by precision of $\lass{F}_i$, we have $l_2\composeL
l_3\leq l_1\composeL l_2\composeL l_3 = l_1\composeL l_2$)
%if a subpart of an extension of a state in $\lass{F}_i$ satisfies $\lass{P}$
%($l_1\composeL l_2|= \lass{F}_i$ and $l_2\composeL l_3 |= \lass{P}$),
%then it is also a subpart of that state ($l_1\composeL l_2\composeL
%l_3|=\lass{F}_i$, hence by precision of $\lass{F}_i$, $l_2\composeL
%l_3\leq l_1\composeL l_2\composeL l_3 = l_1\composeL l_2$).

\begin{figure}
\hrule\vspace{5pt}
\begin{mathpar}
	\infer{
	  P \confines I	
	}
	{
	  P \entails \fenceAss{}&
	  \fenceAss{} \strictfences I
	}
	
	\infer{
		\fenceAss{} \strictfences I
	}
	{
          \for{\left(\interAss{[\token{A}]}{\bar x}{\lass{P}}{\lass{Q}}\right)\in I}\fenceAss{} \strictfences \left\{\interAss{[\token{A}]}{\bar x}{\lass{P}}{\lass{Q}} \right\}
	}		

	\infer{
		\fenceAss{} \!\strictfences\! \left\{\interAss{[\token{A}]}{\bar x}{\lass{P}}{\lass{Q}} \right\}		
	}
	{
		\fenceAss{} \sepish \lass{P} \slentails \m{false}
	}	

	\infer{
		\fenceAss{} \strictfences \left\{\interAss{[\token{A}]}{\bar x}{\lass{P}}{\lass{Q}}\right\}	
	}
	{
    \lass{P} \slentails \lass{P'} * \lass{R}\\
    \lass{Q} \slentails \lass{Q'} * \lass{R}\\
	  \exact{\lass{R}}\\
	  \fenceAss{} \strictfences \left\{[\token{A}]\!\!: \exsts{\bar x} \lass{P'} \swap \lass{Q'} \right\}
	}	
		
%	\infer{
%		\fenceAss{} \strictfences \left\{\capAss{}: \lass{P} \swap \lass{Q} \right\}		
%	}
%	{
%		\fenceAss{}' \slentails \fenceAss{}
%		&
%		\fenceAss{} \sepish \lass{P} \slentails \fenceAss{}' \sepish \lass{P}
%		&
%		\fenceAss{}' \strictfences \left\{\capAss{}: \lass{P} \swap \lass{Q} \right\}		
%	}
%		
	\infer{
		\fenceAss{} \strictfences \left\{\interAss{[\token{A}]}{\bar x}{\lass{P}}{\lass{Q}} \right\}		
	}
	{	
%		\separate{\lass{P}}{\lass{Q}}
%		&
		\left(\lass{P} \septraction \fenceAss{} \right) * \lass{Q} \slentails \fenceAss{}	
		\\
		\fenceAss{} \!<=>\! \bigvee_{i \in I}\fenceAss{i} 		
		\\
		(\precise{\fenceAss{i}}
		\land
		\fenceAss{i} \sepish \lass{P} \slentails \fenceAss{i}
		\;\;\text{for } i \in I)
	}	
%	{
%		\begin{array}{@{} l @{}}			
%			\separate{\lass{P}}{\lass{Q}}
%			\quad
%			\left(\lass{P} \septraction \fenceAss{} \right) * \lass{Q} \slentails \fenceAss{}	
%			\quad
%			\fenceAss{} <=> \bigvee\limits_{i \in I}\fenceAss{i} 		\\
%			%
%			\precise{\fenceAss{i}}
%			\quad 
%			\fenceAss{i} \sepish \lass{P} \slentails \fenceAss{i}
%			\quad
%			\text{for } i \in I
%		\end{array}
%	}	
%	
\end{mathpar}
\hrule
\caption{Confinement and local fencing rules. We assume that variables in
  $\bar x$ do not appear free in $\lass{F}$ and $\lass{F}_i$ for any $i$.}
\label{fig:local-fencing-rules}
\end{figure}


In the same way that all new extensions to the shared states are confined, any world
must also be confined, as to not interfere with its future extensions. This is captured by the confinement condition in the well-formedness of worlds.
%, which repeats the definition of confinement
%for assertions at the model level.


\paragraph{Shifting/fencing judgements}
\fig\ref{fig:shifting-rules} presents an axiomatisation of the main
shifting principles, our mechanism to rewrite interference assertions
in subjective views via \shiftRule. As with confinement, we omit the
direct semantic definition, which can be found in~\cite{colosl-tr14}.
% Appendix~\ref{sec:model-continued}.
The
pseudo-entailment $\separate{\lass{P}}{\lass{Q}}$ asserts that states
described by $\lass{P}$ and $\lass{Q}$ have \emph{empty
  intersections}: whenever $l_1, \lenv \slsat \lass{P}$ and $l_2,
\lenv \slsat \lass{Q}$, $l_1$ and $l_2$ do not have any non-trivial
common substate ($\for{l} l \leq l_1 \land l \leq l_2 \implies l =
\unitL$). This is expressible using standard connectives as follows:
\[
\separate{\lass{P}}{\lass{Q}} <=> \lass{P} \slentails \neg\left( \m{true} * (\neg\emp \land (\m{true} \septraction \lass{Q}) ) \right)
\]
%In Appendix~\ref{sec:assertions-continued} we also axiomatise
%non-intersection directly, which provides an alternative way to check
%non-intersection for a restricted fragment of formulas.

\begin{figure}
\hrule\vspace{5pt}
\begin{mathpar}
	\infer{
		I \weakenI{P} I'	
	}
	{
		P \entails \fenceAss{}\\
		I \weakenI{\fenceAss{}} I'
	}	
	
	\infer{
	  I\weakenI{\fenceAss{}} I
	}{}
	
	\infer{
		I \cup I_1 \weakenI{\fenceAss{}} I \cup I_2
	}
	{
		\fenceAss{} \fences I \cup I_1	
		&
		I_1 \weakenI{\fenceAss{}} I_2
	}	

%	\infer{
%		\left\{\interAss{[\token{A}]}{\bar x}{\lass{P}}{\lass{Q}}{\lass{R}} \right\} \approx^{\fenceAss{}}
%		\left\{\interAss{[\token{A}]}{\bar x}{\lass{P'}}{\lass{Q'}}{\lass{R} * \lass{R}'} \right\}
%	}
%	{
%          \lass{P} \slentails \lass{P'} * \lass{R'}\\
%          \lass{Q} \slentails \lass{Q'} * \lass{R'}\\
%	  \exact{\lass{R'}}\\
%	}	
%	
%%	\infer{
%%		\left\{ [\token{A}]: \exsts{\bar x}\lass{P}  \swap \lass{Q} \right\} \weakenI{\fenceAss{}}
%%		\emptyset
%%	}
%%	{
%%          \lass{P} \slentails \lass{P'} * \lass{R}\\
%%          \lass{Q} \slentails \lass{Q'} * \lass{R}\\
%%	  \exact{\lass{R}}\\
%%	  \separate{\fenceAss{}}{\lass{P'}}
%%	}	
	\infer{
		\left\{\interAss{[\token{A}]}{\bar x}{\lass{P}}{\lass{Q}} \right\} \weakenI{\fenceAss{}}
		\emptyset
	}
	{
		\lass{P} \slentails \lass{P'} * \lass{R}\\
    \lass{Q} \slentails \lass{Q'} * \lass{R}\\
	  \exact{\lass{R}}\\
	  \separate{\fenceAss{}}{\lass{P'}}
	}	

	\infer
%	[\proofRule{False-R}]
	{	
		\left\{[\token{A}]: \exsts{\bar x}\lass{P} \swap \lass{Q} \right\} \weakenI{\fenceAss{}} 
		\emptyset 	
	}
	{
%		& \fenceAss{} \fences  \left\{ [\token{A}]: \left\{ P \swap Q \right\}\right\}
		\left(\lass{P} \septraction (\lass{P} \sepish \fenceAss{})\right) * \lass{Q} \slentails \m{false}
	}	
	
	\infer
%	[\proofRule{Expand/Contract}]
	{
		\left\{\interAss{[\token{A}]}{\bar x}{\lass{P}}{\lass{Q}} \right\} \;\approx^{\fenceAss{}}\;  \bigcup_{i \in I} \left\{\interAss{[\token{A}]}{\bar x}{\lass{P} * \lass{R}_i}{\lass{Q} * \lass{R}_i} \right\}	
	}
	{
		\fenceAss{} \sepish \lass{P} \slentails \bigvee_{i \in I} \fenceAss{} \sepish \left(\lass{P} * \lass{R}_i \right)
		&
		\exact{\lass{R}_i} \text{ for } i \in I
	}

	\infer
%	[\proofRule{Disj}]
	{
	  \bigcup_{i \in I,j\in J}\!\! \left\{[\token{A}]\!:\!\exsts{\bar{x}} \lass{P}_i \!\swap\! \lass{Q}_j \right\}
	  \mathrel{\approx^{\m{true}}}
	  \left\{\![\token{A}]\!: \exsts{\bar{x}}
          \bigvee_{i \in I} \lass{P}_i \!\swap\!
          \bigvee_{j\in J}\lass{Q}_j \right\} 
	}
	{
	}

	\infer{
		\m{true} \fences I	
	}{}	

	\infer{
		\fenceAss{} \fences I
	}
	{
          \for{[\token{A}]: \exsts{\bar x}\lass{P} \swap \lass{Q}\in I}\fenceAss{} \fences \left\{[\token{A}]: \exsts{\bar x}\lass{P} \swap \lass{Q} \right\}
	}		

	\infer{
	  \fenceAss{} \fences \left\{\interAss{[\token{A}]}{\bar x}{\lass{P}}{\lass{Q}} \right\}
	}
	{
		\lass{P} \slentails \lass{P'} * \lass{R}\\
    \lass{Q} \slentails \lass{Q'} * \lass{R}\\
	  \exact{\lass{R}}\\
	  \fenceAss{} \!\fences\! \left\{[\token{A}]\!\!:\exsts{\bar x} \lass{P'} \swap \lass{Q'} \right\}
	}	

	\infer{
		\fenceAss{} \fences \left\{[\token{A}]\!\!:\exsts{\bar x} \action{\lass{P}}{\lass{Q}} \right\}	
	}
	{
		\separate{\fenceAss{}}{\lass{P}}
	}	
	
%	\infer{
%		\fenceAss{} \fences \left\{[\token{A}]: \lass{P} \swap \lass{Q} \right\}		
%	}
%	{
%		\fenceAss{} \sepish \lass{P} \slentails \m{false}
%	}
%	
	\infer{
		\fenceAss{} \fences \left\{\interAss{[\token{A}]}{\bar x}{\lass{P}}{\lass{Q}} \right\}		
	}
	{
		\separate{\lass{P}}{\lass{Q}}
		&
		\left(\lass{P} \septraction (\fenceAss{} \sepish \lass{P}) \right) * \lass{Q} \slentails \fenceAss{}
	}	
\end{mathpar}
\hrule
%\vspace*{5pt}
\caption{Selected action shifting rules; we write $I
  \approx^{\fenceAss{}} I'$ for $I \weakenI{\fenceAss{}} I' /| I'
  \weakenI{\fenceAss{}} I$,  and assume that variables in
  $\bar x$ do not appear free in $\lass{F}$.}
\label{fig:shifting-rules}
\end{figure}

The first three rules of \fig\ref{fig:shifting-rules} allow one to
check shifting piecewise: one may weaken the assertion $P$ into
a local assertion $\lass{F}$ which, if it \emph{fences} $I_1\cup I_2$, can be used to
reduce a shifting judgement $I \cup I_1 \weakenI{\fenceAss{}} I \cup
I_2$ to the simpler $I_1 \weakenI{\fenceAss{}} I_2$. 
The extra fencing condition $\lass{F}\fences I\cup I_1$ is necessary because
shifting means that the actions in $I\cup I_1$ and $I\cup I_2$
have the same effect on $\lass{F}$ after an arbitrary number of action
applications. In particular, this is the case when $\lass{F}\fences I\cup
I_1$, i.e.\ $\lass{F}$ is an \emph{invariant} of the shared region
under interferences in $I\cup I_1$, whereas $I_1 \weakenI{\fenceAss{}}
I_2$ only states that $I_1$ and $I_2$ are equivalent from the point of
view of $\lass{F}$.

The next two rules describe situations where an action is irrelevant
to a particular assertion $\lass{F}$: when the effect of the action is
entirely outside of $\lass{F}$, or when it is impossible to apply the
action to $\lass{F}$. The next rule is an equivalence that uses the
knowledge embodied by $\lass{F}$ of all the possible states that the
subjective shared state may be in to rewrite an action into an equivalent
one. More precisely, if whenever the precondition $\lass{P}$ of the
action is compatible with $\lass{F}$ then one of the $\lass{R}_i$'s is
also true, then it is safe to add $\lass{R}_i$ as a neutral part of
the action (the fact that $\lass{R}_i$ is exact guarantees that no
piece of state in $\lass{R}_i$ is mutated by the ``larger'' action)
without changing the set of states in which the action can be
applied. The last shifting equivalence is straightforward. Note that
$\m{true}$ fences any interference assertion.

To check whether an assertion $\lass{F}$ fences an interference assertion $I$, written
$\lass{F}\fences I$, the last three rules of the figure are similar to those for local
fencing and provide rules to apply to each action of $I$. 
\begin{enumerate}
\item
  As for local fencing, neutral parts in actions may be ignored.
\item
  Contrarily to local fencing, actions are allowed to have effects
  outside of the fence. If the action precondition does not intersect
  with the fence, then its effect is entirely outside the fence and
  the action may be ignored.
\item
  When $\lass{P}$ and $\lass{Q}$ do not intersect in an action
  $\lass{P}\swap \lass{Q}$ (e.g.\ when their common parts have
  been removed according to 1.), then the application of the action
  must preserve the fence $\lass{F}$. Because the action is allowed to
  act partly outside of $\lass{F}$, the state on which the action is
  applied is $\lass{F} ** \lass{P}$, unlike local fencing where
  $\lass{P}$ would be contained in $\lass{F}$. The reason why
  $\lass{P}$ and $\lass{Q}$ must not intersect is precisely that we
  consider the action on $\lass{F} ** \lass{P}$ and not just $\lass{F}$;
  if $\lass{P}$ and $\lass{Q}$ have a non-empty intersection $l$ then
  it might be that $l$ is not part of $\lass{F}$ and is added together
  with $\lass{Q}$ by $*$ on the left-hand side of the sequent. But
  there is no guarantee that $I$ accounts for all possible actions on
  that piece of state $l$ since it was not part of $\lass{F}$, hence
  we could end up with an assertion $\shared{\lass{F}}{I}$ that does
  not satisfy the action closure property.
\end{enumerate}





\paragraph{Stability}
\fig\ref{fig:stability-rules} presents rules to show that an assertion
of the form $\exsts{\bar x}\lass{P} * \bigstar_{i\in
  I}\shared{\lass{Q}_i}{I_i}$ is stable. This is a more restricted
form of assertions than our two previous axiomatisations, but a more
elaborate set of rules exists for the general case (see~\cite{colosl-tr14}).
%(see Appendix~\ref{sec:assertions-continued}). 
The
first two rules state that local assertions are always stable and
existentials can be eliminated. Then, checking the stability of
$\lass{P} * \bigstar_{i\in I}\shared{\lass{Q}_i}{I_i}$ boils down to
establishing, for each subjective view $\shared{\lass{Q}_i}{I_i}$, the
four-place $\mathsf{Stable}$ predicate which in this case means that
$\lass{Q}_i$ is stable under the interference assertion $I_i$, a local
context $\lass{P}$, and a shared context made of the $**$-combination
of all the subjective assertions (including $\lass{Q}_i$).  In turn,
checking this fact reduces to checking stability for each action of
$I_i$. The last three rules deal with checking stability for a single
action, in a similar way to fencing rules above.

\begin{figure*}
\hrule\vspace*{5pt}
\begin{mathpar}
	\infer{\stable{\lass{P}}}{ }
	
%	\infer{
%		\stable{P}	
%	}
%	{
%		\stable{\un{P}}	
%	}
%
	\infer{
		\stable{\exsts{x} P}
	}
	{
		\stable{P}
	}

	\infer{
	  \stable{\lass{P} * \bigstar_{j\in J}\shared{\lass{Q}_j}{I_j}}
	}
	{
          \for{j\in J}
	  \stable{\lass{Q}_j, I_j, \lass{P}, \bigocon_{j\in J} \lass{Q}_j}
	}

%	\infer{
%		\stable{\shared{\lass{P}}{I}}	
%	}
%	{
%		\lass{P} \fences I	
%	}	
%	
%	\infer[?]{
%		\stable{\shared{\lass{P}}{I}}	
%	}
%	{
%		\stable{\shared{\lass{P}}{I'}} 
%		&
%		I' \weakenI{\lass{P}} I
%	}
%	
%	

	\infer{
	  \stable{\lass{Q},I,\lass{P},\lass{R}}
	}
	{
    \for{\interAss{[\token{A}]}{\bar{x}}{\lass{P_1}}{\lass{P}_2} \in I}
          \stable{\lass{Q},\{\interAss{[\token{A}]}{\bar{x}}{\lass{P_1}}{\lass{P}_2} \},\lass{P},\lass{R}}
	}	
	
	\infer{
	  \stable{\lass{Q},\{\interAss{[\token{A}]}{\bar{x}}{\lass{P}_1}{\lass{P}_2}\},\lass{P},\lass{R}}
	}
	{
	  [\token{A}] * \lass{P} * \lass{R} \slentails \m{false}
	}

	\infer{
	  \stable{\lass{Q},\{\interAss{[\token{A}]}{\bar{x}}{\lass{P}_1}{\lass{P}_2} \},\lass{P},\lass{R}}
	}
	{
	  \lass{P} * (\lass{R} ** \lass{P}_1) \slentails \m{false}
	}
	
	
	\infer{
	  \stable{\lass{Q},\{\interAss{[\token{A}]}{\bar{x}}{\lass{P}_1}{\lass{P}_2} \},\lass{P},\lass{R}}
	}
	{
	  \left(\lass{P}_1 \septraction (\lass{P} * (\lass{R} ** \lass{P}_1)\right) * \lass{P}_2 \slentails \lass{Q} * \m{true}
	}
\end{mathpar}
\hrule
%\vspace*{5pt}
\caption{Rules for checking stability (excerpt).
 We assume that variables in
  $\bar x$ do not appear free in $\lass{P}$, $\lass{Q}$, and $\lass{R}$.}
\label{fig:stability-rules}
\end{figure*}

The first of these is new: unlike fencing, stability only has to be
checked against actions for which the environment may hold enough
capabilities. If the capabilities required by the action cannot exist
separately from those held by the whole assertion, which may be summed
up by $\lass{P} * \lass{R}$, then the environment cannot perform the
action. Similarly, an action whose precondition is incompatible with
the current knowledge about the state cannot possibly fire. This is
what the premise of the next rule expresses: the local context is
composed (using $*$) with the shared context, itself overlapped with the precondition
of the action, since that precondition must hold somewhere in the
shared state, separately from any private state (but possibly
partially outside of the current combined subjective view of the
shared state). The last rule checks that a particular subjective
assertion $\lass{Q}$ is preserved by the effect of an action. Again,
there is a crucial difference with the corresponding check for
fencing: the action is applied to the whole state, but part of the
result can be discarded to re-establish $\lass{Q}$.



\paragraph{Proof reuse}
Finally, we note that, once a strict fencing judgement
$F\strictfences I$ has been established, it automatically
establishes a fencing judgement $F\fences I$, and in turn
$F\fences I$ implies that $F$ is stable under
$I$. The other directions are not valid in general: stability of $P$
under $I$ may omit part of the state resulting from an action
application to re-establish $P$, which is not allowed in fencing, and
fencing lacks the confinement condition required by local
fencing. Additionally, a fence $F$ for an interference
assertion $I$ is also a fence for any $I'$ that is a shifting of $I$ under
$F$.
  \vspace{-10pt}
\begin{mathpar}
  \vspace{-10pt}
	\infer{
		F \fences I	
	}{
		F \strictfences I	
	}

	\infer{
  	\stable{\shared{P}{I}}
	}{
	  P \fences I	
	}

	\infer={
		F \fences I
	}
	{
		F \fences I'
		&
		I' \weakenI{F} I	
	}
\end{mathpar}
	
%% ALSO I REMOVED THESE ONES
	
	%% \infer{
	%% 	I \cup I_1 \entailsI I \cup I_2
	%% }
	%% {
	%% 	I_1 \entailsI I_2
	%% }	
	
	%% \infer{
	%% 	\left\{ \interAss{[\token{A}]}{\bar{y}}{P}{Q} \right\}	
	%% 	\entailsI
	%% 	\left\{ \interAss{[\token{A}]}{\bar{y}}{\sumA{P}}{\sumA{Q}} \right\}	
	%% }{}
		
	%% \infer{
	%% 	\left\{ \interAss{[\token{A}]}{\bar{y}}{P}{Q} \right\}	
	%% 	\entailsI
	%% 	\left\{ \interAss{[\token{A}]}{\bar{y}}{P'}{Q'} \right\}	
	%% }
	%% {
	%% 	P \entails\! P'
	%% 	&
	%% 	Q \entails Q'	
	%% }
	
	%% \infer{
	%% 	\fenceAss{} \fences I
	%% }
	%% {
	%% 	I \entailsI I' 
	%% 	&
	%% 	\fenceAss{} \fences I'
	%% }

	%% \infer{
	%% 	I  \weakenI{\fenceAss{}} \emptyset
	%% }
	%% {
	%% 	I  \entailsI I'
	%% 	&
	%% 	I' \weakenI{\fenceAss{}} \emptyset
	%% }
%	
%	\infer{
%		I \cup I' \weakenI{\fenceAss{}} I
%	}
%	{
%		I \cup I' \entailsI I''
%		&
%		I'' \weakenI{\fenceAss{}} I
%	}
%		
%	\infer{
%		\left\{ [\token{A}]: P \swap Q \right\} \weakenI{\fenceAss{}} I'
%	}
%	{
%		\left\{ [\token{A}]: \erase{P} \swap \erase{Q} \right\} \weakenI{\fenceAss{}} I'
%	}
		
%% 	\infer
%% %	[\proofRule{Exist}]
%% 	{
%% 		\left\{[\token{A}]: \exists\overline{v_i \in S_i}^{i \in I}.\, P \swap Q \right\} 
%% 		\approx^{\m{true}}
%% 		\bigcup\limits_{\overline{w_i \in S_i}^{i \in I}} \left\{[\token{A}]: P \overline{[w_i /v_i]}^{i \in I} \swap  Q \overline{[w_i /v_i]}^{i \in I} \right\} 
%% 	}
%% 	{
%% 	}	


	%% \infer{
	%% 	\stable{P \odot Q}	
	%% }
	%% {
	%% 	\stable{P}
	%% 	&
	%% 	\stable{Q}	
	%% }

	%% \infer{
	%% 	\stable{P * Q}	
	%% }
	%% {
	%% 	\stableTo{P}{Q}
	%% 	&
	%% 	\stableTo{Q}{P}	
	%% }

	%% \infer{
	%% 	\stableTo{P}{R}	
	%% }
	%% {
	%% 	\stable{P}
	%% }	

	%% \infer{
	%% 	\stableTo{P * Q}{R}
	%% }
	%% {
	%% 	\stableTo{P}{Q * R}
	%% 	&
	%% 	\stableTo{Q}{P * R}
	%% }	
	
	%% \infer{
	%% 	\stableTo{P}{R * R'}
	%% }
	%% {
	%% 	\stableTo{P}{R}
	%% }	
		
	%% \infer{
	%% 	\stableTo{P \ominus Q}{R}
	%% }
	%% {
	%% 	\stableTo{P}{R}
	%% 	&
	%% 	\stableTo{Q}{R}
	%% }	
	
	%% \infer{
	%% 	\stableTo{\exsts{x} P}{R}
	%% }
	%% {
	%% 	\stableTo{P}{R}
	%% }
	
	%% \infer{
	%% 	\stableTo{\shared{\lass{P}}{I}}{R}
	%% }
	%% {
	%% 	\stableTo{\shared{\lass{P}}{I'}}{R}
	%% 	&
	%% 	I' \weakenI{\lass{P}} I
	%% }
	
	
	%% \infer{
	%% 	\stableTo{\shared{\lass{P}}{I}}{R}
	%% }
	%% {
	%% 	\stableIn{\lass{P}}{I}{R * \shared{\lass{P}}{I}}
	%% }

	%% \infer{
	%% 	\stableIn{\lass{P}}{\left\{\interAss{[\token{A}]}{\bar{y}}{Q_1}{Q_2}\right\}}{R}	
	%% }
	%% {
	%% 	\stableIn{\lass{P}}{\left\{\interAss{[\token{A}]}{\bar{y}}{\sumA{Q_1}}{\sumA{Q_2}}\right\}}{R}	
	%% }	
	
	%% \infer{
	%% 	\stableIn{\lass{P}}{\left\{\interAss{[\token{A}]}{\bar{y}}{Q_1}{Q_2}\right\}}{R}	
	%% }
	%% {
	%% 	Q_1 \entails Q'_1
	%% 	&
	%% 	Q_2 \entails Q'_2
	%% 	&
	%% 	\stableIn{\lass{P}}{\left\{\interAss{[\token{A}]}{\bar{y}}{Q'_1}{Q'_2}\right\}}{R}	
	%% }
	
	%% \infer{
	%% 	\stableIn{\lass{P}}{\left\{\interAss{[\token{A}]}{\bar{y}}{\lass{Q}_1}{\lass{Q}_2}\right\}}{R}	
	%% }
	%% {
	%% 	[\token{A}] * \prodA{R} \slentails \m{false}
	%% }
	
	
	%% \infer{
	%% 	\stableIn{\lass{P}}{\left\{[\token{A}]: \lass{Q}_1 \swap \lass{Q}_2 \right\}} {R}	
	%% }
	%% {
	%% 	\combine{R}{\lass{Q}_1} \slentails \m{false}
	%% }
	
	
	%% \infer{
	%% 	\stableIn{\lass{P}}{\left\{[\token{A}]: \lass{Q}_1 \swap \lass{Q}_2 \right\}}{R}	
	%% }
	%% {
	%% 	\left(\lass{Q}_1 \septraction \combine{R}{\lass{Q}_1} \,\right) * \lass{Q}_2 \slentails \lass{P} * \m{true}
	%% }

\subsection{Soundness}

We prove soundness of our \colosl reasoning, parametrised by the
underlying models of machine states ($\Heaps$) and capabilities
($\Caps$). We appeal to the general soundness result of the views
framework, providing parameters such as the reification function in
definition~\ref{def10} and proving lemmas required to make the result
hold.  

The main part of the proof  establishes
the soundness of the following rule for atomic commands, where
$\entails_{\textsf{SL}}$ represents standard sequential separation
logic:
\[
\infer[\proofRule{Atom}]{
  \hoare{P}{\atomic {\mathbb{C}}}{Q}
}{
  \entails_{\textsf{SL}} \{\lass{P}\}\;{\mathbb{C}}\;\{\lass{Q}\} &
  \repartitions{P}{Q}{\lass{P}}{\lass{Q}}
}
\]
This rule  is required in the frameworks from the
CAP family~\cite{cap-ecoop10,icap,tada}. 
For \colosl, the \emph{repartitioning} $\repartitions{P}{Q}{\lass{P}}{\lass{Q}}$
holds if, from any world $(l,g,\lmod)$ satisfying $P$, 
whenever $l \composeL  g$ 
satisfies $\lass{P}$ then we know that there exists $l'\composeL  g'$ which
satisfies $\lass{Q}$ in such a way that there exists $\lmod'$ such
that $(l', g', \lmod')$ satisfies $Q$. 
Moreover, the passage  from $(l,g,\lmod)$ to $(l',g',\lmod')$ can be
achieved via a succession of valid updates  from $\lmod$
 and 
valid extension steps . The details can be found in the accompanying technical
report~\cite{colosl-tr14}.
%Appendix\ref{sec:semantics}.

Semantic validity of Hoare triples depends on the definition of an
operational semantics $\mathbb{C}, m \rightarrow^{\text{*}}
\mathbb{C}', m'$, where $m, m' \in \Heaps$, and a 
reification function that relates  a \colosl world to
a concrete machine state.

\begin{definition}[Reification]\label{def:reification}
  The \emph{reification}, $\reifyW{.}: \Worlds \rightarrow \Heaps$ is
  defined as:
  \[
  \reifyW{(l, g, \lmod)} \eqdef \heapPart{(l \composeL g)}
  \]
\end{definition}

\begin{definition}[Valid triple]
  A triple is \emph{valid}, written $|= \{P\}\ \mathbb{C}\ \{Q\}$, if
  and only if,  for all $\lenv \in \LEnv$, $w \in  \Worlds$ and  $\h{}, \h{}' \in \Heaps$,
  \vspace{-10pt}
  \[
    \left(w, \lenv |= P  \land \mathbb{C}, \reifyW{w} \rightarrow^{\text{*}} \li{skip}, \h{}'\right)
    \text{ implies } \exsts{w'} w', \lenv |= Q \land \h{}' = \reifyW{w'}
  \]
\end{definition}

\begin{theorem}[Soundness]
  If $|-\!\{P\}\ \mathbb{C}\ \{Q\}$ then $|=\!\{P\}\ \mathbb{C}\ \{Q\}$.
\end{theorem}
