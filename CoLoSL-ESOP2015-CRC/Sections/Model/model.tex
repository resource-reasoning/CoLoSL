\section{\colosl}\label{sec:colosl}
We now give a more formal overview of how to use \colosl for program
verification, eschewing some details of the semantics for lack of space,
while still providing enough ingredients to carry program proofs. We
describe the underlying model of \colosl, give the semantics of
\colosl assertions, then present proof rules to reduce the various
checks one has to perform in the course of \colosl program proofs
(namely, the side-conditions of \shiftRule and \extendRule, and
stability checks) to classical separation logic entailments that, in
particular, do not mention subjective views.


\subsection{\colosl worlds}
\label{subsec:model}

A \emph{world} is a triple $(l, g, \lmod)$ where $l$ and $g$ are
\emph{logical states} and $\lmod$ is an \emph{action model}. The
\emph{local logical state} (local state) $l$ represents the
locally owned resources of a thread, in the standard separation logic
sense, while the \emph{global logical state} (shared state)
$g$ represents shared resources. An action model records all possible interferences on the shared state.

Logical states have two components: one describes machine states
(e.g.\ stacks and heaps); the other represents
\emph{capabilities}. The latter are inspired by the capabilities in
deny-guarantee reasoning~\cite{dg}: a thread in possession of a given
capability is allowed to perform the associated actions (as prescribed
by the \emph{action model} component of each world, defined below),
while any capability \emph{not} owned by a thread means that the
environment can perform the action. This can be seen as a unified
treatment of the rely and guarantee relations in rely-guarantee
reasoning~\cite{rg}: a capability fully owned (resp.\ fully not owned)
during the entire lifetime of a thread represents its guarantee
(resp.\ its rely), while a partially-owned capability means that the
corresponding action is both in the rely and the
guarantee. Capabilities go beyond the rely-guarantee model~\cite{dg};
in particular, they may be transferred between a thread and its
environment just like any other resource to temporarily block (enable) certain actions. See the presentation of
deny-guarantee~\cite{dg} (or CAP~\cite{cap-ecoop10}) for further details
and motivation.

In general, each component of a logical state is taken from an
arbitrary \emph{separation algebra}~\cite{asl} (i.e.\ a cancellative,
partial commutative monoid) that satisfies the
\emph{cross-split} property\footnote{A separation algebra
  $(\mathbb{B}, +, \mathbf{1})$ satisfies the cross-split property iff
  for all $a, b, c, d \in \mathbb{B}$, if $a + b = c + d$, there
  exists $x, y, z, w \in \mathbb{B}$ s.t.\ $a = x + y$, $b = z + w$,
  $c = x + z$, and $d = y + w$.}\cite{dockins2009fresh} (this is
needed for $**$ to be associative~\cite{ramification}).  As we demonstrate in the examples of
\S\ref{sec:examples}, our programs often call for a more complex model
of machine states and capabilities than that presented here. For instance, we may need our
capabilities to be fractionally owned, where ownership of a
\emph{fraction} of a capability grants the right to perform the action
to both the thread and the environment, while a fully-owned capability
by the thread \emph{denies} the right to the environment to perform
the associated action.  For ease of presentation, the focus of this
paper is on the standard stack and heap model for machine states, and
finite sets of \emph{tokens} (which are simple names) for
capabilities. We assume a set of program values $\set{Val}$, as well as infinite disjoint sets $\set{PVar}$, $\set{Loc}$, and $\set{Token}$ of program variables, memory locations, and tokens, respectively.

\begin{definition}[Logical states]
  A \emph{logical state} is a tuple $((@s, h), \ca{}) \in \LStates$, also written
  $(@s,h,\ca{})$, of a finite partial \emph{stack} $@s\in \set{Stack}$ associating
  program variables with values, a \emph{heap} $h \in \set{Heap}$ associating heap
  locations with values, and a \emph{capability} $\ca{} \in \Caps$. 
  \begin{mathpar}
    \set{Stack} == \set{PVar} --`_{\m{fin}} \set{Val}
    
    \set{Heap} == \set{Loc} --`_{\m{fin}} \set{Val}
    
    \Heaps == \set{Stack}\times \set{Heap}
    
    \Caps == \powerset_{\m{fin}}(\set{Token})
    
    \LStates == \Heaps\times \Caps
  \end{mathpar}
\end{definition}

The local and global logical states of a world are always
\emph{compatible}: they can be composed with one another. This captures the intuition that privately-owned resources are disjoint from shared resources. The composition of logical states is defined component-wise as disjoint function union $\uplus$ over stacks and heaps, and disjoint set union $\uplus$ on capabilities.

\begin{definition}[Logical state composition]
  The \emph{composition of logical states} $ \composeL : \LStates
  \times \LStates \rightharpoonup \LStates $ is defined
  as:
  \[
  ((@s, h),\ca{}) \composeL ((@s', h'), \ca{}') \eqdef
  ((@s\uplus @s', h\uplus h'), \ca{}\uplus \ca{}')
  \]
  %% The \emph{separation algebra of logical states} is given by
  %% $(\LStates, \composeL, \unitL)$.
\end{definition}

We write $l$ to range over either arbitrary logical states or just local states. Given a logical state $l= (@s, h, \ca{})$, we write $l_{@s}, l_h$ and $l_{\ca{}}$ for the first, second, and third projections, respectively and write $l_{\textsf{M}}$ for $(@s, h)$. We write $g$ to range over logical states representing shared (global) states. The empty logical state
$(\emptyset, \emptyset, \emptyset)$ is written $\unitL$. We write $l_1
\leq l_2$ when there exists $l$ such that $l\composeL l_1 = l_2$, and
write $l_2 - l_1$ to denote the unique (by cancellativity) such $l$ when it
exists. When $l_1\composeL l_2$ is defined, we say that $l_1$ and
$l_2$ are \emph{compatible} and write $l_1\compatL l_2$.

An action is a triple $(p, q, c)$ of logical states where
$p$ and $q$ are the action \emph{pre-} and \emph{post-states} describing how the shared state is modified by the action; and $c$ is the action \emph{catalyst}: it has to be present for the action to take effect, but is left unchanged by the action. Moreover, the catalyst is maximal in the sense that no further, non-empty catalyst $c'$ can be found such that $c' \leq p$ and $c' \leq q$. For instance, the action corresponding to $s_x$ in \fig\ref{fig:concurrentInc}, is informally the triple ($(\emptyset, \{x:v\}, \emptyset)$, $(\emptyset, \{x:v{+}1\}, \emptyset)$, $(\emptyset, \{x-1:v{+}1\}, \emptyset)$).

An action model is a partial function from \emph{capabilities} to sets
of \emph{actions}; action models correspond to the (semantic interpretation of)  interference assertions
$I$.
%
\begin{definition}[Action models]
  The set of \emph{actions} $\set{Action}$, ranged over by $a$, and
  the set of \emph{action models} $\AMods$, ranged over by $\lmod$, are
  defined as:
  \begin{mathpar}
    \set{Action} == \LStates \times \LStates \times \LStates
    
    \AMods == \Caps \rightharpoonup \pset{\set{Action}}
  \end{mathpar}
%  We write $\unitAM$ for an action model with empty domain.
\end{definition}
%
\paragraph{Well-formed worlds}
are triples
$(l,g,\lmod)\in\LStates\times\LStates\times\AMods$ that satisfy the
well-formedness conditions: 1) the local and shared states are always
compatible ($l\compatL g$); 2) the capabilities owned by $l$ and $g$ are
in the domain of $\lmod$; and 3) actions in $\lmod$ are
\emph{confined} to $g$ (written $g\containI\lmod$). An action $a= (p, q, c)$ is confined to $g$ if 
whenever it is enabled ($p \composeL c$ is compatible with $g$), then its pre-state $p$ is contained in $g$ ($p \leq g$). We provide an informal description of confinement in
\S\ref{subsec:prules}. The formal definition of confinement is provided in~\cite{colosl-tr14}.

\begin{definition}[Well-formedness]
  \label{def:wf}
  A triple $(l, g, \lmod)\in\LStates\times\LStates\times\AMods$ is \emph{well-formed},
  written $\wf{l, g, \lmod}$, iff
  \vspace{-1ex}
  \[
  \begin{array}{L}
    l \compatL g
    /|
    l_{\ca{}} \cup g_{\ca{}} \subseteq \bigcup \m{dom}(\lmod)
    /|
    g \containI \lmod
  \end{array}
\vspace{-1ex}
\]
%
\end{definition}

\begin{definition}[Worlds]\label{def:worlds}
The set of \emph{worlds} is defined as
%
\[
	\Worlds \eqdef 
	\{w\in \LStates\times\LStates\times\AMods ||| \wf{w}\}
\]
\end{definition}
%
Well-formed worlds do not put further constraints on the
relationship between $\lmod$ and $g$, they are however linked more tightly in
the semantics of assertions (\S\ref{subsec:assertions}).

Finally, the composition of two worlds combines their local states, and is defined whenever the worlds agree on the other two
components and the resulting tuple is a well-formed world.

\begin{definition}[World composition]
  The \emph{composition} of worlds, $\composeW: \Worlds \times \Worlds \rightharpoonup \Worlds$, is defined as:
  \[
	(l,g,\lmod) \composeW (l',g',\lmod') \eqdef
	\begin{cases}
		(l\composeL l', g, \lmod) &
		\begin{array}[t]{L}
			\text{if }
			g = g' \text{, and }
			\lmod = \lmod' \text{, and }\p{wf}((l\composeL l', g, \lmod))
		\end{array}\\
		\textit{undefined}&\text{otherwise}
	\end{cases}
\]
\end{definition}

%% The set of well-formed worlds with composition $\composeW$ forms a
%% separation algebra with multiple units: all well-formed worlds of the
%% form $(\unitL,g,\lmod)$.

\subsection{\colosl Assertions}
\label{subsec:assertions}

Our assertion language extends separation logic with \emph{subjective
  views} and \emph{capability assertions}.

\colosl is parametric in the assertions of machine states and
capabilities and can be instantiated with any assertion language over
machine states $\Heaps$ and capabilities $\Caps$. In this paper, we
use standard heap and stack assertions for machine state assertions,
and single-token assertions of the form $[\token{a}]$ for capability
assertions where $\token{a} \in \set{Token}$. We write $[\token{A}]$
as a shorthand for $\bigstar_{\token{a} \in \token{A}} [\token{a}]$.
We assume an infinite set $\set{LVar}$ of \emph{logical variables},
disjoint from $\set{PVar}$.

\begin{definition}[Assertion syntax]\label{def:assertions}
Given $x \in \set{LVar}$, $\li{x} \in \set{PVar}$, and $\token{a} \in \set{Token}$, \emph{the assertions of \colosl}, $\Assertions$, are described by the grammars below:
%
\begin{align*}	 
  A &::=\m{false} \mid E_1 = E_2 \mid \emp \mid \li{x} \harpoonything E \mid E_1 |-> E_2 \mid [E]\\
  \LAssertions \ni \lass{p}, \lass{q} & ::= A \mid \neg\lass{P} \mid \exsts{x} \lass{P} \mid \lass{P} \lor \lass{Q} \mid \lass{P} * \lass{Q} \mid \lass{P} ** \lass{Q} \mid \lass{P} \septraction \lass{Q}\\
  \Assertions \ni P,Q & ::= \lass{P} \mid \exsts{x} P \mid P \lor Q \mid P * Q \mid P ** Q \mid \shared{P}{I}  \\
  I &::= \emptyset \mid \{\interAss{[\token{A}]}{\bar{x}}{P}{Q}\} \cup I
  \quad
  E ::= x \mid \token a \mid E_1 + E_2 \!\mid\! \cdots
\end{align*}
\end{definition}

As in RGSep~\cite{viktor-marriage}, we distinguish between
\emph{local assertions} in $\LAssertions$ and assertions in
$\Assertions$. For simplicity, assertions do not include negation or
magic-wand; these are reserved for local assertions. The syntax of
assertions follows from standard separation logic with variables-as-resource~\cite{variablesAsResource} (note that expressions $E$ do not
allow program variables), with the exception of the subjective views
$\shared P I$.  Machine and capability assertions are
interpreted over a world's local state: $\li{x} \harpoonything E$
(resp.\ $E_1|->E_2$) is true of the singleton stack (resp.\ heap)
where only \li{x} (resp.\ address $E_1$) is allocated and has value
$E$ (resp.\ points to $E_2$); the capability assertion $[E]$ is true
of the singleton capability $\{\token{a}\}$ if $E$ evaluates to
$\token a$.  $\emp$ is true of worlds with empty local state (the
units of $\composeW$); $P * Q$ is true of worlds that can be split
into two according to $\composeW$ such that one state satisfies $P$
and the other satisfies $Q$; $P**Q$ is the \emph{overlapping
  conjunction}, true of worlds can be split three-ways according to
$\composeW$, such that the $\composeW$-composition of the first two
worlds satisfies $P$ and the $\composeW$-composition of the last two
satisfy $Q$~\cite{rey-slnotes}; classical predicates and connectives
have their standard classical meaning. An Interference assertion $I$ describes actions enabled by a given capability, in the form of a pre- and post-condition.
%Following the RGSep style~\cite{viktor-marriage}, interference assertions $I$ describe actions enabled by a given capability, in the form of a pre- and post-condition ($P$ and $Q$ respectively) as well as a side-condition ($R$). We write $P \swap Q$ as a shorthand for $\action{P}{Q}{\emp}$.

A subjective view $\shared P I$ is true of $(l,g,\lmod)$ when $l =
\unitL$ and a \emph{subjective view} $s$ can be found in the global
shared state $g$ (i.e.\ $g = s\composeL r$ for some \emph{context}
$r$), such that $s$ satisfies $P$ in the standard separation logic
sense, and $I$ and $\lmod$ \emph{agree} given the decomposition $s$,
$r$, in the following sense, which we write as
$\extendsAM{\lmod}{s}{r}{\semI{I}}$:
%Appendix~\ref{sec:model-continued}):
\begin{enumerate}
	\item every action in $I$ is reflected in $\lmod{}$;
	
	\item every action in $\lmod$ that has a visible effect on $s$ is reflected in $I$;
	
	\item the above holds after any number of actions in $\lmod$ takes place.
%	\item the above is true for any state resulting from any number of actions of $\lmod$ applied to $g$.
%	\item the above is true after any number of action applications in $I$ that affect $g$ and any number of action applications in $\gmod$ that affect $r$ but not $s$.
\end{enumerate}

We refer to the above agreement between the action model and subjective views as the \emph{action model closure property}. We omit its definition for lack
of space; it can be found in~\cite{colosl-tr14}. The semantics of \colosl assertions is given by a forcing relation
$w,\lenv|= P$ between a world $w$, a logical environment
$\lenv\in\LEnv$, and a formula $P$. We use two auxiliary forcing
relations. The first one $l,\lenv\slsat p$ interprets local assertions
$p\in\LAssertions$ in the usual separation logic sense over a logical
state $l$. The second one $s,\lenv|=_{g,\lmod} P$ interprets
assertions over a \emph{subjective state} $s$ that is part of the
global shared state $g$, subject to action model $\lmod$. This third
form of satisfaction is needed to deal with nesting of subjective
views.
%% \footnote{This presentation with
%%   several forcing relations differs from the usual CAP
%%   presentation~\cite{cap-ecoop10}, where formulas are first
%%   interpreted over worlds that are not necessarily well-formed, and
%%   then cut down to well-formed ones. The CAP presentation strays from
%%   separation logic models in some respects; e.g.\ in CAP, $*$ is not
%%   the adjoint of $--*$, the ``magic wand'' connective of separation
%%   logic. Although we have omitted this connective from our
%%   presentation, its definition in \colosl would be standard and
%%   satisfy the adjunction with $*$.}.
Since logical connectives are interpreted uniformly in all cases, we
write $|=_\dagger$ for any of the three satisfaction relations, and
then write $u$ for elements of either $\Worlds$ or $\LStates$, and
$\grey$ for either $\composeW$ or $\composeL$, depending on whether
the satisfaction relation is $|=$, or either $\slsat$ or
$|=_{l,\lmod}$, respectively.

\begin{definition}[Assertion semantics]\label{def:assertion-semantics}
Given a logical environment $\lenv: \set{LVar} --> \set{Val}$, the
semantics of \colosl assertions is as follows, where $\semI[(.)]{.}:
\LEnv \rightarrow \AMods$ denotes the semantics of interference
assertions.
\vspace{-1ex}
%
\[
\begin{array}{R>{\null}l@{\ \,}c@{\ \,}l}
  (l,g,\lmod), \lenv &|= \lass{P}  &\text{iff}& l,\lenv \slsat \lass{P}\\
  
  (l,g,\lmod), \lenv &|= \shared P I &\text{iff}&
  l = \unitL \text{ and }
  \exsts{s,r}
  g = s\composeL r\text{ and }
  s, \lenv |=_{g,\lmod} P\text{ and }
  \extendsAM{\lmod}{s}{r}{\semI[\lenv]{I}}
\end{array}
\]
\vspace{-3.0ex}
\[
\begin{array}{R>{\null}l@{\ \,}c@{\ \,}l}
  s, \lenv &|=_{g,\lmod} \lass{P} &\text{iff}& s, \lenv \slsat \lass{P}\\
  
  s, \lenv &|=_{g,\lmod} \shared P I &\text{iff}&
  (s,g,\lmod), \lenv |= \shared P I\\
  
  u,\lenv &|=_\dagger \exsts x P
  &\text{iff}& \exsts v u, [\lenv|||x:v] |=_\dagger P\\
%  
%  u,\lenv &|=_\dagger \for{x} P
%  &\text{iff}& \for{v}u, [\lenv|||x:v] |=_\dagger P\\
  
  u,\lenv &|=_\dagger P \lor Q
  &\text{iff}& u,\lenv |=_\dagger P\text{ or }u,\lenv |=_\dagger Q\\
  
  u, \lenv &|=_\dagger P_1 * P_2 &\text{iff}&
  \exsts{u_1,u_2} u = u_1 \grey u_2\text{ and }
  u_1, \lenv |=_\dagger P_1 \text{ and }u_2, \lenv |=_\dagger P_2\\
  
  u, \lenv &|=_\dagger P_1 ** P_2 &\text{iff}&
  \exsts{u',u_1,u_2} u = u'\grey u_1\grey u_2\text{ and}\\
  &&&
  u' \grey u_1, \lenv |=_\dagger P_1 \text{ and }
  u' \grey u_2, \lenv |=_\dagger P_2\\	
  
%  l, \lenv &\slsat [E]
%  &\text{iff}&
%  l = (\emptyset,\emptyset, \{[|E|]_{\lenv}\})\\
%  &&\cdots\\

  l,\lenv &\slsat \m{false}  && \text{never}\\

  l, \lenv &\slsat \emp &\text{iff}&l = \unitL\\
  
  l,\lenv &\slsat E_1 = E_2
  &\text{iff}& [|E_1|]_{\lenv} = [|E_2|]_{\lenv}\\

  l, \lenv &\slsat \li{x} \harpoonything E
  &\text{iff}&
  l = ([\li x: [|E|]_{\lenv}], \emptyset, \emptyset)\\
  
  l, \lenv &\slsat E_1|->E_2 
  &\text{iff}&
  l =
  (\emptyset, [[|E_1|]_{\lenv}: [|E_2|]_{\lenv}], \emptyset)\\
  
  l, \lenv & \slsat [E]
  & \text{iff} &
  l = (\emptyset, \emptyset, \{[|E|]_{\lenv}\})\\
  
  l,\lenv &\slsat \neg \lass{P}
  &\text{iff}& l,\lenv \not\slsat \lass{P}\\
  
  l, \lenv &\slsat \lass{P} \septraction \lass{Q} &\text{iff}&
  \exsts{l'} l', \lenv \slsat \lass{P} \text{ and }
  l \compatL l'
  \text{ and }l \composeL l', \lenv \slsat \lass{Q}
\end{array}
\]
\vspace{-1em}
%
\begin{align*}
%\semI[\lenv]{I}(\token{A}) &==
%  \left\{
%  \begin{array}{@{}l@{\ }|@{\ }r@{}}
%    (p \composeL r, q \composeL r)&
%    \begin{array}{@{}l@{}}
%      \interAss{[\token{A}]}{\bar x}{P}{Q}{} \in I /|  \exsts{\bar{v}, \lmod} \\
%%      \lenv' = [\lenv|||\bar y:\bar v] \\
%%      /| (p \composeL r), \lenv'\slsat \sumA{P} 
%%      /| (q \composeL r), \lenv' \slsat \sumA{Q} \\
%      \quad p, [\lenv|||\bar x:\bar v]  |=_{p \composeL r, \lmod} P 
%      /| q, [\lenv|||\bar x:\bar v]  |=_{q \composeL r, \lmod} Q 
%    \end{array}
%  \end{array}
%  \right\}
\semI[\lenv]{I}(\token{A}) &==
  \left\{
  \begin{array}{@{}l@{\ }|@{\ }r@{}}
    (p, q, c )&
    \begin{array}{@{}l@{}}
      \interAss{[\token{A}]}{\bar x}{P}{Q} \in I /| \exsts{\bar{v}, \lmod, r, r'} \\
      \quad c = r \composeL r' \land \for{l} l \leq p \land l \leq q \implies l = \unitL\\
      \quad p \composeL r, [\lenv|||\bar x:\bar v]  |=_{p \composeL c, \lmod} P 
      /| q \composeL r,  [\lenv|||\bar x:\bar v]  |=_{q \composeL c, \lmod} Q 
    \end{array}
  \end{array}
  \right\}
%\semI[\lenv]{I}(\token{A}) &==
%  \left\{
%  \begin{array}{@{}l@{\ }|@{\ }r@{}}
%    (p, q, r \composeL c)&
%    \begin{array}{@{}l@{}}
%      \interAss{[\token{A}]}{\bar x}{P}{Q}{R} \in I /| \exsts{\bar{v}, \lmod} \\
%      \quad p, [\lenv|||\bar x:\bar v]  |=_{p \composeL r \composeL c, \lmod} P 
%      /| q, [\lenv|||\bar x:\bar v]  |=_{q \composeL r \composeL c, \lmod} Q \\
%      \quad r, [\lenv|||\bar x:\bar v]  |=_{p \composeL r \composeL c, \lmod} R /|
%      r, [\lenv|||\bar x:\bar v]  |=_{q \composeL r \composeL c, \lmod} R \\
%    \end{array}
%  \end{array}
%  \right\}
\end{align*}
\end{definition}

Note that, as in the CAP family~\cite{cap-ecoop10,icap,tada}, \colosl
cannot ensure that proved programs do not leak memory. This is because
of the following property of the semantics with respect to the shared
state (sometimes called ``intuitionistic semantics''~\cite{rey02}): if
$(l,g,\lmod), \lenv |= P$ then $(l,g\circ g',\lmod), \lenv |= P$.


Five of the principles of \fig\ref{fig:principles} are direct
consequences of the semantics.

\begin{lemma}
  \label{lem:assertion-facts}
  The \colosl reasoning principles 
  \forgetRule, \mergeRule, \shiftRule, \weakenRule, and \copyRule are valid.
  %% \begin{mathpar}
  %%       \infer{
  %%       	\shared{P}{I} * \shared{Q}{I'} \entails \shared{R}{I} * \shared{Q}{I'}
  %%       }
  %%       {
  %%       	R \entails P
  %%       	&
  %%       	P \sepish Q \entails R \sepish Q
  %%       }
  %% \end{mathpar}
\end{lemma}
\begin{proof}[sketch]
  The cases of \weakenRule and \copyRule are
  straightforward. \forgetRule, \mergeRule and \shiftRule principles are valid as action
  model closure is preserved when picking a smaller subjective state, when taking the union of subjective states and their interference assertions, or when shifting the interference assertion, respectively. The full proof is provided in~\cite{colosl-tr14}.
  \qed
\end{proof}


\subsection{Reducing \colosl principles to separation logic entailments}
\label{subsec:prules}

We turn to the remaining two principles, \extendRule and \shiftRule,
and to the stability condition. These involve reasoning outside our
assertion language, potentially requiring semantic reasoning 
in the model. Fortunately, it is enough to work
with a partial 
axiomatisation  for all three conditions to verify
our examples. In this section, we give cut-down versions of these
rules for a fragment of the \colosl assertion language where the 
nesting of subjective views is not permitted   and  interference
assertions cannot mention subjective views. This restriction is easily
lifted. We can always \emph{flatten}
assertions with nested boxes into logically equivalent assertions with
no nesting, and  interference assertions  mentioning  other
subjective views in their actions may be rewritten into ones
that do not.  See~\cite{colosl-tr14} for the full details.% Appendix~\ref{sec:assertions-continued}.

%% Moreover, in the restricted case where actions and fences (see below)
%% can be expressed in a fragment extending the usual \emph{symbolic
%%   heaps} used in automatic tools based on separation logic, starting
%% with Smallfoot~\cite{smallfoot}, without inductive predicates but
%% including the $**$ connective (this corresponds to replacing $p$ with
%% $A$ in the grammar of assertions), the separation logic entailments
%% that need to be discharged once the rules of this section have been
%% applied can be verified automatically. Indeed, for this fragment, we
%% can extend the $--o$-elimination procedure of Calcagno et
%% al. in~\cite{vv07msc} to deal with $**$ as well. We leave the details
%% of this adaptation to Appendix~\ref{sec:assertions-continued}. The following standard definition will
%% be needed in the remainder of this section.

\begin{definition}[Exactness, precision]
The local assertion   $p\in\LAssertions$ is \emph{exact}
(respectively, 
\ \emph{precise}) if it is
  satisfied by at most one state (respectively, one substate of each state):
  \begin{align*}
    \exact{p} &==
    \for{\lenv, l_1, l_2} l_1, \lenv \slsat p\text{ and }l_2, \lenv
    \slsat p\text{ implies } l_1 = l_2\\
    \precise{p} &==
    \for{\lenv, l, l_1, l_2} l_1\leq l\text{ and }l_2\leq l\text{ and }l_1, \lenv \slsat p\text{ and }l_2, \lenv
    \slsat p\\
    &\qquad\text{ implies } l_1 = l_2
  \end{align*}
\end{definition}

\paragraph{Confinement}
\colosl models the shared state as a single ``region'' of memory and a
set of potential actions on that region, represented by the last two
components of each world $(l,g,\lmod)$. \colosl's most
distinguishing features are the ability to focus on a sub-part of this
shared region, to extend the shared state, and to exchange an
interference assertion for an other that is equivalent as far as the
subjective view is concerned. The soundness of \colosl hinges on the
fact that the action model $\lmod$ of a world contains all the actions
that could possibly affect the shared state $g$. (Similarly, the
action model closure ensures that subjective views in assertions have
to account for all actions potentially affecting their piece of the shared
state.) Moreover, the pieces of the local state delimited by $l'$ can migrate to
the shared state at any time under a new set of actions $\lmod'$,
yielding a new shared state $g\composeL l'$ and action model $\lmod
\cup \lmod'$.

In order not to invalidate the views that other threads hold of the
shared state, in the situation above we require that the actions in
$\lmod'$ are \emph{confined} to $l'$: whenever an action $a = (p, q, c)$ of
$\lmod'$ is enabled, its pre-state $p$ (those parts of the shared state modified by $a$) must be a substate of $l'$. However, new actions are allowed to
require the presence of some neutral resource outside of $l'$ provided that they are conserved by the action (i.e. they are present in $c$).
%
For instance, abusing notations temporarily to ignore empty stack and
capability components in logical states, the action $a = (\{10:0, 12:0\}, \{10:1, 12:1\}, \{14:0\})$ (which modifies the cells at addresses 10 and 12 to point from 0 to 1 provided that location 14 points to 0), is
confined in the states $l_1=\{10:0,12:0\}$ and $l_2=\{10:1\}$, but not in
$l_3=\{10:0\}$. Indeed $p \composeL c$ is compatible with $l_1$ and $l_3$, and the
modified cells 10 and 12 are fully contained in $l_1$ but not in
$l_3$; $p \composeL c$ is not compatible with $l_2$, hence $a$ has no effect on
$l_2$ and is automatically confined to $l_2$.
%
Moreover, we require not only that all actions in $\lmod'$
are confined to $l'$ in this sense, but also that all states resulting
from the successive application of actions in $\lmod'$ themselves confine
all actions in $\lmod'$. Inspired by the LRG approach~\cite{lrg}, this is achieved by first finding a set that
is invariant under all actions in $\lmod'$ (called a \emph{fence}),
then checking the confinement condition for each action.

In the logic, the shared state is extended by the resources in
$P$ under the interference assertion $I$ via the \extendRule principle,
which requires that $P\containI I$ be
established. \fig~\ref{fig:local-fencing-rules} presents a set of
rules to reduce $P \containI I$ to a series of entailments in
ordinary separation logic. As expressed by the first rule,
$P \containI I$ holds if there is a weaker local assertion $\lass{F}$
that acts as a \emph{local fence} for $I$, denoted by
$\lass{F}\strictfences I$; in particular, this means that $\lass{F}$
must be invariant under all actions of $I$. In~\cite{colosl-tr14}
%Appendix~\ref{sec:assertions-continued} 
we show that it is always possible to weaken an assertion into a local assertion. This fencing condition is
checked for each action in $I$ (see the second rule). For each action
$\lass{P}\swap \lass{Q}$, the three remaining rules of the figure may
apply. In the first of these rules, the action cannot possibly fire,
because its pre-condition does not agree with $\lass{F}$: no state
satisfying $\lass{F}$ may be extended such that a sub-part satisfies
$\lass{P}$. 
%The second of these rules allows one to trim the side-condition as it is left unchanged by the action. 
The second of these rules allows one to trim neutral parts
$\lass{R}$ of an action $\lass{P}\swap \lass{Q}$: if $\lass{R}$
appears both in $\lass{P}$ and $\lass{Q}$, and $\lass{R}$ is exact,
then the part of the state denoted by $\lass{R}$ is uniquely
determined and left unchanged by the action. 
The last rule finally reduces local fencing to entailment checking, provided the fence
$\lass{F}$ can be expressed as a disjunction of precise formulas. The
first premise states that $\lass{F}$ is invariant under the action
$\lass{P}\swap \lass{Q}$, similar to the way that RGSep encodes
stability checks as separation logic entailments. Informally, it
reads: for any state in $f$, remove a part satisfying $p$ and add a
state satisfying $q$; the result should still be in $f$. The third
premise checks the confinement condition: given a state in $f_i$ ($l_1\composeL l_2|= \lass{F}_i$), and an extension of it ($l = l_1 \composeL l_2 \composeL l_3$) where a sub-part of $l$ satisfies $\lass{P}$ ($l_2 \composeL l_3 |= f_i$), the extension $l$ itself is also in $f_i$ ($l_1\composeL l_2\composeL
l_3|=\lass{F}_i$, hence by precision of $\lass{F}_i$, we have $l_2\composeL
l_3\leq l_1\composeL l_2\composeL l_3 = l_1\composeL l_2$)
%if a sub-part of an extension of a state in $\lass{F}_i$ satisfies $\lass{P}$
%($l_1\composeL l_2|= \lass{F}_i$ and $l_2\composeL l_3 |= \lass{P}$),
%then it is also a sub-part of that state ($l_1\composeL l_2\composeL
%l_3|=\lass{F}_i$, hence by precision of $\lass{F}_i$, $l_2\composeL
%l_3\leq l_1\composeL l_2\composeL l_3 = l_1\composeL l_2$).

\begin{figure}
\hrule\vspace{5pt}
\begin{mathpar}
	\infer{
	  P \confines I	
	}
	{
	  P \entails \fenceAss{}&
	  \fenceAss{} \strictfences I
	}
	
	\infer{
		\fenceAss{} \strictfences I
	}
	{
          \for{\left(\interAss{[\token{A}]}{\bar x}{\lass{P}}{\lass{Q}}\right)\in I}\fenceAss{} \strictfences \left\{\interAss{[\token{A}]}{\bar x}{\lass{P}}{\lass{Q}} \right\}
	}		

	\infer{
		\fenceAss{} \!\strictfences\! \left\{\interAss{[\token{A}]}{\bar x}{\lass{P}}{\lass{Q}} \right\}		
	}
	{
		\fenceAss{} \sepish \lass{P} \slentails \m{false}
	}	

	\infer{
		\fenceAss{} \strictfences \left\{\interAss{[\token{A}]}{\bar x}{\lass{P}}{\lass{Q}}\right\}	
	}
	{
    \lass{P} \slentails \lass{P'} * \lass{R}\\
    \lass{Q} \slentails \lass{Q'} * \lass{R}\\
	  \exact{\lass{R}}\\
	  \fenceAss{} \strictfences \left\{[\token{A}]\!\!: \exsts{\bar x} \lass{P'} \swap \lass{Q'} \right\}
	}	
		
%	\infer{
%		\fenceAss{} \strictfences \left\{\capAss{}: \lass{P} \swap \lass{Q} \right\}		
%	}
%	{
%		\fenceAss{}' \slentails \fenceAss{}
%		&
%		\fenceAss{} \sepish \lass{P} \slentails \fenceAss{}' \sepish \lass{P}
%		&
%		\fenceAss{}' \strictfences \left\{\capAss{}: \lass{P} \swap \lass{Q} \right\}		
%	}
%		
	\infer{
		\fenceAss{} \strictfences \left\{\interAss{[\token{A}]}{\bar x}{\lass{P}}{\lass{Q}} \right\}		
	}
	{	
%		\separate{\lass{P}}{\lass{Q}}
%		&
		\left(\lass{P} \septraction \fenceAss{} \right) * \lass{Q} \slentails \fenceAss{}	
		\\
		\fenceAss{} \!<=>\! \bigvee\limits_{i \in I}\fenceAss{i} 		
		\\
		(\precise{\fenceAss{i}}
		\land
		\fenceAss{i} \sepish \lass{P} \slentails \fenceAss{i}
		\;\;\text{for } i \in I)
	}	
%	{
%		\begin{array}{@{} l @{}}			
%			\separate{\lass{P}}{\lass{Q}}
%			\quad
%			\left(\lass{P} \septraction \fenceAss{} \right) * \lass{Q} \slentails \fenceAss{}	
%			\quad
%			\fenceAss{} <=> \bigvee\limits_{i \in I}\fenceAss{i} 		\\
%			%
%			\precise{\fenceAss{i}}
%			\quad 
%			\fenceAss{i} \sepish \lass{P} \slentails \fenceAss{i}
%			\quad
%			\text{for } i \in I
%		\end{array}
%	}	
%	
\end{mathpar}
\hrule
\caption{Confinement and local fencing rules. We assume that variables in
  $\bar x$ do not appear free in $\lass{F}$ and $\lass{F}_i$ for any $i$.}
\label{fig:local-fencing-rules}
\end{figure}


In the same way that all new extensions to the shared states are confined, any world
must also be confined, as to not interfere with its future extensions. This is captured by the confinement condition in the well-formedness of worlds.
%, which repeats the definition of confinement
%for assertions at the model level.


\paragraph{Shifting/fencing judgements}
\fig\ref{fig:shifting-rules} presents an axiomatisation of the main
shifting principles, our mechanism to rewrite interference assertions
in subjective views via \shiftRule. As with confinement, we omit the
direct semantic definition, which can be found in~\cite{colosl-tr14}.
% Appendix~\ref{sec:model-continued}.
The
pseudo-entailment $\separate{\lass{P}}{\lass{Q}}$ asserts that states
described by $\lass{P}$ and $\lass{Q}$ have \emph{empty
  intersections}: whenever $l_1, \lenv \slsat \lass{P}$ and $l_2,
\lenv \slsat \lass{Q}$, $l_1$ and $l_2$ do not have any non-trivial
common sub-state ($\for{l} l \leq l_1 \land l \leq l_2 \implies l =
\unitL$). This is expressible using standard connectives as follows:
\[
\separate{\lass{P}}{\lass{Q}} <=> \lass{P} \slentails \neg\left( \m{true} * (\neg\emp \land (\m{true} \septraction \lass{Q}) ) \right)
\]
%In Appendix~\ref{sec:assertions-continued} we also axiomatise
%non-intersection directly, which provides an alternative way to check
%non-intersection for a restricted fragment of formulas.

\begin{figure}
\hrule\vspace{5pt}
\begin{mathpar}
	\infer{
		I \weakenI{P} I'	
	}
	{
		P \entails \fenceAss{}\\
		I \weakenI{\fenceAss{}} I'
	}	
	
	\infer{
	  I\weakenI{\fenceAss{}} I
	}{}
	
	\infer{
		I \cup I_1 \weakenI{\fenceAss{}} I \cup I_2
	}
	{
		\fenceAss{} \fences I \cup I_1	
		&
		I_1 \weakenI{\fenceAss{}} I_2
	}	

%	\infer{
%		\left\{\interAss{[\token{A}]}{\bar x}{\lass{P}}{\lass{Q}}{\lass{R}} \right\} \approx^{\fenceAss{}}
%		\left\{\interAss{[\token{A}]}{\bar x}{\lass{P'}}{\lass{Q'}}{\lass{R} * \lass{R}'} \right\}
%	}
%	{
%          \lass{P} \slentails \lass{P'} * \lass{R'}\\
%          \lass{Q} \slentails \lass{Q'} * \lass{R'}\\
%	  \exact{\lass{R'}}\\
%	}	
%	
%%	\infer{
%%		\left\{ [\token{A}]: \exsts{\bar x}\lass{P}  \swap \lass{Q} \right\} \weakenI{\fenceAss{}}
%%		\emptyset
%%	}
%%	{
%%          \lass{P} \slentails \lass{P'} * \lass{R}\\
%%          \lass{Q} \slentails \lass{Q'} * \lass{R}\\
%%	  \exact{\lass{R}}\\
%%	  \separate{\fenceAss{}}{\lass{P'}}
%%	}	
	\infer{
		\left\{\interAss{[\token{A}]}{\bar x}{\lass{P}}{\lass{Q}} \right\} \weakenI{\fenceAss{}}
		\emptyset
	}
	{
		\lass{P} \slentails \lass{P'} * \lass{R}\\
    \lass{Q} \slentails \lass{Q'} * \lass{R}\\
	  \exact{\lass{R}}\\
	  \separate{\fenceAss{}}{\lass{P'}}
	}	

	\infer
%	[\proofRule{False-R}]
	{	
		\left\{[\token{A}]: \exsts{\bar x}\lass{P} \swap \lass{Q} \right\} \weakenI{\fenceAss{}} 
		\emptyset 	
	}
	{
%		& \fenceAss{} \fences  \left\{ [\token{A}]: \left\{ P \swap Q \right\}\right\}
		\left(\lass{P} \septraction (\lass{P} \sepish \fenceAss{})\right) * \lass{Q} \slentails \m{false}
	}	
	
	\infer
%	[\proofRule{Expand/Contract}]
	{
		\left\{\interAss{[\token{A}]}{\bar x}{\lass{P}}{\lass{Q}} \right\} \;\approx^{\fenceAss{}}\;  \bigcup_{i \in I} \left\{\interAss{[\token{A}]}{\bar x}{\lass{P} * \lass{R}_i}{\lass{Q} * \lass{R}_i} \right\}	
	}
	{
		\fenceAss{} \sepish \lass{P} \slentails \bigvee_{i \in I} \fenceAss{} \sepish \left(\lass{P} * \lass{R}_i \right)
		&
		\exact{\lass{R}_i} \text{ for } i \in I
	}

	\infer
%	[\proofRule{Disj}]
	{
	  \bigcup\limits_{i \in I,j\in J}\!\! \left\{[\token{A}]\!:\!\exsts{\bar{x}} \lass{P}_i \!\swap\! \lass{Q}_j \right\}
	  \mathrel{\approx^{\m{true}}}
	  \left\{\![\token{A}]\!: \exsts{\bar{x}}
          \bigvee_{i \in I} \lass{P}_i \!\swap\!
          \bigvee_{j\in J}\lass{Q}_j \right\} 
	}
	{
	}

	\infer{
		\m{true} \fences I	
	}{}	

	\infer{
		\fenceAss{} \fences I
	}
	{
          \for{[\token{A}]: \exsts{\bar x}\lass{P} \swap \lass{Q}\in I}\fenceAss{} \fences \left\{[\token{A}]: \exsts{\bar x}\lass{P} \swap \lass{Q} \right\}
	}		

	\infer{
	  \fenceAss{} \fences \left\{\interAss{[\token{A}]}{\bar x}{\lass{P}}{\lass{Q}} \right\}
	}
	{
		\lass{P} \slentails \lass{P'} * \lass{R}\\
    \lass{Q} \slentails \lass{Q'} * \lass{R}\\
	  \exact{\lass{R}}\\
	  \fenceAss{} \!\fences\! \left\{[\token{A}]\!\!:\exsts{\bar x} \lass{P'} \swap \lass{Q'} \right\}
	}	

	\infer{
		\fenceAss{} \fences \left\{[\token{A}]\!\!:\exsts{\bar x} \action{\lass{P}}{\lass{Q}} \right\}	
	}
	{
		\separate{\fenceAss{}}{\lass{P}}
	}	
	
%	\infer{
%		\fenceAss{} \fences \left\{[\token{A}]: \lass{P} \swap \lass{Q} \right\}		
%	}
%	{
%		\fenceAss{} \sepish \lass{P} \slentails \m{false}
%	}
%	
	\infer{
		\fenceAss{} \fences \left\{\interAss{[\token{A}]}{\bar x}{\lass{P}}{\lass{Q}} \right\}		
	}
	{
		\separate{\lass{P}}{\lass{Q}}
		&
		\left(\lass{P} \septraction (\fenceAss{} \sepish \lass{P}) \right) * \lass{Q} \slentails \fenceAss{}
	}	
\end{mathpar}
\hrule
%\vspace*{5pt}
\caption{Selected action shifting rules; we write $I
  \approx^{\fenceAss{}} I'$ for $I \weakenI{\fenceAss{}} I' /| I'
  \weakenI{\fenceAss{}} I$,  and assume that variables in
  $\bar x$ do not appear free in $\lass{F}$.}
\label{fig:shifting-rules}
\end{figure}

The first three rules of \fig\ref{fig:shifting-rules} allow one to
check shifting piecewise: one may weaken the assertion $P$ into
a local assertion $\lass{F}$ which, if it \emph{fences} $I_1\cup I_2$, can be used to
reduce a shifting judgement $I \cup I_1 \weakenI{\fenceAss{}} I \cup
I_2$ to the simpler $I_1 \weakenI{\fenceAss{}} I_2$. 
The extra fencing condition $\lass{F}\fences I\cup I_1$ is necessary because
shifting means that the actions in $I\cup I_1$ and $I\cup I_2$
have the same effect on $\lass{F}$ after an arbitrary number of action
applications. In particular, this is the case when $\lass{F}\fences I\cup
I_1$, i.e.\ $\lass{F}$ is an \emph{invariant} of the shared region
under interferences in $I\cup I_1$, whereas $I_1 \weakenI{\fenceAss{}}
I_2$ only states that $I_1$ and $I_2$ are equivalent from the point of
view of $\lass{F}$.

The next two rules describe situations where an action is irrelevant
to a particular assertion $\lass{F}$: when the effect of the action is
entirely outside of $\lass{F}$, or when it is impossible to apply the
action to $\lass{F}$. The next rule is an equivalence that uses the
knowledge embodied by $\lass{F}$ of all the possible states that the
subjective shared state may be in to rewrite an action into an equivalent
one. More precisely, if whenever the precondition $\lass{P}$ of the
action is compatible with $\lass{F}$ then one of the $\lass{R}_i$'s is
also true, then it is safe to add $\lass{R}_i$ as a neutral part of
the action (the fact that $\lass{R}_i$ is exact guarantees that no
piece of state in $\lass{R}_i$ is mutated by the ``larger'' action)
without changing the set of states in which the action can be
applied. The last shifting equivalence is straightforward. Note that
$\m{true}$ fences any interference assertion.

To check whether an assertion $\lass{F}$ fences an interference assertion $I$, written
$\lass{F}\fences I$, the last three rules of the figure are similar to those for local
fencing and provide rules to apply to each action of $I$. 
\begin{enumerate}
\item
  As for local fencing, neutral parts in actions may be ignored.
\item
  Contrarily to local fencing, actions are allowed to have effects
  outside of the fence. If the action precondition does not intersect
  with the fence, then its effect is entirely outside the fence and
  the action may be ignored.
\item
  When $\lass{P}$ and $\lass{Q}$ do not intersect in an action
  $\lass{P}\swap \lass{Q}$ (e.g.\ when their common parts have
  been removed according to 1.), then the application of the action
  must preserve the fence $\lass{F}$. Because the action is allowed to
  act partly outside of $\lass{F}$, the state on which the action is
  applied is $\lass{F} ** \lass{P}$, unlike local fencing where
  $\lass{P}$ would be contained in $\lass{F}$. The reason why
  $\lass{P}$ and $\lass{Q}$ must not intersect is precisely that we
  consider the action on $\lass{F} ** \lass{P}$ and not just $\lass{F}$;
  if $\lass{P}$ and $\lass{Q}$ have a non-empty intersection $l$ then
  it might be that $l$ is not part of $\lass{F}$ and is added together
  with $\lass{Q}$ by $*$ on the left-hand side of the sequent. But
  there is no guarantee that $I$ accounts for all possible actions on
  that piece of state $l$ since it was not part of $\lass{F}$, hence
  we could end up with an assertion $\shared{\lass{F}}{I}$ that does
  not satisfy the action closure property.
\end{enumerate}





\paragraph{Stability}
\fig\ref{fig:stability-rules} presents rules to show that an assertion
of the form $\exsts{\bar x}\lass{P} * \bigstar_{i\in
  I}\shared{\lass{Q}_i}{I_i}$ is stable. This is a more restricted
form of assertions than our two previous axiomatisations, but a more
elaborate set of rules exists for the general case (see~\cite{colosl-tr14}).
%(see Appendix~\ref{sec:assertions-continued}). 
The
first two rules state that local assertions are always stable and
existentials can be eliminated. Then, checking the stability of
$\lass{P} * \bigstar_{i\in I}\shared{\lass{Q}_i}{I_i}$ boils down to
establishing, for each subjective view $\shared{\lass{Q}_i}{I_i}$, the
four-place $\mathsf{Stable}$ predicate which in this case means that
$\lass{Q}_i$ is stable under the interference assertion $I_i$, a local
context $\lass{P}$, and a shared context made of the $**$-combination
of all the subjective assertions (including $\lass{Q}_i$).  In turn,
checking this fact reduces to checking stability for each action of
$I_i$. The last three rules deal with checking stability for a single
action, in a similar way to fencing rules above.

\begin{figure*}
\hrule\vspace*{5pt}
\begin{mathpar}
	\infer{\stable{\lass{P}}}{ }
	
%	\infer{
%		\stable{P}	
%	}
%	{
%		\stable{\un{P}}	
%	}
%
	\infer{
		\stable{\exsts{x} P}
	}
	{
		\stable{P}
	}

	\infer{
	  \stable{\lass{P} * \bigstar_{j\in J}\shared{\lass{Q}_j}{I_j}}
	}
	{
          \for{j\in J}
	  \stable{\lass{Q}_j, I_j, \lass{P}, \bigocon_{j\in J} \lass{Q}_j}
	}

%	\infer{
%		\stable{\shared{\lass{P}}{I}}	
%	}
%	{
%		\lass{P} \fences I	
%	}	
%	
%	\infer[?]{
%		\stable{\shared{\lass{P}}{I}}	
%	}
%	{
%		\stable{\shared{\lass{P}}{I'}} 
%		&
%		I' \weakenI{\lass{P}} I
%	}
%	
%	

	\infer{
	  \stable{\lass{Q},I,\lass{P},\lass{R}}
	}
	{
    \for{\interAss{[\token{A}]}{\bar{x}}{\lass{P_1}}{\lass{P}_2} \in I}
          \stable{\lass{Q},\{\interAss{[\token{A}]}{\bar{x}}{\lass{P_1}}{\lass{P}_2} \},\lass{P},\lass{R}}
	}	
	
	\infer{
	  \stable{\lass{Q},\{\interAss{[\token{A}]}{\bar{x}}{\lass{P}_1}{\lass{P}_2}\},\lass{P},\lass{R}}
	}
	{
	  [\token{A}] * \lass{P} * \lass{R} \slentails \m{false}
	}

	\infer{
	  \stable{\lass{Q},\{\interAss{[\token{A}]}{\bar{x}}{\lass{P}_1}{\lass{P}_2} \},\lass{P},\lass{R}}
	}
	{
	  \lass{P} * (\lass{R} ** \lass{P}_1) \slentails \m{false}
	}
	
	
	\infer{
	  \stable{\lass{Q},\{\interAss{[\token{A}]}{\bar{x}}{\lass{P}_1}{\lass{P}_2} \},\lass{P},\lass{R}}
	}
	{
	  \left(\lass{P}_1 \septraction (\lass{P} * (\lass{R} ** \lass{P}_1)\right) * \lass{P}_2 \slentails \lass{Q} * \m{true}
	}
\end{mathpar}
\hrule
%\vspace*{5pt}
\caption{Rules for checking stability (excerpt).
 We assume that variables in
  $\bar x$ do not appear free in $\lass{P}$, $\lass{Q}$, and $\lass{R}$.}
\label{fig:stability-rules}
\end{figure*}

The first of these is new: unlike fencing, stability only has to be
checked against actions for which the environment may hold enough
capabilities. If the capabilities required by the action cannot exist
separately from those held by the whole formula, which may be summed
up by $\lass{P} * \lass{R}$, then the environment cannot perform the
action. Similarly, an action whose precondition is incompatible with
the current knowledge about the state cannot possibly fire. This is
what the premise of the next rule expresses: the local context is
composed (using $*$) with the shared context, itself overlapped with the precondition
of the action, since that precondition must hold somewhere in the
shared state, separately from any private state (but possibly
partially outside of the current combined subjective view of the
shared state). The last rule checks that a particular subjective
assertion $\lass{Q}$ is preserved by the effect of an action. Again,
there is a crucial difference with the corresponding check for
fencing: the action is applied to the whole state, but part of the
result can be discarded to re-establish $\lass{Q}$.



\paragraph{Proof reuse}
Finally, we note that, once a strict fencing judgement
$F\strictfences I$ has been established, it automatically
establishes a fencing judgement $F\fences I$, and in turn
$F\fences I$ implies that $F$ is stable under
$I$. The other directions are not valid in general: stability of $P$
under $I$ may omit part of the state resulting from an action
application to re-establish $P$, which is not allowed in fencing, and
fencing lacks the confinement condition required by local
fencing. Additionally, a fence $F$ for an interference
assertion $I$ is also a fence for any $I'$ that is a shifting of $I$ under
$F$.
  \vspace{-10pt}
\begin{mathpar}
  \vspace{-10pt}
	\infer{
		F \fences I	
	}{
		F \strictfences I	
	}

	\infer{
  	\stable{\shared{P}{I}}
	}{
	  P \fences I	
	}

	\infer={
		F \fences I
	}
	{
		F \fences I'
		&
		I' \weakenI{F} I	
	}
\end{mathpar}
	
%% ALSO I REMOVED THESE ONES
	
	%% \infer{
	%% 	I \cup I_1 \entailsI I \cup I_2
	%% }
	%% {
	%% 	I_1 \entailsI I_2
	%% }	
	
	%% \infer{
	%% 	\left\{ \interAss{[\token{A}]}{\bar{y}}{P}{Q} \right\}	
	%% 	\entailsI
	%% 	\left\{ \interAss{[\token{A}]}{\bar{y}}{\sumA{P}}{\sumA{Q}} \right\}	
	%% }{}
		
	%% \infer{
	%% 	\left\{ \interAss{[\token{A}]}{\bar{y}}{P}{Q} \right\}	
	%% 	\entailsI
	%% 	\left\{ \interAss{[\token{A}]}{\bar{y}}{P'}{Q'} \right\}	
	%% }
	%% {
	%% 	P \entails\! P'
	%% 	&
	%% 	Q \entails Q'	
	%% }
	
	%% \infer{
	%% 	\fenceAss{} \fences I
	%% }
	%% {
	%% 	I \entailsI I' 
	%% 	&
	%% 	\fenceAss{} \fences I'
	%% }

	%% \infer{
	%% 	I  \weakenI{\fenceAss{}} \emptyset
	%% }
	%% {
	%% 	I  \entailsI I'
	%% 	&
	%% 	I' \weakenI{\fenceAss{}} \emptyset
	%% }
%	
%	\infer{
%		I \cup I' \weakenI{\fenceAss{}} I
%	}
%	{
%		I \cup I' \entailsI I''
%		&
%		I'' \weakenI{\fenceAss{}} I
%	}
%		
%	\infer{
%		\left\{ [\token{A}]: P \swap Q \right\} \weakenI{\fenceAss{}} I'
%	}
%	{
%		\left\{ [\token{A}]: \erase{P} \swap \erase{Q} \right\} \weakenI{\fenceAss{}} I'
%	}
		
%% 	\infer
%% %	[\proofRule{Exist}]
%% 	{
%% 		\left\{[\token{A}]: \exists\overline{v_i \in S_i}^{i \in I}.\, P \swap Q \right\} 
%% 		\approx^{\m{true}}
%% 		\bigcup\limits_{\overline{w_i \in S_i}^{i \in I}} \left\{[\token{A}]: P \overline{[w_i /v_i]}^{i \in I} \swap  Q \overline{[w_i /v_i]}^{i \in I} \right\} 
%% 	}
%% 	{
%% 	}	


	%% \infer{
	%% 	\stable{P \odot Q}	
	%% }
	%% {
	%% 	\stable{P}
	%% 	&
	%% 	\stable{Q}	
	%% }

	%% \infer{
	%% 	\stable{P * Q}	
	%% }
	%% {
	%% 	\stableTo{P}{Q}
	%% 	&
	%% 	\stableTo{Q}{P}	
	%% }

	%% \infer{
	%% 	\stableTo{P}{R}	
	%% }
	%% {
	%% 	\stable{P}
	%% }	

	%% \infer{
	%% 	\stableTo{P * Q}{R}
	%% }
	%% {
	%% 	\stableTo{P}{Q * R}
	%% 	&
	%% 	\stableTo{Q}{P * R}
	%% }	
	
	%% \infer{
	%% 	\stableTo{P}{R * R'}
	%% }
	%% {
	%% 	\stableTo{P}{R}
	%% }	
		
	%% \infer{
	%% 	\stableTo{P \ominus Q}{R}
	%% }
	%% {
	%% 	\stableTo{P}{R}
	%% 	&
	%% 	\stableTo{Q}{R}
	%% }	
	
	%% \infer{
	%% 	\stableTo{\exsts{x} P}{R}
	%% }
	%% {
	%% 	\stableTo{P}{R}
	%% }
	
	%% \infer{
	%% 	\stableTo{\shared{\lass{P}}{I}}{R}
	%% }
	%% {
	%% 	\stableTo{\shared{\lass{P}}{I'}}{R}
	%% 	&
	%% 	I' \weakenI{\lass{P}} I
	%% }
	
	
	%% \infer{
	%% 	\stableTo{\shared{\lass{P}}{I}}{R}
	%% }
	%% {
	%% 	\stableIn{\lass{P}}{I}{R * \shared{\lass{P}}{I}}
	%% }

	%% \infer{
	%% 	\stableIn{\lass{P}}{\left\{\interAss{[\token{A}]}{\bar{y}}{Q_1}{Q_2}\right\}}{R}	
	%% }
	%% {
	%% 	\stableIn{\lass{P}}{\left\{\interAss{[\token{A}]}{\bar{y}}{\sumA{Q_1}}{\sumA{Q_2}}\right\}}{R}	
	%% }	
	
	%% \infer{
	%% 	\stableIn{\lass{P}}{\left\{\interAss{[\token{A}]}{\bar{y}}{Q_1}{Q_2}\right\}}{R}	
	%% }
	%% {
	%% 	Q_1 \entails Q'_1
	%% 	&
	%% 	Q_2 \entails Q'_2
	%% 	&
	%% 	\stableIn{\lass{P}}{\left\{\interAss{[\token{A}]}{\bar{y}}{Q'_1}{Q'_2}\right\}}{R}	
	%% }
	
	%% \infer{
	%% 	\stableIn{\lass{P}}{\left\{\interAss{[\token{A}]}{\bar{y}}{\lass{Q}_1}{\lass{Q}_2}\right\}}{R}	
	%% }
	%% {
	%% 	[\token{A}] * \prodA{R} \slentails \m{false}
	%% }
	
	
	%% \infer{
	%% 	\stableIn{\lass{P}}{\left\{[\token{A}]: \lass{Q}_1 \swap \lass{Q}_2 \right\}} {R}	
	%% }
	%% {
	%% 	\combine{R}{\lass{Q}_1} \slentails \m{false}
	%% }
	
	
	%% \infer{
	%% 	\stableIn{\lass{P}}{\left\{[\token{A}]: \lass{Q}_1 \swap \lass{Q}_2 \right\}}{R}	
	%% }
	%% {
	%% 	\left(\lass{Q}_1 \septraction \combine{R}{\lass{Q}_1} \,\right) * \lass{Q}_2 \slentails \lass{P} * \m{true}
	%% }

\subsection{Soundness}

Soundness of \colosl has been established parametrically in the
underlying models of machine states ($\Heaps$ ) and capabilities ($\Caps$), as an instance of the Views framework~\cite{views}. The
details can be found in the accompanying technical
report~\cite{colosl-tr14}. The main part of the proof is to establish
the soundness of the following rule for atomic commands, where
$\entails_{\textsf{SL}}$ represents standard sequential separation
logic:
\[
\infer[\proofRule{Atom}]{
  \hoare{P}{\atomic {\mathbb{C}}}{Q}
}{
  \entails_{\textsf{SL}} \{\lass{P}\}\;{\mathbb{C}}\;\{\lass{Q}\} &
  \repartitions{P}{Q}{\lass{P}}{\lass{Q}}
}
\]

The \emph{repartitioning} $\repartitions{P}{Q}{\lass{P}}{\lass{Q}}$
holds whenever, from any world $(l,g,\lmod)$ satisfying $P$, if
whenever a part of the composition of its local and shared states that
satisfies $\lass{P}$ is exchanged for one satisfying $\lass{Q}$, there
is $\lmod'$ and a splitting of the resulting logical state into a
local $l'$ and shared part $g'$ such that $(l',g',\lmod')$ satisfies
$Q$. Moreover, going from $(l,g,\lmod)$ to $(l',g',\lmod')$ can be
achieved via a succession of 1) updates in accordance with $\lmod$; and 2)
valid extension steps . A similar semantic
condition for atomic commands is required in the frameworks from the
CAP family~\cite{cap-ecoop10,icap,tada}. Formal definitions can be
found in~\cite{colosl-tr14}. 
%Appendix\ref{sec:semantics}.

Semantic validity of Hoare triples depends on the definition of an
operational semantics $\mathbb{C}, m \rightarrow^{\text{*}}
\mathbb{C}', m'$, where $m, m' \in \Heaps$. We first define a
reification function that relates a \colosl world $w \in \Worlds$ to
a concrete state in \Heaps.

\begin{definition}[Reification]\label{def:reification}
  The \emph{reification}, $\reifyW{.}: \Worlds \rightarrow \Heaps$ is
  defined as:
  \[
  \reifyW{(l, g, \lmod)} \eqdef \heapPart{(l \composeL g)}
  \]
\end{definition}

\begin{definition}[Valid triple]
  A triple is \emph{valid}, written $|= \{P\}\ \mathbb{C}\ \{Q\}$, iff for all $\lenv \in \LEnv$, $w \in  \Worlds$ and  $\h{}, \h{}' \in \Heaps$,
  \vspace{-10pt}
  \[
    \left(w, \lenv |= P  \land \mathbb{C}, \reifyW{w} \rightarrow^{\text{*}} \li{skip}, \h{}'\right)
    \text{ implies } \exsts{w'} w', \lenv |= Q \land \h{}' = \reifyW{w'}
  \]
\end{definition}

\begin{theorem}[Soundness]
  If $|-\!\{P\}\ \mathbb{C}\ \{Q\}$ then $|=\!\{P\}\ \mathbb{C}\ \{Q\}$.
\end{theorem}
