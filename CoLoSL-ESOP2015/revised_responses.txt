We thank the reviewers for their time and feedback. We would like to
address the comments and questions raised by the reviewers.

## Reviewers 2 and 3 comment on the complexity of CoLoSL.

Crucially, it is that it is also possible to give "simple" global
proofs to programs in CoLoSL. For instance, the global proof of INC
would carry all three variables across all three threads, and then
many of the complications about using Shift, Forget, and Merge go
away. We took the harder road of fully local specs and proofs to
demonstrate the power of CoLoSL with respect to local reasoning.

Local reasoning is more difficult to achieve than global proofs, but
provides compositional reasoning. We hope to follow the same path as
sequential separation logic, which improved on Hoare logic by
providing a way to frame off unnecessary resource, thus enabling local
specifications of programs, and eventually scaling to large
programs. CoLoSL provides, for the first time, arbitrary framing
inside the shared state and inside interference relations in what we
believe is the most fined-grained manner possible. Framing inside
shared regions is only possible in very limited ways, if at all, in
existing logics.

The benefits of compositional reasoning are manifest when several
program proofs are put together. When verifying a large (100,000+
lines of code) system, distinct portions of the code will care about
different sets of shared data structures. Moreover, these data
structures can overlap, for instance the sub-graphs of a larger graph
(as in the spanning tree example), or even collections of discrete
memory cells (as in INC). In existing work, the verification often has
to resort to being non-compositional and verify all procedures with
the whole shared state. Worse, this shared state can only be found by
analysing the whole code. Clearly the proof burden becomes
unmanageable at scale. While we have not yet verified such large
systems, we believe that we have laid solid foundations to make this
goal attainable, and have demonstrated how to attack this general
problem on simpler examples.

Moreover, as noted by all reviewers, this flexible approach already
yields benefit for the examples of our paper, where we are able to
give either more concise proofs (INC and Set), or novel proofs that
hadn't been done before (concurrent spanning tree).

Finally, we believe that a lot of the perceived complexity of CoLoSL
can be attributed to the difficulty associated with reasoning about
fine-grained concurrent programs as is the case in existing logics
such as CAP, etc. We have introduced new reasoning principles such as
SHIFT and EXTEND, which we believe are conceptually natural but we do
agree are difficult to describe formally. We have tried to minimise
the complexity of proof obligations by reducing them to separation
logic entailments.

We will concentrate on improving this exposition for future versions.


## Reviewer 2 highlights three more questions.

1) “Can something similar be done for the proof of Sec 4.1?”. 

We do not know how to do the concurrent spanning tree in e.g. CAP, so
cannot make an analogous strong comparison as with the set example. We
did try.  It probably is possible to do something with CAP. However,
our initial explorations show that this would be very complicated,
since none of the existing approaches allow for arbitrary unknown
sharing (overlaps) over concurrently accessed resources (as is the
case in the graph algorithm).

Surprisingly, our proof of the concurrent spanning tree example is
simpler than the sequential spanning tree example of [10] (partly, but
not only, because we do not prove functional correctness); indeed, the
reviewer points out that `even sequential proofs about graph
algorithms are rather tricky'. We can make this comparison clearer.

2) “The introduction mentions `modularity of specifications’… ?”

We hope our general comment above addresses this concern.

3) “The model that gives semantics to Colosl is abstract … ?”

There has been some confusion. The concrete model is the standard
heap and the concurrent operational semantics is the one used in
Views [5]. Views provides a general soundness result (a real-world
safety property) based on some initial parameters (including a
reification function that relates abstract logical states to concrete
machine states) and some lemmas. We give these parameters and prove
these lemmas, thus obtaining a real-world safety property from
Theorem 1 in [16]. We will clarify this point in future versions.


## Reviewer 3 asks about automation prospects.

As for the case of verifying large code-bases, we believe our work
lays some solid foundations for automation. Our semantic conditions
are already reducible to separation logic entailment checks. However,
these entailments involve reasoning about \*/ and --(*), which are not
always part of automatic tools for reasoning about separation logic
optimism. Moreover, we have obtained encouraging preliminary results
about reducing entailments with \*/ and --(*) to entailments without
these connectives, in the style of how RGSep eliminates
--(*). Finally, because CoLoSL reasoning is compositional, we believe
it is a solid theoretical starting points for tools attacking
concurrent programs. These are interesting research directions for
future work indeed, as very few automatic tools exist to verify
concurrent programs of any size at all!


## Reviewer 1 comments about related work and technical points.

Allow us to answer them here for completeness.

We will expand our related work section to compare CoLoSL with [20]
and other style of logics that use transition systems [Nanevski et al,
ESOP'14]. Our arguments in favour of the strengths and novelty of
CoLoSL in comparison to CAP (and its variants) apply to [20, Nanevski
et al, ESOP’14] as well and we believe that our insights about proof
structure can be carried over to these logics too, although the
precise mechanism as to how is a matter for future work as of now.

The soundness of the EXTEND principle is indeed achieved by the
fencing constraint relating P to I. We will take the reviewer’s advice
and explain this more clearly. We will also elaborate on the intuitive
meaning of both fencing judgements (white and shaded triangles) and
compare them. We will expand the lock-coupling example section by
promoting some of the detailed proofs and description available in the
appendix to the main text.

>>>> “Fig 1: shouldn’t you have some restrictions on A and A’? ...”

In the case of sets of tokens, no further restrictions are needed. In
general, there is a requirement that A and A' can always be picked
"fresh" w.r.t. pre-existing capabilities. This is detailed in the
technical report [16].

>>>> ”AMod seems to map sets of tokens to sets of actions...” 

The INC example features the a_rem action, which requires all three
tokens {a_x, a_y, a_z} at once. At a higher level, the reason why we
consider sets of tokens is because this generalises to other
capability domains easily.


>>>> “Section 4.1. Why do you need  the global graph predicate at all? ...”

The local predicate is indeed sufficient for the proof. We presented
the global predicate to demonstrate that it is possible to derive a
local specification from the global one using the CoLoSL principles.


>>>>  “Fig 6: should you have a usual star in between (U \/ M) and G(l, gamma) in G(x, gamma)? ”

No, since graphs allow loops/cycles, G(x, gamma) and its left subgraph
G(l, gamma) may overlap. For instance, in the graph of Fig 6a. had we
used * rather than \*/ we would have

  G(y, gamma) = y |-> - ... * G(y, gamma) * G(z, gamma) = false

and thus

  graph(x, gamma) = \box{... * false} = false

This is no longer the problem in the local definition g(x, gamma)
since the star separated subgraphs (g(x, gamma) and g(l, gamma)) are
boxed assertions. Similar to above, we would have:

  g(y, gamma) = \box{y |-> - ... * g(y, gamma) * g(z, gamma)} = 
  \box{y |-> - …} * \box{g(y, gamma)} * \box{g(z, gamma)} =>
  \box{y |-> … \*/ g(y, gamma) \*/ g(z, gamma)} =>
  \box{y -> … \*/ g(z, gamma)}

In a nutshell, the contents of *-separated boxed assertions may
overlap since by the (MERGE) principle

  \box{P}_I * \box{Q}_I' =>  \box{P \*/ Q}_{I \cup I'} 

But *-separated unboxed assertions amount to false when overlapping
(as in ordinary separation logic): y |-> - * y |-> - => false.
