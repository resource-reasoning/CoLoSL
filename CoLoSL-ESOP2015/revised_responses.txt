We thank the reviewers for their time and feedback. We'd like to address the comments and questions raised by the reviewers in turn. We will start with reviewers 2 and 3.


+++++++ Reviewer 2 Comments +++++++


>>>> "However I am skeptical about the overall approach. On the one hand..."


We believe that the reviewer’s skepticism is twofold:


---- Contribution ----


Our main contribution is to provide a flexible framing mechanism on the local resource, the shared resource and the interference on that shared resource.  
In the same way that (sequential) separation logic improved on Hoare logic by providing a way to frame off unnecessary resource, recent concurrent program logics such as CAP (and its variants) provided a framing mechanism on both local and shared resources.
While the CAP framing mechanism is fully flexible on the local resource, it is restrictive on the shared resource: one can frame off whole regions at a time but not arbitrary parts of each region. This notion of framing is rather static in that it forces one to predetermine the regions before the reasoning has started. As reviewer 1 points out, this results in awkward proofs as in the CAP proof of the set example (section 4.2). 
On the other hand, in CoLoSL one can frame off **arbitrary (overlapping) parts of the shared resource**.
Moreover, none of the existing logics provide a way for framing off parts of the interference or rewriting its actions whereas in CoLoSL one can **frame off/rewrite parts of the interference**. Framing off irrelevant actions simplifies the stability checks; rewriting actions allows one to combine the knowledge of global invariants with actions and thus obtain a stronger subjective views.


---- Complexity ----
We refer the reviewer to the response to reviewer 3 where we elaborate on the complexity of CoLoSL. 


+++++++ Reviewer 2 Questions +++++++


The reviewer highlights three questions.

1) “Can something similar be done for the proof of Sec 4.1?”. 

We do not know how to do the concurrent spanning tree in e.g.  CAP, so cannot make an analogous strong comparison as with the set example. We did try.  It probably is possible to do something with CAP. However, our initial explorations show that this would be very complicated, since none of the existing approaches allow for arbitrary unknown sharing (overlaps) over concurrently accessed resources (as is the case in the graph algorithm).
Our concurrent spanning tree example is much simpler than the sequential spanning tree example of [10]; indeed, the reviewer points out that `even sequential proofs about graph algorithms are rather tricky'. We can make this comparison clearer.

2) We do demonstrate the modularity of specifications and proof reuse
through our examples. 

In CoLoSL, it is possible to localise the assertions and proofs by means of shrinking/expanding subjective views to closely match the footprint of the algorithms and the intuition of the programmer. For instance, in the concurrent spanning tree example (section 4.1), we localise the footprint of span(x) to g(x, gamma) and **re-use** the same specification at the recursive call points. Such re-use of reasoning is natural for recursive functions. Such reasoning is possible with CoLoSL, due to the flexible framing for the dynamic overlapping shared resource. Such reasoning is not possible with e.g. CAP, due to the limited framing for the pre-determined static shared regions.
With the INC example of section 2, consider the general case of n threads and variables x_1, ..., x_n in the token ring. With CoLoSL, the assertion of a subjective view (the pre-condition) of thread i can be localised to the variables x_i and x_(i-1). The interference of the subjective view can be localised to the variables x_i, x_(i-1) and x_(i-2): the interference of the thread just uses x_i and x_(i-1); the interference of the environment requires the x_(i-2). With this localised view of the thread, stability checks are much simpler. Moreover, reasoning about the thread is independent of the value of  n. 

In contrast, with existing approaches (e.g.  CAP), the assertions and interference associated with each thread depends on all the n variables, and the specifications must be parameterised by this n. Proving a CAP specification for all values of n is possible. However, the CoLoSL approach is more modular in that it is independent of the value of n.


3) There has been some confusion. The concrete model is the standard heap and the concurrent operational semantics is the one used in [5]. The Views framework [5] provides a general soundness result (a real-world safety property) based on some initial parameters
(including a reification function that relates abstract logical states to concrete machine states) and some lemmas. We give these parameters and prove these lemmas, thus obtaining a real-world safety property from theorem 1. We will clarify this point in the final version. 

+++++++ Reviewer 3 Comments +++++++


>>>> "Points against ..." 


Reasoning about fine-grained concurrency is complicated! CAP was introduced in 2010, and has been significantly simplified over the years.  We have demonstrated that CoLoSL reasoning is more modular than CAP reasoning, with flexible framing throughout the
shared resource (see the response to reviewer 2 under contribution).  We have introduced new reasoning principles such as SHIFT and EXTEND, which we believe are conceptually natural but we do agree are difficult to describe formally. We have tried to minimise
the complexity of proof obligations by reducing them to separation-logic entailments. We will concentrate on improving this exposition for the final draft. As with CAP, we hope that CoLoSL will simplify over the years.

We are using INC as an introductory example to explain CoLoSL. The proof steps provide a storytelling mechanism to showcase the CoLoSL principles. We could have just given the natural local specifications for each thread, and then shown that it had the appropriate global
specification, forgoing the proof steps in the middle.



+++++++ Reviewer 1 Main Comments +++++++


We will expand our related work section to compare CoLoSL with [20] and other style of logics that use transition systems [Nanevski et al, ESOP'14]. Our arguments in favour of the strengths and novelty of CoLoSL in comparison to CAP (and its variants) apply to [20, Nanevski et al, ESOP’14] as well and we believe that our insights about proof structure can be carried over to these logics too. 
The soundness of the Extend principle is indeed achieved by the fencing constraint relating P to I. We will take the reviewer’s advice and explain this more clearly. We will also elaborate on the intuitive meaning of both fencing judgements (white and shaded triangles) and compare them. We will expand the lock-coupling example section by promoting some of the detailed proofs and description available in the appendix to the main text. 


+++++++ Reviewer 1 Questions +++++++


>>>> “Fig 1: shouldn’t you have some restrictions on A and A’? ...”


The only restriction necessary on A and A' is that they are **fresh** with respect to the already existing capabilities.  In our exposition the capabilities are represented as finite token sets K = \powerset_fin(token), and we assume an infinite number of tokens (think of tokens as natural numbers). Thus K itself is infinite and we can therefore always guarantee the existence of **some** fresh token sets A and A'. This is reflected by the existential quantification of A and A'.


>>>> ”AMod seems to map sets of tokens to sets of actions...” 


Indeed in our examples we only ever use single token sets. The reason for sets of tokens was to allow a larger number of actions being expressed through fewer tokens since for an action to be possible the thread must hold **all** the  capabilities in the set. For instance, given 3 tokens S = {a, b, c}, using tokens as the domain of AMod it is possible to describe 3 distinct actions. On the other hand, with token sets as the domain of AMod we can group them in 8 different ways (the size of \pset(S)). This is indeed a trivial difference and we are willing to take the reviewer's suggestion for clarity.


>>>> “Section 4.1. Why do you need  the global graph predicate at all? ...”


The local predicate is indeed sufficient for the proof. We presented the global predicate to demonstrate that it is possible to derive a local specification from the global one using the CoLoSL principles. 


>>>>  “Fig 6: should you have a usual star in between (U \/ M) and G(l, gamma) in G(x, gamma)? ”


No, since graphs allow loops/cycles, G(x, gamma) and its left subgraph G(l, gamma) may overlap. For instance, in the graph of Fig 6a. had we used * rather than \*/ we would have 


G(y, gamma) = y |-> - ... * G(y, gamma) * G(z, gamma) = false


and thus


graph(x, gamma) = \box{... * false} = false


This is no longer the problem in the local definition g(x, gamma) since the star separated subgraphs (g(x, gamma) and g(l, gamma)) are boxed assertions. Similar to above, we would have:


g(y, gamma) = \box{y |-> - ... * g(y, gamma) * g(z, gamma)} = 
 \box{y |-> - …} * \box{g(y, gamma)} * \box{g(z, gamma)} =>
\box{y |-> … \*/ g(y, gamma) \*/ g(z, gamma)} =>
\box{y -> … \*/ g(z, gamma)}


In a nutshell, the contents of *-separated boxed assertions may overlap since by the (MERGE) principle


\box{P}_I * \box{Q}_I' =>  \box{P \*/ Q}_{I \cup I'} 


But *-separated unboxed assertions amount to false when overlapping (as in ordinary separation logic): P * P => false (when P =/=> emp)