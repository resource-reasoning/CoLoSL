\section{Introduction}
\label{sec:introduction}

%\pg{This is what we should answer by the introduction: 
%What's the problem with the current state of the art?
%What is our solution?
%Why is the problem we're solving hard?
%How do we solve the challenges?
%Why do we do better than existing work?
%What are the lessons learnt from the paper?}

A key difficulty in verifying properties of shared-memory concurrent
programs is to be able to reason compositionally about each thread in
isolation, even though in reality the correctness of the whole system
is the collaborative result of intricately intertwined actions of the
threads. Such compositional reasoning is essential for verifying large
concurrent systems since it allows them to be verified component-wise
(usually the level of granularity is that of functions), library code
and incomplete programs since it avoids the need to know about the
context of execution and the precise implementation of functions
called in the code, and for replicating a programmer's intuition about
why their implementations are correct since informal arguments are
usually made at a local level without having to remember the details
of the whole system.

In the sequential case, separation logic~\cite{rey02,seplog} famously
achieves compositional reasoning for heap-manipulating
programs. Compositionality rests on two powerful mechanisms: a
function can be specified using only those resources that it actually
accesses (its \emph{footprint}), and this specification can be reused
in any context that merely contains these resources. This is embodied
by the following \emph{frame rule}%
% between Hoare triples, from separation logic
:
\[
\infer[\frameRule]{\hoare{P * R}{\mathbb{C}}{Q * R}}
{\hoare{P}{\mathbb{C}}{Q}}
\]
The $*$ connective between assertions means that they
describe \emph{disjoint} sets of resources. By making the
specification $\hoare{P}{\mathbb{C}}{Q}$ as tight as possible, we can
ensure that it can be reused in a large set of possible contexts via
the frame rule. Spec reuse is paramount to achieve compositional
reasoning: if the spec of a piece of code can be reused in any valid
context, one only has to prove this spec once and for all. In
non-compositional approaches, one very often needs to reprove the
piece of code itself under different specifications.

For shared-memory concurrency, rely-guarantee~\cite{rg} and proof
techniques that combine rely-guarantee and separation logic
principles~\cite{viktor-marriage,dg,lrg,cap-ecoop10,icap,tada} have
been proposed to gain compositionality in the face of the added
difficulty of inter-thread interaction. Unfortunately, none of these
approaches are fully compositional. In particular, despite continuous
successive improvements, the following three interconnected problems
remain open.

First and foremost, the region of memory shared by the threads is
described in a spatially coarse-grained fashion, usually comprising
the entirety of the shared state regardless of how much of it is
actually accessed by individual threads or individual functions within
these threads. Thus, a crucial ingredient of compositionality is
missing: one cannot give small specifications to programs manipulating
shared data, nor can one use the frame rule inside the shared
state. Some formalisms can mitigate this issue, most notably
concurrent abstract predicates (CAP)~\cite{cap-ecoop10} and local
rely-guarantee (LRG)~\cite{lrg}, but only when a subset of threads
manipulate resource that is entirely disjoint from their context, or
when the shared state is composed of entirely disjoint pieces with no
common action. For instance, if threads need to access two successive
nodes in a linked list, then no such splitting is possible as each
cell of the linked list will be shared between two neighbouring
threads, hence the shared state must contain the entire linked
list. Similarly, one cannot reason about subgraphs of a shared graph
in isolation due to arbitrary sharing between them.

Second, when a shared region is created, provision has to be made for
all future extensions of it. It is generally not possible to
arbitrarily grow it with extra state under new interference rules.
TODO: Set example.

Finally, the description of the interference on a shared region is
fixed for the entire lifetime of the region. Even if some actions
become irrelevant due to the resource they act on having been
deallocated or to extra knowledge gained about the state that
falsifies their requirements, they have to be kept around. This incurs
a burden in the proof effort, as stability against these irrelevant
actions still has to be checked at every point.


\julescomment{Need to write something here to insist that
compositionality rules all. Not sure whether to use the paragraph
below or not.}

suppose the code you want to prove uses one library for which you have
a spec, then you need to adapt to that spec because the shared state
has to match the scope of the spec of the library.  Now if you have
two libraries used by your code, the scope of their specs will in all
probability not match, and you cannot use existing program logics
(except LRG in some cases).


This paper introduces the program logic \colosl, for Concurrent Local
Subjective Logic, which addresses all three issues. \colosl models
shared resources as a single state, with a twist: the assertion
language allows threads to hold their own \emph{subjective views} of
this state. Each subjective (personalised) view is an assertion which
provides a thread-specific description of \emph{parts} of the shared
state. It describes the partial shared resources necessary for the
thread to run and the thread-specific interference describing how the
thread and the environment may affect these shared
resources. Subjective views expand and contract to the natural
resources and the interference required by the current
thread. Moreover, the subjective views of different threads represent
potentially \emph{overlapping} parts of the shared state, in contrast
with previous approaches that either mandate that all threads view the
same entire shared state, or strictly disjoint parts of
it. Nevertheless, we provide a framing mechanism both on shared
resources as well as their interferences even in the presence of
overlapping footprints and entangled resources.  This flexibility
provides truly compositional reasoning for shared-memory concurrency.

Contribs?
\begin{itemize}
\item
  small specs for shared state,
  arbitrary extension of the share state,
  rewriting of interference relations
\item
  examples
\item
  using \colosl: proof rules to discharge \colosl-specific proof
  obligations and turn them into regular SL validity checks.
\end{itemize}


%This paper presents the program logic \colosl, which achieves
%compositional reasoning for concurrent programs by enabling
%\emph{subjective} views of the shared state. Subjective views may be
%composed arbitrarily and manipulated so as to retain only the portions
%of local and shared state actually accessed by each thread in the
%program, and to consider only the interferences relevant to that piece
%of shared state. \colosl achieves a greater degree of compositionality
%than existing work by enabling \emph{finer-grained} sharing: the
%program logic can consider that threads share only what is relevant to
%their function, a key ingredient of compositionality.
%
%
%
%Driven by the ever-increasing need for concurrency in software,
%%  spurred by recent hardware developments, 
%program logics for shared-memory concurrency have progressed towards
%the twin ideals of fine-grain reasoning and compositionality. The
%former enables elegant proof techniques about increasingly subtle
%concurrency idioms~\cite{vv06popl,vv07msc,todo}, while the latter
%allows programs to be proved component-wise and their proofs to be
%reusable as-is in any client
%program~\cite{csl-tcs,cap-ecoop10,icap}.
%%  Central to these compositional verification frameworks is the
%% formalism used to describe both the state shared between program
%% threads and the possible interference on that state.
%%
%% dating back from Owicki~\cite{owicki}, and later Jones who
%% integrated the notion of interference in the logic
%% itself~\cite{rg}.
%% 
%
%% Consider for instance
%% a program where threads operate on subgraphs of a global graph.
%
%
%%  dubbed their \emph{subjective states}.  One may then reuse these
%%   specifications in the context of any larger local state (as is
%%   standard in separation logic~\cite{rey02}), and, crucially for
%%   compositional reasoning about concurrent programs, any larger
%%   shared state. The subjective states of different threads in a
%%   program are allowed to overlap arbitrarily, ensuring maximum
%%   reusability of proofs.
%
%
%
%
% Subjective views can expand or contract depending on the resources required by the thread, which has subtle consequences for the logical reasoning. In particular, it is possible to strengthen actions in $I$ to record  some global information known to the subjective view.
%Then, the view can be weakened to just the resources and possibly strengthened actions appropriate to  the thread. The strengthened actions retain  some global information despite the weakened view. 


\paragraph{Related work}
\colosl stems from a long lineage of program logics for shared-memory
concurrency, dating back to the Owicki-Gries logic~\cite{og}, each of
which made substantial advances in fine-grained compositional
reasoning about more and more complex concurrent programs. As noted by
Jones and motivating his definition of rely-guarantee~\cite{rg},
Owicki-Gries's system is fundamentally non-compositional as assertions
at each program point in each thread has to be checked against every
instruction of every other threads. While rely-guarantee addresses
this concern by summarising potential interferences in terms of rely
and guarantee conditions, its model of the shared state is global,
even encompassing the threads' private state. Later techniques
combined rely-guarantee with separation logic, starting with
RGSep~\cite{viktor-marriage}, which separates private (or local) and
shared state, allowing further compositionality. However, the view of
the shared state and interference on it is still globally-shared
across threads. The next breakthrough as far as compositionality is
concerned came from LRG~\cite{lrg}, wherein the shared state may be
split into completely independent pieces, thus partially solving the
first problem outlined above. This provides a way to frame off parts
of the shared state, but, as noted by its author, the strong
disjointness restrictions make this applicable only at the level of
disjoint modules in the code. Independently from LRG, the reasoning
framework of Concurrent Abstract Predicates (CAP)~\cite{cap-ecoop10}
and its extended variants~\cite{icap,tada} introduced the notion
of \emph{regions} of shared state. Much like LRG, the division into
regions is only possible for entirely disjoint pieces of state, with
fixed and disjoint interference relations.

TODO: rewrite a bit.
There are many interesting ideas present in the CAP literature:
e.g. abstract states~\cite{caresl}; higher-order
reasoning~\cite{icap}; and abstract atomicity~\cite{tada}. All these
ideas require further investigation. Here, our aim was to simply
introduce subjective views as a fundamental new way of underpinning of
such reasoning.

TODO: CareSL

TODO Turon et al.'s POPL'13 paper (which also espouses the idea of
using "local protocols" to govern individual pieces of a shared data
structure, albeit in a less rigorously enforced manner than in CoLoSL)

(and probably his ICFP paper as well)

\julescomment{The next paragraph about SCSL should be much shorter and to
the point.}

We conclude this section by noting that while \colosl enables
reasoning about \emph{fine-grained} concurrency, the logic of
subjective concurrent separation logic (SCSL)~\cite{SCSL} employs
auxiliary states to reason about \emph{coarse-grained}
concurrency. That is, although both techniques share the spirit
of \emph{subjectivity}, their applications are completely
orthogonal. As the authors note in~\cite{SCSL}, CAP (and by
design \colosl) can be employed to reason about their case studies of
coarse-grained concurrency. However, SCSL cannot be used to reason
about the fine-grained concurrency scenarios that \colosl tackles,
either when the resources are distributed disjointly amongst threads
or when they are intricately entangled.

\paragraph{Paper outline}
In \S\ref{sec:intuition}, we exhibit the main principles of \colosl
through a variant of Dijkstra's token-ring mutual exclusion
algorithm~\cite{dijkstra74}, which illustrates distributed, global
knowledge between threads. In this scenario, as well as the local
knowledge about how each thread behaves, the programmer also has
global knowledge about how threads constrain one another. Pleasantly,
our reasoning captures the spirit of local reasoning about individual
threads while retaining global knowledge about the overall
interactions between threads.
%It is a good  introductory example, as it uses all the highlighted \colosl\ reasoning principles in a fundamental way. 

\todo In \S\ref{sec:logic}, we interpret \colosl\ assertions over a particular domain which includes: thread-local state exclusively visible to the thread; {\em one} global shared state accessible by all thread (in contrast with the CAP approach); and {\em action models} describing how the global state can be updated. In \S\ref{sec:semantics}, we define the rely and guarantee conditions of each thread in terms of their action models, and provide a sketch of soundness. In particular, the reasoning principles highlighted above are simple semantic
consequences of our generic model of program states.  
%The full technical details can be found in the accompanying technical report~\cite{colosl-tr14}.

In \S\ref{sec:examples}, we study further, more challenging examples. We verify a concurrent spanning tree algorithm for graphs. This algorithm uses threads spawned on arbitrary overlapping graphs. We demonstrate that the flexible, overlapping subjective views of \colosl are just what we need.  We also verify a concurrent set module implemented using a hand-over-hand list-locking algorithm.
%
The flexibility of \colosl's subjective views leads to a considerably simpler correctness proof compared to that of CAP. 
%
Finally, we demonstrate how the mutual exclusion ring of \S\ref{sec:intuition} can be generalised to synchronise access to a concurrent database.
