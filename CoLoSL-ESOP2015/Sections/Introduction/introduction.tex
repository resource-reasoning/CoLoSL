\section{Introduction}
\label{sec:introduction}

%\pg{This is what we should answer by the introduction: 
%What's the problem with the current state of the art?
%What is our solution?
%Why is the problem we're solving hard?
%How do we solve the challenges?
%Why do we do better than existing work?
%What are the lessons learnt from the paper?}

A key difficulty in verifying properties of shared-memory concurrent
programs is to be able to reason compositionally about each thread in
isolation, even though in reality the correctness of the whole system
is the collaborative result of intricately intertwined actions of the
threads. Such compositional reasoning is essential for 1) verifying large
concurrent systems since it allows them to be verified component-wise
(usually the level of granularity is that of functions); 2) library code
and incomplete programs since it avoids the need to know about the
context of execution and the precise implementation of functions
called in the code; and 3) replicating a programmer's intuition about
why their implementations are correct since informal arguments are
usually made at a local level without having to remember the details
of the whole system.

In the sequential case, separation logic~\cite{rey02,seplog} famously
achieves compositional reasoning for heap-manipulating
programs. Compositionality rests on two powerful mechanisms: a
function can be specified using only those resources that it actually
accesses (its \emph{footprint}), and this specification can be reused
in any context that merely contains these resources. This is embodied
by the following \emph{frame rule}%
% between Hoare triples, from separation logic
:
\[
\infer[\frameRule]{\hoare{P * R}{\mathbb{C}}{Q * R}}
{\hoare{P}{\mathbb{C}}{Q}}
\]
The $*$ connective between assertions means that they
describe \emph{disjoint} sets of resources. By making the
specification $\hoare{P}{\mathbb{C}}{Q}$ as tight as possible, we can
ensure that it can be reused in a large set of possible contexts via
the frame rule. Specification reuse is paramount to achieve compositional
reasoning: if the specification of a piece of code can be reused in any valid
context, one only has to prove it once and for all. In
non-compositional approaches, one very often needs to reprove the
piece of code itself under different specifications.

For shared-memory concurrency, rely-guarantee~\cite{rg} and proof
techniques that combine rely-guarantee and separation logic
principles~\cite{viktor-marriage,dg,lrg,cap-ecoop10,icap,tada} have
been proposed to gain compositionality in the face of the added
difficulty of inter-thread interaction. Unfortunately, none of these
approaches are fully compositional. In particular, despite continuous
successive improvements, the following three interconnected problems
remain open.

First and foremost, the region of memory shared by the threads is
described in a spatially coarse-grained fashion, usually comprising
the entirety of the shared state regardless of how much of it is
actually accessed by individual threads or individual functions within
these threads. Thus, a crucial ingredient of compositionality is
missing: one cannot give small specifications to programs manipulating
shared data, nor can one use the frame rule inside the shared
state. Some formalisms can mitigate this issue, most notably
Concurrent Abstract Predicates (CAP)~\cite{cap-ecoop10} and Local
Rely-Guarantee reasoning (LRG)~\cite{lrg}, but only when a subset of threads
manipulate resources that are entirely disjoint from their context, or
when the shared state is divided into entirely disjoint regions with no
common actions. For instance, given a linked list of $n+1$ nodes accessed concurrently by $n$ threads (numbered $1, \cdots, n$) where the $i$th thread requires access to two successive nodes at indices $i-1$ and $n$, no such splitting is possible as each
node of the linked list will be shared between two neighbouring
threads, hence the shared state must contain the entire linked
list. Similarly, when data structures with intricate (unspecified) patterns of sharing are accessed concurrently, one cannot reason about subgraphs
\emph{in isolation} due to arbitrary sharing between them.

Second, the interference associated with each region is defined when it is created and cannot change. As such, upon its creation, provision has to be made for
all future extensions of it and it is generally not possible to
arbitrarily grow it with extra state under new interference rules.
As we discuss in \S\ref{sec:examples}, this results in unnatural specifications such as the concurrent set module example in~\cite{cap-ecoop10}. 

Finally, the description of the interference on the shared state is
fixed throughout its entire lifetime: even if a transition on the shared state 
becomes irrelevant (either because the resources it acts on have been
deallocated or extra knowledge gained about the shared state
falsifies their requirements), it still has to be kept around and accounted for. This incurs
a burden in the proof effort, as stability against these irrelevant
actions still has to be checked at every point.

The restrictions imposed on the ways in which the shared state can be decomposed and accessed by different threads (the first issue discussed above) not only affects the locality of reasoning, but also impedes \emph{modularity} and proof reuse. When the implementation of a module $M_1$ is verified against its specification, its proof can only be reused from within another module $M_2$, if either the parts of the shared state accessed by $M_2$ are disjoint from those of $M_1$; or the shared state is partitioned identically for both modules, i.e. for common parts of the shared state, they view the same region boundaries, with same contents and interference descriptions. While the former restriction heavily limits specification reuse, the latter is unnatural: the divisions imposed on the shared state are merely instrumental and are utilised to promote locality; it is unrealistic to expect different module specifications to view the same repartitioning of shared resources. 

This paper introduces the program logic \colosl, for Concurrent Local
Subjective Logic, which addresses all three issues. \colosl models
shared resources as a single state, with a twist: the assertion
language allows threads to hold their own \emph{subjective views} of
this state. Each subjective (personalised) view is an assertion which
provides a thread-specific description of \emph{parts} of the shared
state. It describes the partial shared resources necessary for the
thread to run and the thread-specific interference describing how the
thread and the environment may affect these shared
resources. Subjective views expand and contract to the natural
resources and the interference required by the current
thread. Moreover, the subjective views of different threads represent
potentially \emph{overlapping} parts of the shared state, in contrast
with previous approaches that either mandate that all threads view the
same entire shared state, or strictly disjoint parts of
it. Nevertheless, we provide a framing mechanism both on shared
resources as well as their interferences even in the presence of
overlapping footprints and entangled resources. This flexibility
provides truly compositional reasoning for shared-memory concurrency.

Contribs?
\begin{itemize}
\item
  small specs for shared state,
  arbitrary extension of the share state,
  rewriting of interference relations
\item
  examples
\item
  using \colosl: proof rules to discharge \colosl-specific proof
  obligations and turn them into regular SL validity checks.
\end{itemize}


%This paper presents the program logic \colosl, which achieves
%compositional reasoning for concurrent programs by enabling
%\emph{subjective} views of the shared state. Subjective views may be
%composed arbitrarily and manipulated so as to retain only the portions
%of local and shared state actually accessed by each thread in the
%program, and to consider only the interferences relevant to that piece
%of shared state. \colosl achieves a greater degree of compositionality
%than existing work by enabling \emph{finer-grained} sharing: the
%program logic can consider that threads share only what is relevant to
%their function, a key ingredient of compositionality.
%
%
%
%Driven by the ever-increasing need for concurrency in software,
%%  spurred by recent hardware developments, 
%program logics for shared-memory concurrency have progressed towards
%the twin ideals of fine-grain reasoning and compositionality. The
%former enables elegant proof techniques about increasingly subtle
%concurrency idioms~\cite{vv06popl,vv07msc,todo}, while the latter
%allows programs to be proved component-wise and their proofs to be
%reusable as-is in any client
%program~\cite{csl-tcs,cap-ecoop10,icap}.
%%  Central to these compositional verification frameworks is the
%% formalism used to describe both the state shared between program
%% threads and the possible interference on that state.
%%
%% dating back from Owicki~\cite{owicki}, and later Jones who
%% integrated the notion of interference in the logic
%% itself~\cite{rg}.
%% 
%
%% Consider for instance
%% a program where threads operate on subgraphs of a global graph.
%
%
%%  dubbed their \emph{subjective states}.  One may then reuse these
%%   specifications in the context of any larger local state (as is
%%   standard in separation logic~\cite{rey02}), and, crucially for
%%   compositional reasoning about concurrent programs, any larger
%%   shared state. The subjective states of different threads in a
%%   program are allowed to overlap arbitrarily, ensuring maximum
%%   reusability of proofs.
%
%
%
%
% Subjective views can expand or contract depending on the resources required by the thread, which has subtle consequences for the logical reasoning. In particular, it is possible to strengthen actions in $I$ to record  some global information known to the subjective view.
%Then, the view can be weakened to just the resources and possibly strengthened actions appropriate to  the thread. The strengthened actions retain  some global information despite the weakened view. 


\paragraph{Related work}
\colosl stems from a long lineage of program logics for shared-memory
concurrency, dating back to the Owicki-Gries logic~\cite{og}, each of
which made substantial advances in fine-grained compositional
reasoning about more and more complex concurrent programs. As noted by
Jones and motivating his definition of rely-guarantee~\cite{rg},
Owicki-Gries's system is fundamentally non-compositional as assertions
at each program point in each thread has to be checked against every
instruction of every other threads. While rely-guarantee addresses
this concern by summarising potential interferences in terms of rely
and guarantee conditions, its model of the shared state is global,
even encompassing the threads' private state. Later techniques
combined rely-guarantee with separation logic, starting with
RGSep~\cite{viktor-marriage}, which separates private (or local) and
shared state, allowing further compositionality. However, the view of
the shared state and interference on it is still globally shared
across threads. The next breakthrough as far as compositionality is
concerned came from LRG~\cite{lrg}, wherein the shared state may be
split into completely independent pieces, thus partially solving the
first problem outlined above. This provides a way to frame off parts
of the shared state, but, as noted by its author, the strong
disjointness restrictions make this applicable only at the level of
disjoint modules in the code. Independently from LRG, the reasoning
framework of CAP~\cite{cap-ecoop10}
and its extended variants~\cite{icap,tada} introduced the notion
of \emph{regions} of shared state. Much like LRG, the division into
regions is only possible for entirely disjoint pieces of state, with
fixed and disjoint interference relations.

TODO: rewrite a bit.
There are many interesting ideas present in the CAP literature:
e.g. abstract states~\cite{caresl}; higher-order
reasoning~\cite{icap}; and abstract atomicity~\cite{tada}. All these
ideas require further investigation. Here, our aim was to simply
introduce subjective views as a fundamental new way of underpinning of
such reasoning.

TODO: CareSL

TODO Turon et al.'s POPL'13 paper (which also espouses the idea of
using "local protocols" to govern individual pieces of a shared data
structure, albeit in a less rigorously enforced manner than in \colosl)

(and probably his ICFP paper as well)

We conclude this section by noting that while \colosl appeals to \emph{subjective views} to reason about \emph{fine-grained} concurrency, Subjective Concurrent Separation Logic (SCSL)~\cite{SCSL} uses \emph{subjective auxiliary states} to reason about \emph{coarse-grained} concurrency. While as the authors note in~\cite{SCSL}, CAP (and by
design \colosl) can be employed to reason about their studied examples, SCSL cannot be used to reason about scenarios involving fine-grained concurrency.

\paragraph{Paper outline}
In \S\ref{sec:intuition}, we exhibit the main principles of \colosl
through a variant of Dijkstra's token-ring mutual exclusion
algorithm~\cite{dijkstra74}, which illustrates distributed, global
knowledge between threads. In this scenario, as well as the local
knowledge about how each thread behaves, the programmer also has
global knowledge about how threads constrain one another. Pleasantly,
our reasoning captures the spirit of local reasoning about individual
threads while retaining global knowledge about the overall
interactions between threads.
%It is a good  introductory example, as it uses all the highlighted \colosl\ reasoning principles in a fundamental way. 

\todo In \S\ref{sec:logic}, we interpret \colosl\ assertions over a particular domain which includes: thread-local state exclusively visible to the thread; {\em one} global shared state accessible by all thread (in contrast with the CAP approach); and {\em action models} describing how the global state can be updated. In \S\ref{sec:semantics}, we define the rely and guarantee conditions of each thread in terms of their action models, and provide a sketch of soundness. In particular, the reasoning principles highlighted above are simple semantic
consequences of our generic model of program states.  
%The full technical details can be found in the accompanying technical report~\cite{colosl-tr14}.

In \S\ref{sec:examples}, we study further, more challenging examples. We verify a concurrent spanning tree algorithm for graphs. This algorithm uses threads spawned on arbitrary overlapping graphs. We demonstrate that the flexible, overlapping subjective views of \colosl are just what we need.  We also verify a concurrent set module implemented using a hand-over-hand list-locking algorithm.
%
The flexibility of \colosl's subjective views leads to a considerably simpler correctness proof compared to that of CAP. 
%
Finally, we demonstrate how the mutual exclusion ring of \S\ref{sec:intuition} can be generalised to synchronise access to a concurrent database.
