\section{Introduction}

%% Jules: be more general than just program logics? Model-checking, etc.?

Driven by the ever-increasing need for concurrency in software,
%%  spurred by recent hardware developments, 
program logics for shared-memory concurrency have progressed towards
the twin ideals of fine-grain reasoning and compositionality. The
former enables elegant proof techniques about increasingly subtle
concurrency idioms~\cite{vv06popl,vv07msc,todo}, while the latter
allows programs to be proved component-wise and their proofs to be
reusable as-is in any client
program~\cite{csl-tcs,cap-ecoop10,icap}. Central to these
compositional verification frameworks is the formalism used to
describe both the state shared between program threads and the
possible interference on that state.
%%  dating back from Owicki~\cite{owicki}, and later Jones who
%% integrated the notion of interference in the logic
%% itself~\cite{rg}.

The recent formalism of Views~\cite{views} pinpoints the fundamental
insight behind these program logics: assertions denote \emph{views} of
the concrete machine state for each thread, which other threads cannot
invalidate. Borrowing the vocabulary, existing formalisms (with the
notable exception of Local Rely Guarantee~\cite{lrg}--henceforth LRG)
require the view of all threads to map to the same portion of concrete
state. This impedes compositionality: to use a given program
specification in another context, the current shared state has to
match that of the existing specification. In general, however, the
shared state could contain more resources, potentially overlapping
with those of the specification. Consider for instance a program
producing the spanning tree of a graph by spawning two recursive
copies of itself on each subgraph of non-empty graphs. The overall
specification would be (schematically) of the form
\[
\hoare{\shared{\p{graph}(\li x)}{}}
      {\li{spanning(x)}}
      {\shared{\p{tree}(\li x)}{}}
\]
where boxed assertions describe shared state. At the site of a
recursive call on a subgraph \li l, after unfolding $\p{graph}{\li
  x}$, one needs to establish (TODO: ugh, do we want to explain
formulas/$**$, or should we just have words here?)
\[
\shared{\li x |-> m,\li l, \li r ** \p{graph}(\li l) ** \p{graph}(\li r)}{}
|- \shared{\p{graph}(\li l)}{}
\]
which is unfortunately not true. The rigidity of existing frameworks
forces us to abandon the subjective view of the state in favour of
more global specifications, for instance of the schematic form
\[
\hoare{\shared{\p{graph}(\li{root}) ** \p{graph}{\li x}}{}}
      {\li{spanning(x)}}
      {\shared{\p{graph}(\li{root}) ** \p{tree}(\li x)}{}}
\]
In this situation, the reasoning has to cover the whole global shared
state (in particular, here it assumes that nothing beyond the original
graph is shared between any threads in the context), and be robust
against interferences from the environment \emph{even on parts of the
  shared state not actually accessed by the current thread}.

Moreover, while in the example above we know what the global shared
state is, this will not always be the case (\textit{e.g.}, when
proving code from a library, independently of any client). The
discrepancy between the current subjective state and that of
established specifications may be arbitrary (TODO: I'm trying to say
they could overlap, be disjoint, etc.).

This paper presents the program logic \colosl, which achieves
compositional reasoning for concurrent programs by enabling
\emph{subjective} views of the shared state. Subjective views may be
composed arbitrarily and manipulated so as to retain only the portions
of local and shared state actually accessed by each thread in the
program, and to consider only the interferences relevant to that piece
of shared state.

%%  dubbed their \emph{subjective states}.  One may then reuse these
%%   specifications in the context of any larger local state (as is
%%   standard in separation logic~\cite{rey02}), and, crucially for
%%   compositional reasoning about concurrent programs, any larger
%%   shared state. The subjective states of different threads in a
%%   program are allowed to overlap arbitrarily, ensuring maximum
%%   reusability of proofs.


Achieving a greater degree of compositionality in the reasoning
supposes that we change the way the shared state is described
logically.  In \colosl, shared state assertions are of the form
$\shared P I$ where $P$ is a formula and $I$ a set of \emph{actions}
(or interferences). Such an assertion means that $P$ is true of
\emph{some part} of the shared state, and that this part of the shared
state is subject to interferences in $I$ (which describes those
actions mutating the shared state that are to be expected from the
environment and those that the current thread is allowed to perform).

Four novel reasoning principles allow us to reason about this novel
interpretation of shared state assertions in \colosl. First, since we
only care about some unspecified fraction of the shared state, we can
always  zoom in on a fraction of the subjective state:
\begin{align*}
  \shared{P * Q}{I} &\vdash \shared{P}{I}  \tag{\textsc{Forget}}
\end{align*}
TODO: why this is cool.

Second, the $*$ connective of separation logic splits the shared state
into \emph{overlapping} subjective views (EXPLAIN OVERLAP):
\begin{align*}
  \shared{P}{I_1} * \shared{Q}{I_2} &\vdash \shared{P \sepish Q}{I_1 \cup I_2} \tag{\textsc{Merge}}
\end{align*}
[TODO: new: usually $I$ never changes.]

In combination with the usual law of parallel composition of
separation logic~\cite{csl-tcs}, this yields a powerful mechanism to
distribute the shared state between several threads:
\[
\infrule{Parallel}
        {\hoare{P_1}{\mathbb{P}_1}{Q_1}\\
          \hoare{P_2}{\mathbb{P}_2}{Q_2}}
        {\hoare{P_1 * P_2}{\mathbb{P}_1 || \mathbb{P}_2}{Q_1 * Q_2}}
        {}
\]


Third, a set of actions $I$ can be exchanged for any other $I'$ that
has the same projected effect on the subjective state $P$; when that
is the case, we write $ I \weakenIb{P} I'$ and say that the actions
are \emph{shifted}:
\begin{align*}
  I \weakenIb{P} I'
  &\text{ implies }
  \shared{P}{I} \Vvdash \shared{P}{I'}
  \tag{\textsc{Shift}}
\end{align*}
TODO: new: usually $I$ never changes. Semantic equivalence between $I$
and $I'$ partially axiomatised; enough for our examples.

Finally, private resources can be incorporated into the shared state
together with new actions:
\begin{align}
  P \containI I
  &\text{ implies }
  P \Vvdash
  \exsts{\capAss{1}, \capAss{2}} \capAss{1} * \shared{P *
    \capAss{2}}{I}
  \tag{\textsc{Extend}}
\end{align}
The side condition $P \containI I$ ensures that the mutations
performed by actions in $I$ are confined to $P$.  TODO: why this is
new (new actions may refer to existing shared state).



Contributions:
\begin{enumerate}
\item
  We introduce the program logic \colosl, which achieves fully
  compositional rely/guarantee style reasoning for concurrent
  programs. Our soundness result is parametric in the underlying
  programming language and separation algebra of states.
\item
  We evaluate \colosl on a range of key examples that were challenging
  for previous work. We are able to derive natural and concise specs,
  circumscribed to the part of the shared state accessed by each
  thread, even in the case of threads operating on subparts of data
  structures with unspecified sharing (directed acyclic graphs in our
  example).
\item
  We demonstrate the generality of \colosl by deriving the main
  reasoning principles of existing program logics for concurrency
  within our framework.
\end{enumerate}

\paragraph{Related work}
Reasoning about concurrency: major advances since Owicki-Gries:
compositional reasoning, from the seminal paper by Jones~\cite{rg} on
the one hand, and O'Hearn~\cite{csl-orig,csl-tcs} on the other hand,
later fused together in a series of increasingly compositional
formalisms such as RGSep~\cite{viktor-marriage}, Local RG~\cite{lrg},
deny-guarantee~\cite{dg}, and the CAP
family~\cite{cap-ecoop10,icap,tada}, to name a few.

%% [have pictures of the shared state throughout the ages, like in the
%%   York talk? No: it's difficult to argue that the drawings accurately
%%   represent the logics RGSep and LRG...]

In some way, this mirrors the progression w.r.t.\ compositionality of
reasoning about sequential programs with resources/heap: first Hoare
logic~\cite{hoarelogic} carry around the whole of the heap. Major
advances in compositionality for pointer programs via separation
logic~\cite{seplog}, which enables \emph{local} proofs where
irrelevant and disjoint pieces of state are \emph{framed}, recently
extended to programs manipulating data structures with intrinsic
sharing, such as graphs~\cite{ramification}.


\paragraph{Outline}
\S\ref{sec:intuition} motivates the four main mechanisms of \colosl on
an illustrative example; \S\ref{sec:logic} formalises our program
logic and the semantics of state assertions; \S\ref{sec:examples}
sketches the proofs of more examples (TODO: more awesome);
\S\ref{sec:soundness} presents our soundness result, and
\S\ref{sec:conclusion} contrast with related work and concludes.
