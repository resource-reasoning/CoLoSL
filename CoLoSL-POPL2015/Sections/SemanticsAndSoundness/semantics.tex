\section{\colosl rules}
\todo Section title must change.
\todo introductory paragraph to summarise this section?
%
\subsection{Rely, Guarantee, Stability}
%
%
\paragraph{Stability}
An assertion is \emph{stable} if and only if it cannot be falsified by the interference from other threads in the environment. That is, for all possible updates that the environment can do, the assertion must remain true. To capture the interference of the environment, we define the Rely relation.
%
%
\begin{definition}[Rely] The \emph{Rely} relation $\rely: \pset{\Worlds \times \Worlds}$ is
%
\[
	\rely \eqdef  \left(\updateR \cup \extendR \cup \shiftR \right)^{\text{*}}
\]
%
where * denotes the reflexive transitive closure and 
%
\[
\begin{array}{@{} r @{} l @{}}
	\extendR \eqdef &
 	\left\{
	\begin{array}{@{} l @{\hspace*{2pt}} | @{\hspace*{2pt}} r @{}}
	   \left(
	   \begin{array}{@{} l @{}}
	     (l , g, \gmod, \lmod),\\
 	     \left(
	     \begin{array}{@{} l @{}}
	      l,
	      g \composeL g',\\
	      \gmod', \lmod \cup \lmod_n
	     \end{array}
 	    \right)
	   \end{array}
 	  \right)
	   &
 	  	\begin{array}{@{} l @{}}
%	 	  	g' = l' \composeL (\unitH, \ca{2})  \land\\
	 	  	
	 	  	\capPart{g'} \subseteq \dom{\lmod_n} \cup \dom{\lmod} \land \\
	 	  	
			\extendsAM{\gmod', \lmod \cup \lmod_n}{g'}{g}{\lmod_n} \land \\
			
%			\for{l_1, r, \amod{1} \subseteq \lmod} \\
%			\hspace*{0.1cm} l_1 \composeL r = s \land \extendsAM{\gmod, \lmod}{l_1}{r}{\amod{1}}  \\
%			\hspace*{0.1cm} \implies\extendsAM{\gmod', \lmod \cup \amod{0}}{l_1}{r \composeL s'}{\amod{1}}
			
			\expandsAM{\gmod'}{\lmod_n}{g'}{g}{\gmod}{\lmod}
			
     	
   		\end{array}
 	\end{array}
	\right\}\\
	
	
	
	\updateR \eqdef &
 	\left\{
	\begin{array}{@{} l @{\hspace*{2pt}} | @{\hspace*{2pt}} r @{}}
	   	\left(
	   	\begin{array}{@{} l @{}}
	     	(l, g, \gmod, \lmod),\\
	     	(l, g', \gmod, \lmod)
	   	\end{array}
		\right)
	  	&
	  	\begin{array}{@{} l @{} }
%		  	\left(
%		  	\begin{array}{@{} l @{} }
%		 		g = g' \lor\\

		 	  	\begin{array}{@{} l @{}}
		 	  		\exsts{\ca{} }\left( \capPart{l} \composeCap \capPart{g} \right) \disjoint \ca{} \land 
		 	  		(g, g') \in \gmod(\ca{}) \\
		 	  	
		 	  	\end{array}	

%		 	\end{array}
%	   		\right)
   		\end{array}
 	\end{array}
	\right\}\\
	
	
	
	\shiftR \eqdef & 
	\left\{
	\begin{array}{@{} l @{\hspace*{2pt}} | @{\hspace*{2pt}} r @{}}
	   \left(
	   \begin{array}{@{} l @{}}
	     (l, g, \gmod, \lmod),
 	     \left( l, g, \gmod, \lmod \cup \lmod_n  \right)
	   \end{array}
 	  \right)
	   &
% 	  	\begin{array}{@{} l @{}}
%	 	  	\for{l, r} \for{\gmod' \subseteq \lmod} \extendsAM{\gmod, \lmod}{l}{r}{\gmod'} \\
%	 	  	\hspace*{0.5cm} \implies \extendsAM{\gmod, \lmod \cup \amod{0}}{l}{r}{\gmod'}
%   		\end{array}

		\expandsAM{\gmod}{\lmod_n}{\unitL}{g}{\gmod}{\lmod}
 	\end{array}
	\right\}

\end{array}
\]
%
where \emph{action model extension}, $\expandsAM{\gmod'}{\lmod_n}{s'}{s}{\gmod}{\lmod}$, denotes the extension of $(\gmod, \lmod)$ to $(\gmod', \lmod \cup \lmod_n)$ when the shared state is extended with $s'$ and is described in \defin\ref{def:amodExtension}.
\end{definition}
%
%
Intuitively, the Rely relation describes all possible updates by the environment. At any one point, a thread in the environment may extend the shared state with additional resources ($g'$), introduce new interference to describe how the new resources can be manipulated ($\lmod_0$) and consequently rewrite the global action model ($\gmod'$). This is captured by the \extendR\ relation. For this to be possible, the resultant action model pair $(\gmod', \lmod \cup \lmod_0)$ must be closed under the newly added resources and interference: $\extendsAM{\gmod', \lmod \cup \lmod_0}{g'}{g}{\lmod_0}$. Additionally, for all subjective state $l_1$, context $r$ and action model $\lmod_1$ under which the old action model pair was closed, the new action model pair must also  be closed when the context is extended with the new resources $\extendsAM{\gmod', \lmod \cup \lmod_0}{l_1}{r \composeL g'}{\lmod_1}$. 

Moreover, at any one point the environment may update the shared state by performing an action for which it has the sufficient capability ($\ca{}$). This is described by the \updateR\ relation. For this to be possible, the thread performing the action must have the $\ca{}$ capability in its own local state and thus the $\ca{}$ capability must be disjoint from both shared and local states of the current world. 

Finally, the environment may extend the local action model by shifting (rewriting) some of the existing behaviour. This is modelled by the \shiftR\ relation. This is only possible if for any subjective state $l$, context $r$ and action model $\gmod'$ under which the old action model pair was closed, the new action model pair is also closed: $\extendsAM{\gmod, \lmod \cup \lmod_0}{l}{r}{\gmod'}$. 
%
%
\begin{definition}[Action Model Extension]\label{def:amodExtension}
An action model $\gmod'$ \emph{extends}  ($g, \gmod, \lmod$) with $(\lmod_n, g')$, written $\expandsAM{\gmod'}{\lmod_n}{g'}{g}{\gmod}{\lmod}$, iff for all $\lmod_0 \subseteq \lmod$ and $s, r$ such that $s \composeL r = g$:
%
\[
	\extendsAM{\gmod, \lmod}{s}{r}{\lmod_0} \implies \extendsAM{\gmod', \lmod \cup \lmod_n}{s}{r\composeL g'}{\lmod_0}
\]
%
\end{definition}
%
%
The rely $\rely$ enables us to define the stability of assertions with respect to the environment actions.
%
\begin{definition}[Stability] An assertion $P$ is stable ($\stable{P}$) iff for all $\lenv \in \LEnv$ and $w, w' \in \Worlds$, if $w, \lenv |= P$ and $(w, w') \in \rely$, then $w', \lenv |= P$.
%\[	
%\begin{array}{r @{} l}
%	\stable{P} \iffdef &
%	\for{\lenv}\for{w, w'} \\
%	& w \in \sem[\lenv]{P} \land (w, w') \in \rely \implies
%	 w' \in \sem[\lenv]{P}
%\end{array}
%\]
\end{definition}
%
\begin{lemma}[Stability]
An assertion $P$ is stable if it cannot be falsified by possible updates on the shared state from other threads:
%
\[
\begin{array}{l}
	\for{\lenv}\for{w, w'} 
    w, \lenv |= P \land (w, w') \in \updateR \implies
	 	w', \lenv |= P\\
	 
	 \implies \stable{P}
\end{array}	 
\]
%
\end{lemma}
%
That is, an assertion $P$ is always stable with respect to possible extensions of the shared state and action shifting. For an assertion to be stable it thus suffices to consider the interference on the shared state from other threads.

We now define the Guarantee relation  that describes all possible updates the current thread can perform. Intuitively, the Guarantee relation is the dual of Rely.
%
\begin{definition}[Guarantee]
The \emph{Guarantee} relation $\guarantee: \powerset (\Worlds \times \Worlds)$ is defined as
%
\[
	\guarantee \eqdef  \left( \updateG \cup \extendG \cup \shiftG \right)^{\text{*}}
\]
%
with
%
\[
\begin{array}{@{} r @{} l @{}}

	\extendG \eqdef &
 	\left\{
	\begin{array}{@{} l @{\hspace*{2pt}} | @{\hspace*{2pt}} r @{}}
	   \left(
	   \begin{array}{@{} l @{}}
	     (l \composeL l', g, \gmod, \lmod),\\
 	     \left(
	     \begin{array}{@{} l @{}}
	      l \composeL (\unitH, \ca{1}),\\
	      g \composeL g',\\
	      \gmod', \lmod \cup \lmod_n
	     \end{array}
 	    \right)
	   \end{array}
 	  \right)
	   &
 	  	\begin{array}{@{} l @{}}
	 	  	g' = l' \composeL (\unitH, \ca{2})  \land\\
	 	  	
	 	  	\ca{1} \composeCap \ca{2} \subseteq \dom{\lmod_n} \land \\
	 	  	
	 	  	\ca{1} \composeCap \ca{2} \disjoint \dom{\lmod} \land \\
	 	  	
			\extendsAM{\gmod', \lmod \cup \lmod_n}{g'}{g}{\lmod_n} \land \\
			
%			\for{l_1, r_1, \amod{1} \subseteq \lmod} \\
%			\hspace*{0.1cm} l_1 \composeL r_1 = s \land \extendsAM{\gmod, \lmod}{l_1}{r_1}{\amod{1}}  \\
%			\hspace*{0.1cm} \implies\extendsAM{\gmod', \lmod \cup \lmod_0}{l_1}{r_1 \composeL s'}{\amod{1}}

			\expandsAM{\gmod'}{\lmod_n}{g'}{g}{\gmod}{\lmod}
			
     	
   		\end{array}
 	\end{array}
	\right\}\\
	
	\updateG \eqdef &
 	\left\{
	\begin{array}{@{} l @{\hspace*{2pt}} | @{\hspace*{2pt}} r @{}}
	   	\left(
	   	\begin{array}{@{} l @{}}
	     	(l, g, \gmod, \lmod),\\
	     	(l', g', \gmod, \lmod)
	   	\end{array}
		\right)
	  	&
	  	\begin{array}{@{} l @{} }
	  		\capPart{(l' \composeL s')}  \subseteq \capPart{(l \composeL g)} \land\\
		  	\left(
		  	\begin{array}{@{} l @{} }
		 		g = g' \lor\\
		 	  	\left(
		 	  	\begin{array}{@{} l @{}}
		 	  		\exsts{\ca{} \subseteq \capPart{l}}
		 	  		(g, g') \in \gmod(\ca{}) \land\\
		 	  	
		 	  	\heapSize{\heapPart{\left(l \composeL g\right)}} \subseteq 
		 	  	\heapSize{\heapPart{\left(l' \composeL g'\right)}}
		 	  	\end{array}	
		 	  	\right)
		 	\end{array}
	   		\right)
   		\end{array}
 	\end{array}
	\right\}\\
	
	
	
	\shiftG \eqdef & 
	\left\{
	\begin{array}{@{} l @{\hspace*{2pt}} | @{\hspace*{2pt}} r @{}}
	   \left(
	   \begin{array}{@{} l @{}}
	     (l, g, \gmod, \lmod),
 	     \left( l, g, \gmod, \lmod \cup \lmod_0  \right)
	   \end{array}
 	  \right)
	   &
	   
	   \expandsAM{\gmod}{\lmod_n}{\unitL}{g}{\gmod}{\lmod}
% 	  	\begin{array}{@{} l @{}}
%	 	  	\for{l, r} \for{\gmod' \subseteq \lmod} \extendsAM{\gmod, \lmod}{l}{r}{\gmod'} \\
%	 	  	\hspace*{0.5cm} \implies \extendsAM{\gmod, \lmod \cup \lmod_0}{l}{r}{\gmod'}
%   		\end{array}
 	\end{array}
	\right\}

\end{array}
\]
%
\end{definition}
%
%
The current thread may at any point extend the shared state with some of its locally held resources $l'$ and in doing so introduce new interference to describe how the new resources may be mutated ($\lmod_0$) and generate  new capabilities ($\ca{1} \composeCap \ca{2} \subseteq \dom{\lmod_0}$) that facilitate the new interference. This is captured by the \extendG\ relation and is analogous to \extendR.  The generated capabilities must be fresh ($\ca{1} \composeCap \ca{2}  \disjoint \dom{\lmod}$). The last two conjuncts  enforce closure of the new action models and can be justified as in the case of \extendR.

The current thread can update its local state arbitrarily and may update the shared state by performing an action for which it holds the necessary capability $\ca{}$ in its local state. This is described by the \updateG\ relation. For this to be possible, the total amount of capabilities held locally and in the shared state must not grow. That is, the current thread may not generate new capabilities arbitrarily since capabilities may only be generated upon extension of the shared state as captured in \extendG. Similarly, if the shared state is being updated ($g \not= g'$),  then the heap resources (the domain of the heap) may not grow ($\heapSize{\heapPart{(l \composeL g)}} \subseteq \heapSize{\heapPart{(l' \composeL g')}}$) where the $\heapSize{.}$ function is as given in \defin\ref{def:orthogonal}. The intuition behind this constraint is to ensure that threads do not generate resources out of thin air in order to enable actions. Note that this does not stop a thread from local allocation/deallocation of resources. In the case of allocation, the desired effect can be achieved by first allocating the new resources locally (\textit{i.e.} extending the local state from $l$ to $l \composeL l''$), while leaving the shared state untouched; and then performing the relevant action on the shared state (\textit{i.e.} updating $g$ to $g'$) without extending the heap resources, as illustrated in the following sequence.
%
\[
\begin{array}{l}
	(l, g, \gmod, \lmod) \rightarrow (l \composeL l'', g, \gmod, \lmod) \rightarrow (l', g', \gmod, \lmod)\\
	\text{ where } \heapSize{\heapPart{(l \composeL l'' \composeL g)}} \subseteq \heapSize{\heapPart{(l' \composeL g')}}
\end{array}
\]
%
Deallocation of local resources can be achieved in a similar fashion.
%That is, all previously compatible frames remain compatible. We illustrate the need for this constraint in \ex ~\ref{ex:compatibleFrames}.

Lastly, the current thread may extend the local action model by shifting some of the existing interference. This is modelled by the \shiftG\ relation and is analogous to \shiftR.
%
%
\begin{definition}[Orthogonal]\label{def:orthogonal}
The \emph{orthogonal} of a state  $\heapSize{.}: \Heaps \rightarrow \pset{\Heaps}$ is defined as the set of all states that are disjoint from it. That is, given a state $\h{} \in \Heaps$:
%
\[
	\heapSize{\h{}} \eqdef \left\{ \h{}' \mid \h{} \disjoint \h{}' \right\}
\]
%
\end{definition}
%
Using the guarantee relation, we introduce the notion of \emph{repartitioning} a state that satisfies $P$ to one satisfying $Q$ with respect to an update from $R_1$ to $R_2$, written $\repartitions{P}{Q}{R_1}{R_2}$. While the guarantee states how a thread can modify the shared state, extend it or shift the interference, repartitioning describes how the local and shared \emph{heaps} are updated in such a way that is compatible with the guarantee as well as the update from $R_1$ to $R_2$.
%
\begin{definition}[Repartitioning] \label{def:repartitioning}
$\repartitions{P}{Q}{R_1}{R_2}$ holds iff for every $\lenv \in \LEnv$, and world $w_1$ where $w_1, \lenv |= P$, there exists a state $m_1 \in \Heaps$ where $(m_1, \emptyset), \lenv \slsat R_1$ and a residual state $m'$ such that 
%
\begin{itemize} 
	\item $m_1 \composeH m' = \heapPart{\left(\collapseW{w_1}\right)}$; and
	\item for every $m_2$ where $(m_2, \emptyset), \lenv \slsat R_2$, there exists a world $w_2$ where $w_2, \lenv |= Q$ such that:
	\begin{itemize}
		\item $m_2 \composeH m' = \heapPart{\left(\collapseW{w_2}\right)}$; and
		\item $(w_1, w_2) \in \guarantee$
	\end{itemize}	  
\end{itemize}
%
where $\collapseW{l, g, \gmod, \lmod} \eqdef l \composeL s$.

Note that when $R_1 = R_2 = \emp$, then the repartitioning has no side effect in that it preserves the concrete state and only allows the world to be repartitioned. We write $P \semimplies Q$ for $\repartitions{P}{Q}{\emp}{\emp} $.
%\[
%\begin{array}{@{} r l @{}}
%	\repartitions{P}{Q}{p}{q} \iffdef 
%	& \for{\lenv} \repartitions{\sem[\lenv]{P}}{\sem[\lenv]{Q}}{\semH[\lenv]{\heapAss{1}}}{\semH[\lenv]{\heapAss{2}}}\\\\
%	
%	\repartitions{W_1}{W_2}{H_{1}}{H_{2}} \iffdef &
%	\begin{array}{l}
%		\for{w_1 \in W_1} \exsts{h_1 \in H_1\ , h'}\\
%		\hspace*{0.5cm} h_1 \composeH h' = \heapPart{(\collapseW{w_1})} \;\land\\
%		\hspace*{0.5cm} \for{h_2 \in H_2} \exsts{w_2 \in W_2}\\
%		\hspace*{1cm} h_2 \composeH h' = \heapPart{(\collapseW{w_2})} \;\land\; (w_1, w_2) \in \guarantee
%	\end{array}
%\end{array}
%\]
%%
\end{definition}
%
%
\begin{lemma}[]
The semantic implications (\extendRule) and (\shiftRule) are valid.
%
\begin{proof}
In each case, it suffices to show that the respective repartitioning ($\semimplies$) is valid and allowed by the guarantee relation. In the case of (\extendRule) the transition is contained in the \extendG\ relation, while with (\shiftRule) the transition is allowed by \shiftG. The full proof is provided in~\cite{colosl-tr14}.
\renewcommand{\qed}{}
\end{proof}
%
\end{lemma}
%
%
\paragraph{Proof rules}
Our proof rules are of the form $\entails \{P\}\ C\ \{Q\}$ and carry an implicit assumption that the pre- and post-conditions of their judgements are stable. Most of the proof rules are standard with the exception of the atomic and consequence rules. We proceed with the judgements of these rules.
%
%
\begin{definition}[Proof rules]\label{def:proofRules} The \emph{atomic} proof judgement, \proofRule{Atom}, is defined as follows where $\entails_{\textsf{SL}}$ denotes the standard sequential separation logic judgement.
%
\[
%\begin{array}{c}
	\infer[\proofRule{Atom}]{
		\entails \{P\} \atomic {C} \{Q\}
	}{
		\entails_{\textsf{SL}} \{R_1\}\ C\ \{R_2\} &
		\repartitions{P}{Q}{R_1}{R_2}
	}
\]
%
The \emph{rule of consequence}, \proofRule{Conseq}, is as given below.
%
\[	
	\infer[\proofRule{Conseq}]{
		\entails \{P\}\ C\ \{Q\}
	}{
		P \semimplies P' &
		\entails \{P'\}\ C\ \{Q'\} &
		Q' \semimplies Q
	}
%\end{array}
\]
%
In both judgements, $\semimplies$ denotes the repartitioning of the state as described in \defin\ref{def:repartitioning}.
\end{definition}
%
%
%\subsection{Program logic}
%We build the \colosl\ program logic on top of the views framework~\cite{views} instantiated as follows. Our view semigroup is the separation algebra of worlds as described in \defin\ref{def:worlds}. 
%The machine states and the reification of worlds are given in \defin\ref{def:machineStates} and \ref{def:reification}\footnote{
%Generally, since \colosl\ is parametric in the separation algebra of heaps, the set of machine states and the reification function over heaps are also parameterised. Further details can be found in~\cite{colosl-tr14}.
%}. 
%The grammar of \colosl\ atomic commands is provided in \defin\ref{def:atomicCommands}; we show the soundness of \colosl\ atomic commands in the companion technical report~\cite{colosl-tr14}. 
%The axiomatisation of \colosl\ atomic commands are as per \defin\ref{def:proofRules}.
%%
%%
%\begin{definition}[Machine States]\label{def:machineStates}
%The set of \colosl\ \emph{Machine States} are $\MStates \eqdef \Heaps$.
%\end{definition}
%%
%%
%%
%%
%\paragraph{Programming language}
% We use the programming language of the views framework \cite{views} instantiated with a set of atomic commands. \colosl\ is parametric in the set of atomic commands: we provide an atomic construct $\atomic{.}$ that can be applied to any sequential command and enforce atomic behaviour. We proceed with the grammar of \colosl atomic commands.
%%
%\begin{definition}[Atomic commands]\label{def:atomicCommands}
%The \emph{atomic commands} of \colosl, $\atom{} \in \Atoms$, are defined by the following grammar
%%
%\begin{mathpar}
%	\atom{} ::= \atomic{\seq{}}
%	
%	\seq{} ::= \bc{} \mid \li{skip} \mid \seq{1};\seq{2} \mid \seq{1}+\seq{2} \mid \seq{}^{\text{*}}
%\end{mathpar}
%%
%where $\bc{} \in \Basics$ denotes a set of basic commands that can be instantiated with any set of sequential commands. In the examples of this paper, our basic commands are given by the following grammar.
%%
%\[
%\bc{} ::= \li{x}:= E \mid \li{assume}(E)
%\]
%%
%\end{definition}
%
%\paragraph{Soundness}\label{subsec:soundness}
%In~\cite{colosl-tr14} we provide the semantics of the \colosl\ programming language; we demonstrate that the \colosl\ program logic is sound with respect to its semantics by appealing to the views framework~\cite{views}.
%
%
%
\subsection{Interference manipulations}\label{subsec:extension}
%The rest of the semantic development of this section concerns the
%formalisation of the notions of well-formed states, action
%shifting, and action model closure, which were informally introduced
%above. Central to these definitions is the concept of fences.
In this section we formalise the notions of action action model containment and action shifting, which were informally introduced in \S\ref{sec:logic}. Central to these definitions is the concept of fences.
%
\paragraph{Shared state extension}
Recall from \S\ref{subsec:extend} that one may always \emph{extend}
the shared state using local resources from the current state of a
thread. In doing so, one must specify the interference relation over
newly shared resources. While in \colosl the new interferences may
mention parts of the shared state beyond the newly added resources,
they must not allow visible updates to those parts, so as not to
invalidate other threads' views of existing resources. We thus impose
a locality condition on the newly added behaviour to ensure sound
extension of the shared state. This is informally illustrated in the
following example.
%
\begin{example}\label{ex:badExtension}
Let $P \eqdef \cell{x}{1} * \shared{\cell{y}{1} \lor \cell{y}{2}}{I}$ denote the view of the current thread with $I \eqdef \left(\token{b}: \left\{\cell{y}{1} \swap \cell{y}{2}\right\} \right)$. Since the current thread owns the location addressed by $x$, it can extend the shared state as $Q \eqdef [\token{a}] * \shared{\left(\cell{y}{1} \!\lor\! \cell{y}{2} \right) * \cell{x}{1}}{I \cup I'}$ where 
$
	I' \eqdef 
		\left(
			\token{a}: 
			\left\{
			\begin{array}{@{}l@{}} 
				\cell{x}{1} \swap \cell{x}{2}\\
				\cell{y}{1} \swap \cell{y}{3}
			\end{array}
			\right\}
		 \right)
$.
In extending the shared state, the current thread also extended the interference allowed on the shared state by adding two new actions associated with the newly generated capability resource $[\token{a}]$ as given in $I'$. The first action specifies how the value of location $x$ can be updated. Since location $x$ was previously owned privately by the current thread and was hence not visible to other threads, this new action will not invalidate their view of the shared state. On the other hand, the second action introduces a new way in which the value of location $y$ can be mutated. To other threads the only updates allowed on location $y$ are done through the $[\token{b}]$ capability as specified in $I$ and thus this new behaviour is unbeknownst to them. As such, this action violates the view of other threads and does not agree with the existing interference.
\end{example}
%
%
In order to ensure sound extension of the shared state, we require that the newly introduced interferences are confined to the locally owned resources (\textit{cf.} \eqref{eq:extend}).
%
\begin{definition}
  A set of states $\mathcal P$ \emph{contains} an action model
  $\gmod$, written $\mathcal P \containI \gmod$, if
  \[
  \E{\fence{}} \mathcal P\subseteq \fence{} /| \fence{} \strictfences \gmod
  \]
\end{definition}

We lift the notion of containment to assertions as follows where given $P \in \Assertions$ and $I \in \IAssertions$:
%
\[
	P \containI I \iffdef \for{\lenv, \ca{}} \left\{l \mid l, \lenv \slsat P \right\} \containI \semI[\lenv]{I}(\ca{})
\]
%


\paragraph{Action shifting}
Recall from \S\ref{sec:intuition} that \colosl\ allows for forgetting
of those actions that do not affect the subjective view of the shared
state, as well as rewriting the behaviour of actions to gain a more
accurate account of their effect. This is achieved through
\emph{action shifting}, which allows the swapping of one global action
model for another one that is equivalent. Here, being equivalent means
that there is some fence that sees them as equivalent, in that actions
from the new global action model contains only actions with the same
effect from the old one, and moreover any action from the old one that
affects the subjective state has to remain in the new one. Since we
are working at the level of a subjective view and not the whole shared
state, we need to refine our notion of action application and fences.

\begin{definition}[Subjective action application]
  The \emph{subjective application} $a(l)$ of an action $a$ on a
  logical state $l$ is defined as follows:
  \[
  a(l) == a[l,l - (l\meetL \m{fst}(\updateFP{a}))]
  \]
\end{definition}

\begin{definition}[Fenced action model]
  An action model $\gmod \in \AMods$ is \emph{fenced} by $\fence{}
  \in \pset{\LStates}$, written $\fence{} \fences \gmod$, if, for
  all $l \in \fence{}$ and all $\ca{}\in\m{rg}(\gmod)$,
\[
\begin{array}{L}
  a(l)\text{ is defined} /| \m{visible}(a,l) => a(l)\in\fence{}
  %% (p, q) \in \gmod(\ca{}) /|
  %% p \meetL l \not= \emptyset /|
  %% \updateFP{p, q} = (p', q') \land\\
  %% p' \maxMeetL l = p'' \land
  %% p'' /= \unitL \land
  %% l = p'' \composeL l' /|
  %% q' \compatL l'
  %% =>
  %% q' \composeL l' \in \fence{}
\end{array}
\]
\end{definition}

Note that, in contrast with $a[l]$, only part of the active
precondition has to intersect with the subjective view.

In the example of \fig\ref{fig:concurrentInc}, $I_x$ is fenced by
\[
\fence{x} \eqdef\begin{array}[t]{L}
\left\{\cell{x}{v} * \cell{z}{v} \mid v \in \{0,
\cdots, 10\} \right\} \cup\\
\left\{\cell{x}{v+1} * \cell{z}{v} \mid v
\in \{0 ,\cdots, 9 \}\right\}
\end{array}
\]

\julescomment{Find better/more examples, perhaps of non-fencing as
  well.}


%%%%%%%%%%%%%%%%%%%%%
%% \paragraph{Fences}
%% A subjective state represents the instantaneous view of a thread at a
%% particular instant. However, this view is subject to interferences by
%% other threads, as well as by the thread's own actions, as specified by
%% an action model. To reason on such states, it makes sense to consider
%% all its potential future incarnations with respect to these
%% modifications.  

%% %  F |> s <==> \forall p, q, k, l, l', p',
%% %    (p,q)\in s(k) /\ l o l' o p' is defined /\ l o l'\in F /\ l o p' = p /\ l\neq\emptyset
%% %      => \exists f, l'', q'. l = l'' o f /\ q = f o q' /\
%% %            (l''\neq\emptyset /\ q # l' => l' o q\in F)


%% We are now ready to describe what effect an action $a$ can have on a
%% \emph{subjective} state $l$: because the subjective state is not the
%% whole shared state, the precondition of $a$ only needs to be
%% \emph{compatible} with $l$. When that is the case, the action consumes
%% the part of its active precondition that intersects with $l$ and plugs
%% in its active postcondition instead, provided that the result is
%% defined.





\begin{definition}[Action shifting]
  Given $\gmod, \gmod' \in \AMods$ and $\mathcal{P} \in
  \pset{\LStates}$, $\gmod'$ is a \emph{shifting} of $\gmod$ with
  respect to $\mathcal{P}$, written $\gmod \weakenI{\mathcal{P}}
  \gmod'$, if there exists a fence $\fence{}$ such that
  \[
  \begin{array}{L}
    \mathcal{P} \subseteq \fence{} \land \fence{} \fences \gmod
    \land
    \for{l\in \fence{}}\for{\ca{}}\\
    \quad\for{a\in\gmod'(\ca{})}
    \m{present}(a,l,\gmod(\ca{})) /|\null\\
    \quad\for{a\in\gmod(\ca{})}
    a(l)\text{ is defined} /|\m{visible}(a,l) =>
    \m{present}(a,l,\gmod(\ca{}))
    %% \for{\ca{}, l, p, q, p', q', l'} l \in F \land \updateFP{p, q} = (p', q') =>\\
    %% \left(\begin{array}{L}
    %%   (p, q) \in \gmod'(\ca{}) 
    %%   \land p \leq l \composeL r => \\
    %%   \hspace*{0.4cm}\exsts{f} (p' \composeL f, q' \composeL f) \in
    %%   \gmod(\ca{}) \land p' \composeL f \leq l \composeL r
    %% \end{array}\right) /|\\
    %% \left(\begin{array}{L}
    %% (p, q) \in \gmod(\ca{})
    %%   \land p \composeL l' = l \composeL r /| q'\compatL l' /| l \meetL p' /= \{ \unitL \} => \\
    %%   \hspace*{0.4cm}\exsts{f} (p' \composeL f, q' \composeL f) \in \gmod'(\ca{}) \land p' \composeL f \leq l \composeL r
    %% \end{array}\right)
  \end{array}
  \]
\end{definition}
%
%
\julescomment{TODO: update words.}
%
%
Intuitively, there exists an invariant $\fence{}$ that contains the states in $\mathcal{P}$ and encompasses the behaviour of actions in $\gmod$ and 
\begin{enumerate}
	\item if an action in $\gmod'$ is possible given a state $l \in \fence{}$ and an arbitrary context $r$ (its precondition is satisfiable by $l \composeL r$), then there exists a similar action with the same update footprint in $\gmod$ whose precondition is also satisfiable by $l \composeL r$. 
	\item if an action in $\gmod$ is possible given a state $l \in \fence{}$ and an arbitrary context $r$ (its precondition is satisfiable by $l \composeL r$), then \emph{either}  there exists a similar action with the same update footprint in $\gmod'$ whose precondition is also satisfiable by $l \composeL r$; \emph{or} the action does not affect $l$, that is  $l \meetL p' = \{\unitL\}$ where $(p', q')$ denotes the update footprint of the action; \emph{or}  the resultant state ($q' \composeL l'$) is undefined.
\end{enumerate} 
%
%
%We provide a set of rules in \fig\ref{fig:shiftRules} that reduce action shifting to logical entailments. While these rules are not complete, we found them sufficient to reason about our examples. The $\approx^R$ notation in the conclusion of \proofRule{Expand/Contract}, denotes that the shifting is valid both ways (\textit{i.e.} $I_1 \approx^R I_2$ iff $I_1 \weakenI{R} I_2$ and $I_2 \weakenI{R} I_1$). We write $\exact{P}$ to denote that the assertion $P$ is \emph{exact}. That is, there exists $l$ such that for all $\lenv$ and $l'$ where $l', \lenv \slsat P$ then $l = l'$. 
%%
%%
%\begin{figure*}
%\hrule\vspace*{5pt}
%\begin{mathpar}
%	\infer[\proofRule{Hide}]{
%		I \cup \left\{ \capAss{}: \left\{ P * \fenceAss{}  \swap Q * \fenceAss{}  \right\}\right\} \weakenI{R} 
%		I 	
%	}{
%		R \entails \fenceAss{} * \fenceAss{}' 
%		& \fenceAss{} * \fenceAss{}' \fences  I \cup \left\{ \capAss{}: \left\{P * \fenceAss{}  \swap Q * \fenceAss{}  \right\}\right\}
%		&\exact{\fenceAss{}}
%%		& P * \fenceAss{} * \fenceAss{}' \not\entails  false
%		& P \sepish \fenceAss{}' \entails P * \fenceAss{}' 
%		& \precise{P}
%		& \precise{\fenceAss{}'}
%	}
%
%
%	\infer[\proofRule{False-L}]{	
%		I \cup \left\{ \capAss{}: \left\{ P \swap Q\right\}\right\} \weakenI{R} 
%		I 	
%	}{
%		R \entails \fenceAss{} 
%		& \fenceAss{} \fences  I \cup \left\{ \capAss{}: \left\{ P \swap Q \right\}\right\}
%		&F \sepish P \entails \m{false}
%	}
%	
%	
%	\infer[\proofRule{False-R}]{	
%		I \cup \left\{ \capAss{}: \left\{ P \swap Q\right\}\right\} \weakenI{R} 
%		I 	
%	}{
%		R \entails \fenceAss{} 
%		& \fenceAss{} \fences  I \cup \left\{ \capAss{}: \left\{ P \swap Q \right\}\right\}
%		&F \sepish Q \entails \m{false}
%	}
%
%
%	\infer[\proofRule{Expand/Contract}]{
%%		\left( I \cup \left\{ \capAss{}: P \swap Q\right\}\right) \approx^R \left( I \cup \left\{ \capAss{}: \bigcup\limits_{i \in J} P * R_i \swap Q * R_i \right\} \right) 	
%		I \cup \left\{ \capAss{}: P \swap Q\right\} \;\approx^R\;  I \cup \left\{ \capAss{}: \left\{P * R_i \swap Q * R_i \mid i \in J\right\} \right\}	
%	}
%	{	
%		R \entails \fenceAss{} 
%		& \fenceAss{} \fences I \cup \left\{ \capAss{}: \left\{ P \swap Q \right\}\right\}
%		&\bigwedge\limits_{i \in J} \exact{R_i}
%		& \fenceAss{} \sepish P \vdash \bigvee\limits_{i \in J} \fenceAss{} \sepish \left(P * R_i \right)
%	}
%\end{mathpar}
%%\[
%%%\infer{
%%%	\left(I \cup \left\{ \capAss{}: P \swap Q\right\}\right) \weakenI{R} 
%%%	I 	
%%%}{
%%%	R \entails \fenceAss{} 
%%%	& \fenceAss{} \fences  I \cup \left\{ \capAss{}: P \swap Q\right\}
%%%	&\exact{\fenceAss{} \intersect Q}
%%%	& \fenceAss{} \intersect P \vdash \fenceAss{} \intersect Q
%%%}\\\\
%%\]
%\hrule
%%\vspace*{5pt}
%\caption{Action shifting rules.}
%\label{fig:shiftRules}
%\end{figure*}


%
\subsection{Soundness}
In this section we show that the program logic of \colosl\ is sound. We proceed with the definition of a \emph{valid} triple that relates the proof rules (Hoare triples) to the operational semantics of \colosl. In what follows, we write $C, m \rightarrow^{\text{*}} C', m'$ to denote the operational semantics relation where $C, C' \in \textsf{Comm}$ and $m, m' \in \Heaps$. We define a reification function that relates a \colosl\ world $w \in \Worlds$, to concrete states in \Heaps.
%We proceed by  providing the definition of a reification function that maps \colosl\ worlds onto states.
%
\begin{definition}[Reification]\label{def:reification}
The \emph{reification of worlds}, $\reifyW{.}: \Worlds \rightarrow \pset{\Heaps}$ is defined as:
%
\[
	\reifyW{(l, g, \gmod, \lmod)} \eqdef \heapPart{(l \composeL g)}
\]
%
\end{definition}
%
%
\begin{definition}[Valid triple] A triple is \emph{valid}, written $|= \{P\} C \{Q\}$, iff for all $\lenv \in \LEnv$, $w \in  \Worlds$ and  $\h{}, \h{}' \in \Heaps$,
%
\[
\begin{array}{l l}
	\text{if} & w, \lenv |= P  \land \h{} \in \reifyW{w} \land C, \h{} \rightarrow^{\text{*}} \li{skip}, \h{}' \\
	
	\text{then} & \exsts{w'} w', \lenv |= Q \land \h{}' \in \reifyW{w'}
\end{array}
\]
%
\end{definition}
%
%
%
%
\begin{theorem}[Soundness]
%
The \colosl\ program logic is sound. That is, if $|-\!\{P\} C \{Q\}$ then $|=\!\{P\} C \{Q\}$.
%
\begin{proof}(Sketch)
We build the \colosl\ program logic on top of the views framework~\cite{views} and provide the full details of  how we instantiate the framework in~\cite{colosl-tr14}. To establish the soundness of \colosl, it then suffices to show that the atomic triple in the conclusion of (\proofRule{Atom}) rule is valid; the full proof is presented in~\cite{colosl-tr14}. 
\renewcommand{\qed}{}
\end{proof}
%
\end{theorem}
%
%
%\subsection{Axiomatisation of \colosl principles}

%\paragraph{Action shifting}
%We do not give the semantic model of interferences here. Instead, we
%give rules that reduce it to logical entailments. We delay the
%semantic definitions until \S\ref{sec:soundness}, in which we will
%show that the rules we propose here are indeed sound.
