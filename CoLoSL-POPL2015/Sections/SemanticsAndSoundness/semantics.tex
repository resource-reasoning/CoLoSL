\section{\colosl rules}

\subsection{Rely, Guarantee, Stability}
%
\azaleacomment{add the projections $\heapPart{.}, \capPart{.}$ to the definition of logical states.}
%
\paragraph{Stability}
An assertion is \emph{stable} if and only if it cannot be falsified by the interference from other threads in the environment. That is, for all possible updates that the environment can do, the assertion must remain true. To capture the interference of the environment, we define the Rely relation.
\begin{definition}[Rely] The \emph{Rely} relation $\rely: \pset{\Worlds \times \Worlds}$ is defined as 
%
\[
	\rely \eqdef  \left(\updateR \cup \extendR \cup \shiftR \right)^{\text{*}}
\]
%
where * denotes the reflexive transitive closure and 
%
\[
\begin{array}{@{} r @{} l @{}}
	\extendR \eqdef &
 	\left\{
	\begin{array}{@{} l @{\hspace*{2pt}} | @{\hspace*{2pt}} r @{}}
	   \left(
	   \begin{array}{@{} l @{}}
	     (l , s, \amod{}, \amod{L}),\\
 	     \left(
	     \begin{array}{@{} l @{}}
	      l,
	      s \composeL s',\\
	      \amod{}', \amod{L} \cup \amod{0}
	     \end{array}
 	    \right)
	   \end{array}
 	  \right)
	   &
 	  	\begin{array}{@{} l @{}}
%	 	  	s' = l' \composeL (\unitH, \ca{2})  \land\\
	 	  	
	 	  	\capPart{s'} \subseteq \dom{\amod{0}} \cup \dom{\amod{L}} \land \\
	 	  	
			\extendsAM{\amod{}', \amod{L} \cup \amod{0}}{s'}{s}{\amod{0}} \land \\
			
			\for{l_1, r, \amod{1} \subseteq \amod{L}} \\
			\hspace*{0.1cm} l_1 \composeL r = s \land \extendsAM{\amod{}, \amod{L}}{l_1}{r}{\amod{1}}  \\
			\hspace*{0.1cm} \implies\extendsAM{\amod{}', \amod{L} \cup \amod{0}}{l_1}{r \composeL s'}{\amod{1}}
			
     	
   		\end{array}
 	\end{array}
	\right\}\\
	
	
	
	\updateR \eqdef &
 	\left\{
	\begin{array}{@{} l @{\hspace*{2pt}} | @{\hspace*{2pt}} r @{}}
	   	\left(
	   	\begin{array}{@{} l @{}}
	     	(l, s, \amod{}, \amod{L}),\\
	     	(l, s', \amod{}, \amod{L})
	   	\end{array}
		\right)
	  	&
	  	\begin{array}{@{} l @{} }
		  	\left(
		  	\begin{array}{@{} l @{} }
		 		s = s' \lor\\

		 	  	\begin{array}{@{} l @{}}
		 	  		\exsts{\ca{} }\left( \capPart{l} \composeCap \capPart{s} \right) \disjoint \ca{} \land 
		 	  		(s, s') \in \amod{}(\ca{}) \\
		 	  	
		 	  	\end{array}	

		 	\end{array}
	   		\right)
   		\end{array}
 	\end{array}
	\right\}\\
	
	
	
	\shiftR \eqdef & 
	\left\{
	\begin{array}{@{} l @{\hspace*{2pt}} | @{\hspace*{2pt}} r @{}}
	   \left(
	   \begin{array}{@{} l @{}}
	     (l, s, \amod{}, \amod{L}),\\
 	     \left( l, s, \amod{}, \amod{L} \cup \amod{0}  \right)
	   \end{array}
 	  \right)
	   &
 	  	\begin{array}{@{} l @{}}
	 	  	\for{l, r} \for{\amod{}' \subseteq \amod{L}} \extendsAM{\amod{}, \amod{L}}{l}{r}{\amod{}'} \\
	 	  	\hspace*{0.5cm} \implies \extendsAM{\amod{}, \amod{L} \cup \amod{0}}{l}{r}{\amod{}'}
   		\end{array}
 	\end{array}
	\right\}

\end{array}
\]
%
\end{definition}
%
Intuitively, the Rely relation describes all possible updates by the environment. At any one point, a thread in the environment may extend the shared state with additional resources ($s'$), introduce new interference to describe how the new resources can be manipulated ($\amod{0}$) and consequently rewrite the global action model ($\amod{}'$). This is captured by the \extendR\ relation. For this to be possible, the resultant action model pair $(\amod{}', \amod{L} \cup \amod{0})$ must be closed under the newly added resources and interference: $\extendsAM{\amod{}', \amod{L} \cup \amod{0}}{s'}{s}{\amod{0}}$. Additionally, for all subjective state $l_1$, context $r$ and action model $\amod{1}$ under which the old action model pair was closed, the new action model pair must also  be closed when the context is extended with the new resources $\extendsAM{\amod{}', \amod{L} \cup \amod{0}}{l_1}{r \composeL s'}{\amod{1}}$. 

Moreover, at any one point the environment may update the shared state by performing an action for which it has the sufficient capability ($\ca{}$). This is described by the \updateR\ relation. For this to be possible, the thread performing the action must have the $\ca{}$ capability in its own local state and thus the $\ca{}$ capability must be disjoint from both shared and local states of the current world. 

Finally, the environment may extend the local action model by shifting (rewriting) some of the existing behaviour. This is modelled by the \shiftR\ relation. This is only possible if for any subjective state $l$, context $r$ and action model $\amod{}'$ under which the old action model pair was closed, the new action model pair is also closed: $\extendsAM{\amod{}, \amod{L} \cup \amod{0}}{l}{r}{\amod{}'}$. 

The rely $\rely$ enables us to define the stability of assertions with respect to the environment actions.
%
\begin{definition}[Stability] An assertion $P$ is stable ($\stable{P}$) iff for all $\lenv \in \LEnv$ and $w, w' \in \Worlds$, if $w \in \sem[\lenv]{P}$ and $(w, w') \in \rely$, then $w' \in \sem[\lenv]{P}$.
%\[	
%\begin{array}{r @{} l}
%	\stable{P} \iffdef &
%	\for{\lenv}\for{w, w'} \\
%	& w \in \sem[\lenv]{P} \land (w, w') \in \rely \implies
%	 w' \in \sem[\lenv]{P}
%\end{array}
%\]
\end{definition}
%
\begin{lemma}[Stability]
An assertion $P$ is stable if it cannot be falsified by possible updates on the shared state from other threads:
%
\[
\begin{array}{l}
	\for{\lenv}\for{w, w'} 
     w \in \sem[\lenv]{P} \land (w, w') \in \updateR \implies
	 w' \in \sem[\lenv]{P}\\
	 
	 \implies \stable{P}
\end{array}	 
\]
%
\end{lemma}
%
That is, an assertion $P$ is always stable with respect to possible extensions of the shared state and action shifting. For an assertion to be stable it thus suffices to consider the interference on the shared state from other threads.
%
\begin{definition}[Guarantee]
\[
\begin{array}{@{} r @{} l @{}}

	\extendG \eqdef &
 	\left\{
	\begin{array}{@{} l @{\hspace*{2pt}} | @{\hspace*{2pt}} r @{}}
	   \left(
	   \begin{array}{@{} l @{}}
	     (l \composeL l', s, \amod{}, \amod{L}),\\
 	     \left(
	     \begin{array}{@{} l @{}}
	      l \composeL (\unitH, \ca{1}),\\
	      s \composeL s',\\
	      \amod{}', \amod{L} \cup \amod{0}
	     \end{array}
 	    \right)
	   \end{array}
 	  \right)
	   &
 	  	\begin{array}{@{} l @{}}
	 	  	s' = l' \composeL (\unitH, \ca{2})  \land\\
	 	  	
	 	  	\ca{1} \composeCap \ca{2} \subseteq \dom{\amod{0}} \land \\
	 	  	
	 	  	\{\ca{1} \composeCap \ca{2}\} \disjoint \dom{\amod{L}} \land \\
	 	  	
			\extendsAM{\amod{}', \amod{L} \cup \amod{0}}{s'}{s}{\amod{0}} \land \\
			
			\for{l_1, r_1, \amod{1} \subseteq \amod{L}} \\
			\hspace*{0.1cm} l_1 \composeL r_1 = s \land \extendsAM{\amod{}, \amod{L}}{l_1}{r_1}{\amod{1}}  \\
			\hspace*{0.1cm} \implies\extendsAM{\amod{}', \amod{L} \cup \amod{0}}{l_1}{r_1 \composeL s'}{\amod{1}}
			
     	
   		\end{array}
 	\end{array}
	\right\}\\
	
	\updateG \eqdef &
 	\left\{
	\begin{array}{@{} l @{\hspace*{2pt}} | @{\hspace*{2pt}} r @{}}
	   	\left(
	   	\begin{array}{@{} l @{}}
	     	(l, s, \amod{}, \amod{L}),\\
	     	(l', s', \amod{}, \amod{L})
	   	\end{array}
		\right)
	  	&
	  	\begin{array}{@{} l @{} }
	  		\capPart{(l' \composeL s')}  \subseteq \capPart{(l \composeL s)} \land\\
		  	\left(
		  	\begin{array}{@{} l @{} }
		 		s = s' \lor\\
		 	  	\left(
		 	  	\begin{array}{@{} l @{}}
		 	  		\exsts{\ca{} \subseteq \capPart{l}}
		 	  		(s, s') \in \amod{}(\ca{}) \land\\
		 	  	
		 	  	\heapSize{\heapPart{\left(l \composeL s\right)}} = 
		 	  	\heapSize{\heapPart{\left(l' \composeL s'\right)}}
		 	  	\end{array}	
		 	  	\right)
		 	\end{array}
	   		\right)
   		\end{array}
 	\end{array}
	\right\}\\
	
	
	
	\shiftG \eqdef & 
	\left\{
	\begin{array}{@{} l @{\hspace*{2pt}} | @{\hspace*{2pt}} r @{}}
	   \left(
	   \begin{array}{@{} l @{}}
	     (l, s, \amod{}, \amod{L}),\\
 	     \left( l, s, \amod{}, \amod{L} \cup \amod{0}  \right)
	   \end{array}
 	  \right)
	   &
 	  	\begin{array}{@{} l @{}}
	 	  	\for{l, r} \for{\amod{}' \subseteq \amod{L}} \extendsAM{\amod{}, \amod{L}}{l}{r}{\amod{}'} \\
	 	  	\hspace*{0.5cm} \implies \extendsAM{\amod{}, \amod{L} \cup \amod{0}}{l}{r}{\amod{}'}
   		\end{array}
 	\end{array}
	\right\}\\\\
	
	\guarantee \eqdef & \left( \updateG \cup \extendG \cup \shiftG \right)^{*} \\\\
\end{array}
\]
%
\end{definition}
%
%

%%%
%\begin{definition}[Repartitioning]
%%
%\[
%\begin{array}{@{} r l @{}}
%	\repartitions{P}{Q}{\heapAss{1}}{\heapAss{2}} \iffdef 
%	& \for{\lenv} \repartitions{\sem[\lenv]{P}}{\sem[\lenv]{Q}}{\semH[\lenv]{\heapAss{1}}}{\semH[\lenv]{\heapAss{2}}}\\\\
%	
%	\repartitions{W_1}{W_2}{H_{1}}{H_{2}} \iffdef &
%	\begin{array}{l}
%		\for{w_1 \in W_1} \exsts{h_1 \in H_1\ , h'}\\
%		\hspace*{0.5cm} h_1 \composeH h' = \heapPart{(\collapseW{w_1})} \;\land\\
%		\hspace*{0.5cm} \for{h_2 \in H_2} \exsts{w_2 \in W_2}\\
%		\hspace*{1cm} h_2 \composeH h' = \heapPart{(\collapseW{w_2})} \;\land\; (w_1, w_2) \in \guarantee
%	\end{array}
%\end{array}
%\]
%%
%\end{definition}
%%

%TODO: include this: In particular,
%an action whose precondition is satisfiable is always enabled from the
%empty subjective assertion (which by definition is compatible with all
%other states). 


\subsection{Program logic}

\paragraph{Programming language}

\paragraph{Proof rules}
Explain atomic rule. Others are standard.



\subsection{Soundness}
\label{sec:soundness}


\subsection{Axiomatisation of \colosl principles}

\paragraph{Action shifting}
We do not give the semantic model of interferences here. Instead, we
give rules that reduce it to logical entailments. We delay the
semantic definitions until \S\ref{sec:soundness}, in which we will
show that the rules we propose here are indeed sound.

\begin{figure}
\hrule\vspace*{5pt}
\[
\begin{array}{c }
\infer{
%	\shared{R}{ I \cup \left\{ \capAss{}: P \swap Q\right\}} \sentails 
%	\shared{R}{ I \cup \left\{ \capAss{}: \bigcup\limits_{i \in J} P * R_i \swap Q * R_i \right\}} 	
	\left( I \cup \left\{ \capAss{}: P \swap Q\right\}\right) \weakenI{R} \left( I \cup \left\{ \capAss{}: \bigcup\limits_{i \in J} P * R_i \swap Q * R_i \right\} \right) 	
}
{	
    R \entails \fenceAss{} 
	& \fenceAss{} \fences I \cup \left\{ \capAss{}: P \swap Q\right\}
	&\bigwedge\limits_{i \in J} \exact{R_i}\\
	& \fenceAss{} \sepish P \vdash \bigvee\limits_{i \in J} \fenceAss{} \sepish \left(P * R_i \right)
}
\\\\
\infer{
%	\shared{R}{ I \cup \left\{ \capAss{}: P \swap Q\right\}} \sentails 
%	\shared{R}{I} 	
	\left(I \cup \left\{ \capAss{}: P \swap Q\right\}\right) \weakenI{R} 
	I 	
}{
	R \entails \fenceAss{} 
	& \fenceAss{} \fences  I \cup \left\{ \capAss{}: P \swap Q\right\}
	&\exact{\fenceAss{} \intersect Q}\\
	& \fenceAss{} \intersect P \vdash \fenceAss{} \intersect Q
}\\\\
\infer{	
	\left(I \cup \left\{ \capAss{}: P \swap Q\right\}\right) \weakenI{R} 
	I 	
}{
	R \entails \fenceAss{} 
	& \fenceAss{} \fences  I \cup \left\{ \capAss{}: P \swap Q\right\}
	&F \sepish Q \entails \m{false}
}
\end{array}
\]
\hrule\vspace*{5pt}
\caption{Action shifting rules.}
\label{fig:shiftRules}
\end{figure}
