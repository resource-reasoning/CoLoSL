\section{\colosl rules}

\subsection{Rely, Guarantee, Stability}
%
%
\paragraph{Stability}
An assertion is \emph{stable} if and only if it cannot be falsified by the interference from other threads in the environment. That is, for all possible updates that the environment can do, the assertion must remain true. To capture the interference of the environment, we define the Rely relation.
%
%
\todo\ explain what this is and when we need it.
\begin{definition}[Action Model Extension]
An action model $\amod{}'$ \emph{extends}  ($s, \amod{}, \amod{L}$) with $(\amod{n}, s')$, written $\expandsAM{\amod{}'}{\amod{n}}{s'}{s}{\amod{}}{\amod{L}}$, iff for all $\amod{0} \subseteq \amod{L}$ and $l, r$ such that $l \composeL r = s$:
%
\[
	\extendsAM{\amod{}, \amod{L}}{l}{r}{\amod{0}} \implies \extendsAM{\amod{}', \amod{L} \cup \amod{n}}{l}{r\composeL s'}{\amod{0}}
\]
%
\end{definition}
%
%
\begin{definition}[Rely] The \emph{Rely} relation $\rely: \pset{\Worlds \times \Worlds}$ is defined as 
%
\[
	\rely \eqdef  \left(\updateR \cup \extendR \cup \shiftR \right)^{\text{*}}
\]
%
where * denotes the reflexive transitive closure and 
%
\[
\begin{array}{@{} r @{} l @{}}
	\extendR \eqdef &
 	\left\{
	\begin{array}{@{} l @{\hspace*{2pt}} | @{\hspace*{2pt}} r @{}}
	   \left(
	   \begin{array}{@{} l @{}}
	     (l , s, \amod{}, \amod{L}),\\
 	     \left(
	     \begin{array}{@{} l @{}}
	      l,
	      s \composeL s',\\
	      \amod{}', \amod{L} \cup \amod{n}
	     \end{array}
 	    \right)
	   \end{array}
 	  \right)
	   &
 	  	\begin{array}{@{} l @{}}
%	 	  	s' = l' \composeL (\unitH, \ca{2})  \land\\
	 	  	
	 	  	\capPart{s'} \subseteq \dom{\amod{n}} \cup \dom{\amod{L}} \land \\
	 	  	
			\extendsAM{\amod{}', \amod{L} \cup \amod{n}}{s'}{s}{\amod{n}} \land \\
			
%			\for{l_1, r, \amod{1} \subseteq \amod{L}} \\
%			\hspace*{0.1cm} l_1 \composeL r = s \land \extendsAM{\amod{}, \amod{L}}{l_1}{r}{\amod{1}}  \\
%			\hspace*{0.1cm} \implies\extendsAM{\amod{}', \amod{L} \cup \amod{0}}{l_1}{r \composeL s'}{\amod{1}}
			
			\expandsAM{\amod{}'}{\amod{n}}{s'}{s}{\amod{}}{\amod{L}}
			
     	
   		\end{array}
 	\end{array}
	\right\}\\
	
	
	
	\updateR \eqdef &
 	\left\{
	\begin{array}{@{} l @{\hspace*{2pt}} | @{\hspace*{2pt}} r @{}}
	   	\left(
	   	\begin{array}{@{} l @{}}
	     	(l, s, \amod{}, \amod{L}),\\
	     	(l, s', \amod{}, \amod{L})
	   	\end{array}
		\right)
	  	&
	  	\begin{array}{@{} l @{} }
%		  	\left(
%		  	\begin{array}{@{} l @{} }
%		 		s = s' \lor\\

		 	  	\begin{array}{@{} l @{}}
		 	  		\exsts{\ca{} }\left( \capPart{l} \composeCap \capPart{s} \right) \disjoint \ca{} \land 
		 	  		(s, s') \in \amod{}(\ca{}) \\
		 	  	
		 	  	\end{array}	

%		 	\end{array}
%	   		\right)
   		\end{array}
 	\end{array}
	\right\}\\
	
	
	
	\shiftR \eqdef & 
	\left\{
	\begin{array}{@{} l @{\hspace*{2pt}} | @{\hspace*{2pt}} r @{}}
	   \left(
	   \begin{array}{@{} l @{}}
	     (l, s, \amod{}, \amod{L}),
 	     \left( l, s, \amod{}, \amod{L} \cup \amod{n}  \right)
	   \end{array}
 	  \right)
	   &
% 	  	\begin{array}{@{} l @{}}
%	 	  	\for{l, r} \for{\amod{}' \subseteq \amod{L}} \extendsAM{\amod{}, \amod{L}}{l}{r}{\amod{}'} \\
%	 	  	\hspace*{0.5cm} \implies \extendsAM{\amod{}, \amod{L} \cup \amod{0}}{l}{r}{\amod{}'}
%   		\end{array}

		\expandsAM{\amod{}}{\amod{n}}{\unitL}{s}{\amod{}}{\amod{L}}
 	\end{array}
	\right\}

\end{array}
\]
%
\end{definition}
%
Intuitively, the Rely relation describes all possible updates by the environment. At any one point, a thread in the environment may extend the shared state with additional resources ($s'$), introduce new interference to describe how the new resources can be manipulated ($\amod{0}$) and consequently rewrite the global action model ($\amod{}'$). This is captured by the \extendR\ relation. For this to be possible, the resultant action model pair $(\amod{}', \amod{L} \cup \amod{0})$ must be closed under the newly added resources and interference: $\extendsAM{\amod{}', \amod{L} \cup \amod{0}}{s'}{s}{\amod{0}}$. Additionally, for all subjective state $l_1$, context $r$ and action model $\amod{1}$ under which the old action model pair was closed, the new action model pair must also  be closed when the context is extended with the new resources $\extendsAM{\amod{}', \amod{L} \cup \amod{0}}{l_1}{r \composeL s'}{\amod{1}}$. 

Moreover, at any one point the environment may update the shared state by performing an action for which it has the sufficient capability ($\ca{}$). This is described by the \updateR\ relation. For this to be possible, the thread performing the action must have the $\ca{}$ capability in its own local state and thus the $\ca{}$ capability must be disjoint from both shared and local states of the current world. 

Finally, the environment may extend the local action model by shifting (rewriting) some of the existing behaviour. This is modelled by the \shiftR\ relation. This is only possible if for any subjective state $l$, context $r$ and action model $\amod{}'$ under which the old action model pair was closed, the new action model pair is also closed: $\extendsAM{\amod{}, \amod{L} \cup \amod{0}}{l}{r}{\amod{}'}$. 

The rely $\rely$ enables us to define the stability of assertions with respect to the environment actions.
%
\begin{definition}[Stability] An assertion $P$ is stable ($\stable{P}$) iff for all $\lenv \in \LEnv$ and $w, w' \in \Worlds$, if $w \in \sem[\lenv]{P}$ and $(w, w') \in \rely$, then $w' \in \sem[\lenv]{P}$.
%\[	
%\begin{array}{r @{} l}
%	\stable{P} \iffdef &
%	\for{\lenv}\for{w, w'} \\
%	& w \in \sem[\lenv]{P} \land (w, w') \in \rely \implies
%	 w' \in \sem[\lenv]{P}
%\end{array}
%\]
\end{definition}
%
\begin{lemma}[Stability]
An assertion $P$ is stable if it cannot be falsified by possible updates on the shared state from other threads:
%
\[
\begin{array}{l}
	\for{\lenv}\for{w, w'} 
     w \in \sem[\lenv]{P} \land (w, w') \in \updateR \implies
	 w' \in \sem[\lenv]{P}\\
	 
	 \implies \stable{P}
\end{array}	 
\]
%
\end{lemma}
%
That is, an assertion $P$ is always stable with respect to possible extensions of the shared state and action shifting. For an assertion to be stable it thus suffices to consider the interference on the shared state from other threads.

We now define the Guarantee relation  that describes all possible updates the current thread can perform. Intuitively, the Guarantee relation is the dual of Rely.
%
\begin{definition}[Guarantee]
The \emph{Guarantee} relation $\guarantee: \powerset (\Worlds \times \Worlds)$ is defined as
%
\[
	\guarantee \eqdef  \left( \updateG \cup \extendG \cup \shiftG \right)^{\text{*}}
\]
%
with
%
\[
\begin{array}{@{} r @{} l @{}}

	\extendG \eqdef &
 	\left\{
	\begin{array}{@{} l @{\hspace*{2pt}} | @{\hspace*{2pt}} r @{}}
	   \left(
	   \begin{array}{@{} l @{}}
	     (l \composeL l', s, \amod{}, \amod{L}),\\
 	     \left(
	     \begin{array}{@{} l @{}}
	      l \composeL (\unitH, \ca{1}),\\
	      s \composeL s',\\
	      \amod{}', \amod{L} \cup \amod{n}
	     \end{array}
 	    \right)
	   \end{array}
 	  \right)
	   &
 	  	\begin{array}{@{} l @{}}
	 	  	s' = l' \composeL (\unitH, \ca{2})  \land\\
	 	  	
	 	  	\ca{1} \composeCap \ca{2} \subseteq \dom{\amod{n}} \land \\
	 	  	
	 	  	\ca{1} \composeCap \ca{2} \disjoint \dom{\amod{L}} \land \\
	 	  	
			\extendsAM{\amod{}', \amod{L} \cup \amod{n}}{s'}{s}{\amod{n}} \land \\
			
%			\for{l_1, r_1, \amod{1} \subseteq \amod{L}} \\
%			\hspace*{0.1cm} l_1 \composeL r_1 = s \land \extendsAM{\amod{}, \amod{L}}{l_1}{r_1}{\amod{1}}  \\
%			\hspace*{0.1cm} \implies\extendsAM{\amod{}', \amod{L} \cup \amod{0}}{l_1}{r_1 \composeL s'}{\amod{1}}

			\expandsAM{\amod{}'}{\amod{n}}{s'}{s}{\amod{}}{\amod{L}}
			
     	
   		\end{array}
 	\end{array}
	\right\}\\
	
	\updateG \eqdef &
 	\left\{
	\begin{array}{@{} l @{\hspace*{2pt}} | @{\hspace*{2pt}} r @{}}
	   	\left(
	   	\begin{array}{@{} l @{}}
	     	(l, s, \amod{}, \amod{L}),\\
	     	(l', s', \amod{}, \amod{L})
	   	\end{array}
		\right)
	  	&
	  	\begin{array}{@{} l @{} }
	  		\capPart{(l' \composeL s')}  \subseteq \capPart{(l \composeL s)} \land\\
		  	\left(
		  	\begin{array}{@{} l @{} }
		 		s = s' \lor\\
		 	  	\left(
		 	  	\begin{array}{@{} l @{}}
		 	  		\exsts{\ca{} \subseteq \capPart{l}}
		 	  		(s, s') \in \amod{}(\ca{}) \land\\
		 	  	
		 	  	\heapSize{\heapPart{\left(l \composeL s\right)}} \subseteq 
		 	  	\heapSize{\heapPart{\left(l' \composeL s'\right)}}
		 	  	\end{array}	
		 	  	\right)
		 	\end{array}
	   		\right)
   		\end{array}
 	\end{array}
	\right\}\\
	
	
	
	\shiftG \eqdef & 
	\left\{
	\begin{array}{@{} l @{\hspace*{2pt}} | @{\hspace*{2pt}} r @{}}
	   \left(
	   \begin{array}{@{} l @{}}
	     (l, s, \amod{}, \amod{L}),
 	     \left( l, s, \amod{}, \amod{L} \cup \amod{0}  \right)
	   \end{array}
 	  \right)
	   &
	   
	   \expandsAM{\amod{}}{\amod{n}}{\unitL}{s}{\amod{}}{\amod{L}}
% 	  	\begin{array}{@{} l @{}}
%	 	  	\for{l, r} \for{\amod{}' \subseteq \amod{L}} \extendsAM{\amod{}, \amod{L}}{l}{r}{\amod{}'} \\
%	 	  	\hspace*{0.5cm} \implies \extendsAM{\amod{}, \amod{L} \cup \amod{0}}{l}{r}{\amod{}'}
%   		\end{array}
 	\end{array}
	\right\}

\end{array}
\]
%
\end{definition}
%
%
The current thread may at any point extend the shared state with some of its locally held resources $l'$ and in doing so introduce new interference to describe how the new resources may be mutated ($\amod{0}$) and generate  new capabilities ($\ca{1} \composeCap \ca{2} \subseteq \dom{\amod{0}}$) that facilitate the new interference. This is captured by the \extendG\ relation and is analogous to \extendR.  The generated capabilities must be fresh ($\ca{1} \composeCap \ca{2}  \disjoint \dom{\amod{L}}$). The last two conjunct are to enforce the closure of the new action models and can be justified as in the case of \extendR.

The current thread can update its local state arbitrarily and may update the shared state by performing an action for which it holds the necessary capability $\ca{}$ in its local state. This is described by the \updateG\ relation. For this to be possible, the total amount of capabilities held locally and in the shared state must not grow. That is, the current thread may not generate new capabilities arbitrarily since capabilities may only be generated upon extension of the shared state as captured in \extendG. Similarly, if the shared state is being updated ($s \not= s'$),  then the heap resources (the domain of the heap) may not grow ($\heapSize{\heapPart{(l \composeL s)}} \subseteq \heapSize{\heapPart{(l' \composeL s')}}$) where the $\heapSize{.}$ function is as given in \defin\ref{def:orthogonal}. The intuition behind this constraint is to ensure that threads do not generate resources out of thin air in order to enable actions. Note that this does not stop a thread from local allocation/deallocation of resources. In the case of allocation, the desired effect can be achieved by first allocating the new resources locally (\textit{i.e.} extending the local state from $l$ to $l \composeL l''$), while leaving the shared state untouched; and then performing the relevant action on the shared state (\textit{i.e.} updating $s$ to $s'$) without extending the heap resources, as illustrated in the following sequence.
%
\[
\begin{array}{l}
	(l, s, \amod{}, \amod{L}) \rightarrow (l \composeL l'', s, \amod{}, \amod{L}) \rightarrow (l', s', \amod{}, \amod{L})\\
	\text{ where } \heapSize{\heapPart{(l \composeL l'' \composeL s)}} \subseteq \heapSize{\heapPart{(l' \composeL s')}}
\end{array}
\]
%
Deallocation of local resources can be achieved in a similar fashion.
%That is, all previously compatible frames remain compatible. We illustrate the need for this constraint in \ex ~\ref{ex:compatibleFrames}.

Lastly, the current thread may extend the local action model by shifting some of the existing interference. This is modelled by the \shiftG\ relation and is analogous to \shiftR.
%
%
\begin{definition}[Orthogonal]\label{def:orthogonal}
The \emph{orthogonal} of a heap  $\heapSize{.}: \Heaps \rightarrow \pset{\Heaps}$ is defined as the set of all heaps that are disjoint from it. That is, given a heap $m \in \Heaps$:
%
\[
	\heapSize{m} \eqdef \left\{ m' \mid m \disjoint m' \right\}
\]
%
\end{definition}
%
Using the guarantee relation, we introduce the notion of \emph{repartitioning} a state that satisfies $P$ to one satisfying $Q$ with respect to an update from $p$ to $q$, written $\repartitions{P}{Q}{p}{q}$. While the guarantee states how a thread can modify the shared state, extend it or shift the interference, repartitioning describes how the local and shared \emph{heaps} are updated in such a way that is compatible with the guarantee as well as the update from $p$ to $q$.
%
\begin{definition}[Repartitioning] $\repartitions{P}{Q}{p}{q}$ holds iff for every $\lenv \in \LEnv$, and world $w_1$ where $w_1, \lenv |= P$, there exists a state $m_1 \in \Heaps$ where $(m_1, \emptyset), \lenv \slsat p$ and a residual state $m'$ such that 
%
\begin{itemize} 
	\item $m_1 \composeH m' = \heapPart{\left(\collapseW{w_1}\right)}$; and
	\item for every $m_2$ where $(m_2, \emptyset), \lenv \slsat q$, there exists a world $w_2$ where $w_2, \lenv |= Q$ such that:
	\begin{itemize}
		\item $m_2 \composeH m' = \heapPart{\left(\collapseW{w_2}\right)}$; and
		\item $(w_1, w_2) \in \guarantee$
	\end{itemize}	  
\end{itemize}
%
where $\collapseW{l, s, \amod{}, \amod{L}} \eqdef l \composeL s$.

Note that when $p = q = \emp$, then the repartitioning has no side effect in that it preserves the concrete state and only allows the world to be repartitioned. We write $P \semimplies Q$ for $\repartitions{P}{Q}{\emp}{\emp} $.
%\[
%\begin{array}{@{} r l @{}}
%	\repartitions{P}{Q}{p}{q} \iffdef 
%	& \for{\lenv} \repartitions{\sem[\lenv]{P}}{\sem[\lenv]{Q}}{\semH[\lenv]{\heapAss{1}}}{\semH[\lenv]{\heapAss{2}}}\\\\
%	
%	\repartitions{W_1}{W_2}{H_{1}}{H_{2}} \iffdef &
%	\begin{array}{l}
%		\for{w_1 \in W_1} \exsts{h_1 \in H_1\ , h'}\\
%		\hspace*{0.5cm} h_1 \composeH h' = \heapPart{(\collapseW{w_1})} \;\land\\
%		\hspace*{0.5cm} \for{h_2 \in H_2} \exsts{w_2 \in W_2}\\
%		\hspace*{1cm} h_2 \composeH h' = \heapPart{(\collapseW{w_2})} \;\land\; (w_1, w_2) \in \guarantee
%	\end{array}
%\end{array}
%\]
%%
\end{definition}
%

%TODO: include this: In particular,
%an action whose precondition is satisfiable is always enabled from the
%empty subjective assertion (which by definition is compatible with all
%other states). 


\subsection{Program logic}
We build the \colosl\ program logic on top of the views framework~\cite{views} instantiated as follows. The view semigroup is the separation algebra of worlds as described in \defin\ref{todo}. 
The machine states and the reification of worlds are as given in \defin\ref{def:machineStates} and \ref{def:reification}\footnote{
Generally, since \colosl\ is parametric in the separation algebra of heaps, the set of machine states and the reification function over heaps are also parameterised. Further details can be found in~\cite{colosl-tr14}.
}. 
The grammar of \colosl\ atomic commands is provided in \defin\ref{def:atomicCommands}; we show the soundness of \colosl\ atomic commands in the companion technical report~\cite{colosl-tr14}. 
The axiomatisation of \colosl\ atomic commands are as per \defin\ref{todo}.
%
%
\begin{definition}[Machine States]\label{def:machineStates}
The set of \colosl\ \emph{Machine States} are $\MStates \eqdef \Heaps$.
\end{definition}
%
%
\begin{definition}[Reification]\label{def:reification}
The \emph{reification of worlds}, $\reifyW{.}: \Worlds \rightarrow \pset{\MStates}$ is defined as:
%
\[
	\reifyW{(l, l_s, \amod{}, \amod{L})} \eqdef \heapPart{(l \composeL l_s)}
\]
%
\end{definition}
%
%
\paragraph{Programming language}
 We use the programming language of the views framework \cite{views} instantiated with a set of atomic commands. \colosl\ is parametric in the set of atomic commands: we provide an atomic construct $\atomic{.}$ that can be applied to any sequential command and enforce atomic behaviour. We proceed with the grammar of \colosl atomic commands.
%
\begin{definition}[Atomic commands]\label{def:atomicCommands}
The \emph{atomic commands} of \colosl\, $\atom{} \in \Atoms$ are defined by the following grammar.
%
\begin{mathpar}
	\atom{} ::= \atomic{\seq{}}
	
	\seq{} ::= \bc{} \mid \li{skip} \mid \seq{1};\seq{2} \mid \seq{1}+\seq{2} \mid \seq{}^{\text{*}}
\end{mathpar}
%
where $\bc{} \in \Basics$ denotes a set of basic commands that can be instantiated with any set of sequential commands. In the examples of this paper, our basic commands are given by the following grammar.
%
\[
\bc{} ::= \li{x}:= E \mid \li{assume}(E)
\]
%
\end{definition}
\paragraph{Proof rules}
Our proof rules are of the form $\entails \{P\}\ C\ \{Q\}$ and carry an implicit assumption that the pre- and post-conditions of their judgements are stable. Most of the proof rules are standard as described in \cite{views} with the exception of the atomic and consequence rules. We proceed with the judgements of these rules.
%
%
\begin{definition}[Proof rules]\label{def:proofRule}

\end{definition}


\subsection{Soundness}
\label{sec:soundness}


\subsection{Axiomatisation of \colosl principles}

\paragraph{Action shifting}
We do not give the semantic model of interferences here. Instead, we
give rules that reduce it to logical entailments. We delay the
semantic definitions until \S\ref{sec:soundness}, in which we will
show that the rules we propose here are indeed sound.

\begin{figure}
\hrule\vspace*{5pt}
\[
\begin{array}{c }
\infer{
%	\shared{R}{ I \cup \left\{ \capAss{}: P \swap Q\right\}} \sentails 
%	\shared{R}{ I \cup \left\{ \capAss{}: \bigcup\limits_{i \in J} P * R_i \swap Q * R_i \right\}} 	
	\left( I \cup \left\{ \capAss{}: P \swap Q\right\}\right) \weakenI{R} \left( I \cup \left\{ \capAss{}: \bigcup\limits_{i \in J} P * R_i \swap Q * R_i \right\} \right) 	
}
{	
    R \entails \fenceAss{} 
	& \fenceAss{} \fences I \cup \left\{ \capAss{}: P \swap Q\right\}
	&\bigwedge\limits_{i \in J} \exact{R_i}\\
	& \fenceAss{} \sepish P \vdash \bigvee\limits_{i \in J} \fenceAss{} \sepish \left(P * R_i \right)
}
\\\\
\infer{
%	\shared{R}{ I \cup \left\{ \capAss{}: P \swap Q\right\}} \sentails 
%	\shared{R}{I} 	
	\left(I \cup \left\{ \capAss{}: P \swap Q\right\}\right) \weakenI{R} 
	I 	
}{
	R \entails \fenceAss{} 
	& \fenceAss{} \fences  I \cup \left\{ \capAss{}: P \swap Q\right\}
	&\exact{\fenceAss{} \intersect Q}\\
	& \fenceAss{} \intersect P \vdash \fenceAss{} \intersect Q
}\\\\
\infer{	
	\left(I \cup \left\{ \capAss{}: P \swap Q\right\}\right) \weakenI{R} 
	I 	
}{
	R \entails \fenceAss{} 
	& \fenceAss{} \fences  I \cup \left\{ \capAss{}: P \swap Q\right\}
	&F \sepish Q \entails \m{false}
}
\end{array}
\]
\hrule\vspace*{5pt}
\caption{Action shifting rules.}
\label{fig:shiftRules}
\end{figure}
