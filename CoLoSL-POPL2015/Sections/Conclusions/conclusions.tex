
\subsection*{Related Work and Concluding Remarks}

Compositional reasoning about fine-grained concurrent algorithms is
essential for verifying large concurrent systems.  Jones introduced
global rely-guarantee thinking in his PhD
thesis~\cite{rg}, motivating the rely and guarantee relations given in
\S\ref{sec:semantics}. O'Hearn introduced local concurrent separation
reasoning~\cite{csl-tcs}, giving the disjoint concurrency rule
which underpins the reasoning presented here.  Since then, many
researchers 
have looked at more complex and finer-grained algorithms,
building on the combination of global and local  ideas arising from these papers:
examples include RGSep~\cite{viktor-marriage}, Local RG~\cite{lrg},
deny-guarantee~\cite{dg}, and the CAP
family~\cite{cap-ecoop10,icap,tada}, to name but a few. In addition,
the views framework~\cite{views} clarifies much of the basic assumptions associated
with this work: assertions provide disjoint 
\emph{views} of the concrete machine state for each thread, which
other threads cannot invalidate. 


One point of inspiration has come from CAP reasoning. 
CAP uses boxed assertions of the form $\capbox{P}{I}{r}$,
where the assertion $P$ describes a fixed disjoint  part of the global shared
state labelled by fixed region name  $r$, and the interference given by $I$ is also fixed. In contrast,
\colosl uses overlapping  subjective views $\shared{P}{I}$ with no region name, where
assertion $P$ now describes a flexible, overlapping part of the global
shared state, and there is a subtle dynamic relationship between this
$P$ and 
the flexible $I$. Subjective views  lead to simpler proofs, as 
illustrated by the concurrent set example in
\S\ref{sec:examples}. There are many interesting ideas present in the CAP
literature: e.g. abstract states~\cite{carasel}; higher-order
reasoning~\cite{icap}; and abstract atomicity~\cite{tada}. All these
ideas require further investigation. Here,  our aim was to simply  introduce 
subjective views as a 
fundamental new way of  underpinning of  such reasoning. 



Our merging of overlapping subjective views relies on the overlapping
conjunction introduced in~\cite{rey-slnotes,js-popl12,ramification}.
In~\cite{ramification}, a sequential spanning tree algorithm is
verified using a this connective. \colosl is naturally able to verify
a concurrent tree spanning algorithm where the overlapping of shared
subgraphs is key.



Finally, probably the work that is nearest in spirit to  \colosl is Local RG~\cite{lrg}. Here,  it is also
possible to use assertions  to describe unnamed parts of the shared region, albeit only
when the assertions cover disjoint parts of the shared state, and when
the interference on each sub-region are also disjoint. Moreover, Local
RG assertions are specified globally over the entire shared state, and
cannot be dynamically rewritten, in contrast with
\colosl. Nonetheless, both approaches share a similar goal of enabling
more compositional reasoning about the shared state.

%%  where the
%% reasoning is based on the combination of global rely-guarantee reasoning with
%% local separation logic based on one global shared state. 

%% taken inspiration from them. our set example better. 





%Future work: because we are able to specify shared state and
%interferences locally, there is hope that \colosl can be adapted to
%reason about distributed systems as well, as in our motivating example
%of \S\ref{sec:intuition}.

%\julescomment{This is a brain dump. Doesn't have to make it in the
 % submitted version.}

%One of the new paradigms of \colosl is the ability to manipulate the
%interference relation, via \emph{shifting}. The focus of this paper
%has largely been on manipulations of the spatial components of
%subjective views, and the treatment of shifting has been left at the
%minimum we needed to cover our range of examples. This opens the way
%to more fine-grained reasoning about interferences. For instance, a
%process who never receives a capability could safely over-approximate
%the corresponding interference. Conversely, a process who never gives
%a capability away could safely under-approximate the corresponding
%interference relation. In \colosl, this is not yet allowed, as
%interferences can only be shifted to equivalent ones, the only
%exception being the ability to forget actions that have no visible
%effect on the current subjective state. One could imagine tracking
%which process is allowed to own which capability to be more flexible
%in this instance. (if that can be useful at all?)
