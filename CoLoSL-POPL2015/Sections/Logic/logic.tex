\section{The \colosl logic}
\label{sec:logic}

We now introduce the program logic \colosl formally. Let us first give
the syntax and semantics of our assertion language.

\subsection{\colosl assertions}

\paragraph{Syntax}
Our assertions extend standard separation logic with \emph{subjective
  views}, as introduced in the previous section. \colosl is parametric
with respect to the heap and capability assertions and can be
instantiated with any assertion language so long as they are
interpreted over elements of a separation
algebra~\cite{asl,views}. For space reasons, we restrict the
exposition in this paper to \emph{heap assertions} and models, and to
sets of \emph{tokens} as capabilities. The parametric treatment of
\colosl assertions can be found in the companion technical
report~\cite{colosl-tr14}. We assume infinite disjoint sets
$\set{PVar}$, $\set{LVar}$, and $\set{Token}$ of program variables,
logical variables, and tokens, respectively.

\begin{definition}[Assertion syntax]
  \label{def:assertions}
  The assertions of \colosl are elements of $\Assertions$ described by
  the grammar below, where $\li x$ ranges over program variables, $x$
  over logical variables, and $\token a$ over tokens.
  \begin{align*}
    E &::= x ||| 0, 1, \ldots ||| E_1 + E_2 ||| \cdots\\
    \p{A} &::=\m{false} \mid E_1 = E_2 ||| \emp ||| \li{x}|-> E ||| E_1 |-> E_2 \mid [\token a]\\
    P, Q  &::= 
    \p{A} \mid P \Rightarrow Q \mid \exsts{x} P \mid
     P * Q \mid P --* Q \mid P \sepish Q% \mid P \intersect Q
     \mid \shared{P}{I} \\
    I &::= \emptyset ||| \interAss{\token a}{\vec{y}}{P}{Q}, I
  \end{align*}
\end{definition}

The syntax follows from standard separation logic with variables as
resource~\cite{entcs06} (notice that expressions $E$ do not allow
program variables), with the exception of shared-state assertions,
whose notation is borrowed from previous rely-guarantee-based
formalisms. Predicates and connectives from the first row have their
standard classical meaning, and spatial predicates and connectives
have been informally introduced in the previous section.

\paragraph{Program states}
To interpret formulas in our assertion language, we build models using
two ingredients. The first is \emph{logical states}, which are used to
describe resources held locally as well as those shared with other
threads.

\begin{definition}[Logical states]
  A \emph{logical state} is a triple $(s, h, \ca{})$ of a partial
  \emph{stack} $s\in\set{Stack}$, assigning values to program
  variables, a heap $h \in\Heaps$, represented as a finite partial
  functions from addresses to values, and a capability $\ca{}
  \in\Caps$.
  \begin{align*}
    \set{Stack} &== \set{PVar} --` \set{Val}&
    \Heaps &== \set{Loc} --`_{\m{fin}} \set{Val}&
    \Caps &== \powerset(\set{Token})\\
    &&\mathllap{\LStates} &== \Heaps\times \Caps
  \end{align*}
  We write $\unitL$ for the logical state $(\emptyset, \unitH, \unitCap)$. The
  \emph{composition of logical states}
  $
  \composeL : \LStates \times \LStates \rightharpoonup \LStates
  $
  is defined as:
  \[
  (s, h,\ca{}) \composeL (s', h', \ca{}') \eqdef
  (s\uplus s', h\composeH h', \ca{}\composeCap \ca{}')
  \]
\end{definition}
Although, for this presentation, we build logical states out of
stacks, heaps, and sets of tokens, the general setting allows any pair
(here we would group the stack and the heap as a single component) of
separation algebras (\textit{i.e.}, cancellative partial commutative
monoids~\cite{asl}) would do~\cite{colosl-tr14}.

In the following, we write $l_1\leq l_2$ when there exists $l$ such
that $l\composeL l_1 = l_2$. When that is the case, we also write $l_2
- l_1$ to denote the unique (by cancellativity) such $l$. When $l_1$
and $l_2$ are compatible according to $\composeL$, we write
$l_1\compatL l_2$.

The last ingredient are \emph{action models}, used to interpret
interference assertions.

\begin{definition}[Action models]
An \emph{action model} is a partial function from capabilities to
their semantic actions, expressed as relations between the logical
states:
\[
	\amod{} \in \AMods \eqdef \Caps \rightharpoonup \pset{\LStates \times \LStates}
\]
We write $\unitAM$ for an action model with empty domain.
\end{definition}


\begin{definition}[Worlds]
  A \emph{world} is a 4-tuple consisting of a logical state
  representing the thread-local state, a second logical state
  representing the shared state, a global action model and a local
  action model. Later in \S\ref{subsec:localGlobalActionModels}, we
  justify the need for both local and global action models. An extra
  \emph{well-formedness} condition is imposed on worlds, that ensures
  that the local and shared states are always compatible, and that the
  updates permitted by the action models are well-behaved with respect
  to future extensions of the shared state:
  \[
  \Worlds \eqdef \{w\in
  \LStates\times\LStates\times\AMods\times\AMods ||| \p{wf}(w)\}
  \]
  The \emph{composition of worlds} is defined as
  \begin{align*}
    &\qquad (l,l_s,\amod{},\amod{\ell}) \composeW
    (l',l_s',\amod{}',\amod{\ell}') \\
    &\eqdef
    \begin{cases}
      (l\composeL l', l_s, \amod{}, \amod{\ell}) &
      \begin{array}[t]{L}
        \text{if }
        l_s = l_s' \text{, }
        \amod{} = \amod{}' \text{, and } \amod{\ell} = \amod{\ell}'\\[-.7ex]
        \text{and }\p{wf}((s,l\composeL l', l_s, \amod{}, \amod{\ell}))
      \end{array}\\
      \textit{undefined}&\text{otherwise}
    \end{cases}
  \end{align*}
\end{definition}


\paragraph{Semantics}
We are now ready to give the semantics of \colosl assertions, defined
as a forcing relation $|=$ between worlds and formulas. We use two
auxiliary forcing relations. The first one, written $\slsat$,
interprets \emph{atomic} formulas $\p{A}$ in the usual separation
logic sense over a single logical state, while the other
$|=_{l,\amod{},\amod{\ell}}$ interprets assertions over a single
logical state representing a piece of shared state. Its three
parameters are a top-level shared state $l$ and action models
$\amod{}$ and $\amod{\ell}$. This third form of satisfaction is needed
to deal with nesting of boxed formulas.

Moreover, since logical connectives are interpreted uniformly in all
cases, we write $|=_{?}$ for either of the three satisfaction
relations, and then write $u$ for elements of either $\Worlds$ or
$\LStates$, and $\gray$ for either $\composeW$ or $\composeL$,
depending on whether the satisfaction relation is
$|=$, or either $\slsat$ or $|=_{l,\amod{},\amod{\ell}}$,
respectively.

\begin{definition}[Assertion semantics]
  Given a logical environment $\lenv\in\LEnv == \set{LVar} -->
  \set{Val}$, the semantics of \colosl assertions is as follows, where
  $\semI[(.)]{.}$ denotes the semantics of interference assertions
  described in \defin~\ref{def:interferenceSemantics}:
\[
\begin{array}{R>{\null}l@{\ \,}c@{\ \,}l}
  l,\lenv &\slsat \m{false}
  &\text{iff}& \text{never}\\
  l,\lenv &\slsat E_1 = E_2
  &\text{iff}& [|E_1|]_{\lenv} = [|E_2|]_{\lenv}\\
  l, \lenv &\slsat \emp &\text{iff}& l = \unitL\\
  l, \lenv &\slsat \li{x}|->E
  &\text{iff}&
  l =
  ([\li x: [|E|]_{\lenv}],\unitH,\unitCap)\\
  l, \lenv &\slsat E_1|->E_2 
  &\text{iff}&
  l =
  (\emptyset,[[|E_1|]_{\lenv}: [|E_2|]_{\lenv}],\unitCap)\\
  l, \lenv &\slsat [\token a]
  &\text{iff}&
  l = (\emptyset,\unitH, \{\token a\})\\
  l_s, \lenv &|=_{l,\amod{},\amod{\ell}} \p{A} &\text{iff}& l_s, \lenv |= \p{A}\\
  l_s, \lenv &|=_{l,\amod{},\amod{\ell}} \shared P I &\text{iff}&
  (l_s,l,\amod{},\amod{\ell}), \lenv |= \shared P I\\
  u,\lenv &|=_{?} P => Q
  &\text{iff}& u,\lenv |=_{?} P\text{ implies }u,\lenv |=_{?} Q\\
  u,\lenv &|=_{?} \exsts x P
  &\text{iff}& \exsts v u, [\lenv|||x:v] |=_{?} P\\
  u, \lenv &|=_{?} P_1 * P_2 &\text{iff}&
  \exsts{u_1,u_2} u = u_1\gray u_2\text{ and}\\
  &&& u_1, \lenv |=_{?} P_1 \text{ and }u_2, \lenv |=_{?} P_2\\
  u, \lenv &|=_{?} P --* Q &\text{iff}&
  \for{u'} u', \lenv |=_{?} P \text{ and }
  u \sharp u'\\
  &&&\text{ implies }u\gray u', \lenv |=_{?} Q\\
  u, \lenv &|=_{?} P_1 ** P_2 &\text{iff}&
  \exsts{u',u_1,u_2} u = u'\gray u_1\gray u_2\\
  &&&\text{ and }
  u'\gray u_1, \lenv |=_{?} P_1 \text{ and }\\
  &&&u'\gray u_2, \lenv |=_{?} P_2
\end{array}
\vspace{-.8em}
\]
\[
\begin{array}{R>{\null}l@{\ \,}c@{\ \,}l}
  (l,l_s,\amod{},\amod{\ell}), \lenv &|= \p{A} &\text{iff}& l,\lenv |= \p{A}\\
  (l,l_s,\amod{},\amod{\ell}), \lenv &|= \shared P I &\text{iff}&
  l = \unitH\text{ and }
  \exsts{l_s',r}
  l_s = l_s'\composeL r
  \text{ and}\\
  &&&l_s', \lenv |=_{l_s,\amod{},\amod{\ell}} P\text{ and }\\
  &&&\extendsAM{\amod{}, \amod{\ell}}{l_s'}{r}{\semI[\lenv]{I}}
\end{array}
\]
\end{definition}

The semantics of separation logic predicates and connectives is
standard and depends only on the local state.  $\shared{P}{I}$ states
that $P$ holds for only a sub-state $l_s'$ of the global shared state
$l_s'\composeL r$. The interference associated with $l_s'$ is given by
interference assertion $\semI[\lenv]{I}$ such that the global and
local action models $\amod{}$ and $\amod{\ell}$ are \emph{closed}
under $\semI[\lenv]{I}$ with respect to the subjective view $l_s'$ and
context $r$. This will be formalised in \S\ref{subsec:localGlobalActionModels}.
%Since shared state assertions are partial subjective description of the shared state, separating conjunction between them behaves as overlapping conjunction 

\begin{lemma}
  \label{lem:assertionFacts}
  The following formulas are valid according to the semantics above:
  \begin{align*}
  \shared{P * Q}{I} &=> \shared{P}{I}  \tag{\textsc{Forget}}\\
  \shared{P}{I_1} * \shared{Q}{I_2} &=> \shared{P \sepish Q}{I_1 \cup I_2} \tag{\textsc{Merge}}\\
  \shared{P}{I} &=> \shared{P}{I} * \shared P I \tag{\textsc{Split}}\\
  \shared{P * \shared{Q}{I'}}{I} &<=> \shared{P}{I} * \shared{Q}{I'}
  \end{align*}
\end{lemma}
\julescomment{TODO: Other interesting facts?}
\begin{proof}
  Immediate.
\end{proof}

\azaleacomment{I'm not sure the proof is so immediate at least in the case of merge. I needed a separate lemma to show action model containment. We should cite the tech report for the proof?}

\begin{definition}[Localised interference semantics]
  \label{def:interferenceSemantics}
  The semantics of an interference assertion $I$ is given by
  $
  \semI[(.)]{I} : \LEnv -->
  \Caps -->  \powerset(\LStates \times \LStates)
  $
  defined as follows:
  \begin{align*}
  \semI[\lenv]{I}(\ca{}) &==
  \left\{
  \begin{array}{@{}l@{\ }|@{\ }r@{}}
    (p, q)&
    \begin{array}{@{}l@{}}
      \exsts{\interAss{\ca{}}{\vec{y}}{P}{Q} \in I}
      \exsts{\vec{v},r, \amod{}, \amod{\ell}}\\
      \quad p,[\lenv|||\vec y:\vec v] |=_{p \composeL r,\amod{}, \amod{\ell}} P \land\null\\
      \quad q,[\lenv|||\vec y:\vec v] |=_{q \composeL r,\amod{}, \amod{\ell}} Q
    \end{array}
  \end{array}
  \right\}
  \end{align*}
\end{definition}


\subsection{Action shifting}

\begin{figure}
\hrule\vspace*{5pt}
\[
\begin{array}{c }
\infer{
%	\shared{R}{ I \cup \left\{ \capAss{}: P \swap Q\right\}} \sentails 
%	\shared{R}{ I \cup \left\{ \capAss{}: \bigcup\limits_{i \in J} P * R_i \swap Q * R_i \right\}} 	
	\left( I \cup \left\{ \capAss{}: P \swap Q\right\}\right) \weakenI{R} \left( I \cup \left\{ \capAss{}: \bigcup\limits_{i \in J} P * R_i \swap Q * R_i \right\} \right) 	
}
{	
    R \entails \fenceAss{} 
	& \fenceAss{} \fences I \cup \left\{ \capAss{}: P \swap Q\right\}
	&\bigwedge\limits_{i \in J} \exact{R_i}\\
	& \fenceAss{} \sepish P \vdash \bigvee\limits_{i \in J} \fenceAss{} \sepish \left(P * R_i \right)
}
\\\\
\infer{
%	\shared{R}{ I \cup \left\{ \capAss{}: P \swap Q\right\}} \sentails 
%	\shared{R}{I} 	
	\left(I \cup \left\{ \capAss{}: P \swap Q\right\}\right) \weakenI{R} 
	I 	
}{
	R \entails \fenceAss{} 
	& \fenceAss{} \fences  I \cup \left\{ \capAss{}: P \swap Q\right\}
	&\exact{\fenceAss{} \intersect Q}\\
	& \fenceAss{} \intersect P \vdash \fenceAss{} \intersect Q
}\\\\
\infer{	
	\left(I \cup \left\{ \capAss{}: P \swap Q\right\}\right) \weakenI{R} 
	I 	
}{
	R \entails \fenceAss{} 
	& \fenceAss{} \fences  I \cup \left\{ \capAss{}: P \swap Q\right\}
	&F \sepish Q \entails \m{false}
}
\end{array}
\]
\hrule\vspace*{5pt}
\caption{Action shifting rules.}
\label{fig:shiftRules}
\end{figure}

We do not give the semantic model of interferences here. Instead, we
give rules that reduce it to logical entailments. We delay the
semantic definitions until \S\ref{sec:soundness}, in which we will
show that the rules we propose here are indeed sound.

\subsection{Rely, guarantee, stability}


TODO: include this: In particular,
an action whose precondition is satisfiable is always enabled from the
empty subjective assertion (which by definition is compatible with all
other states). 


\subsection{Proof rules}

Explain atomic rule. Others are standard.

