\section{The \colosl logic}
\label{sec:logic}

We now introduce the program logic \colosl formally. Let us first give
the syntax and semantics of our assertion language.

\subsection{\colosl assertions}

\paragraph{Syntax}
Our assertions extend standard separation logic with \emph{subjective
  views}, as introduced in the previous section. \colosl is parametric
with respect to the heap and capability assertions and can be
instantiated with any assertion language so long as they are
interpreted over elements of a separation
algebra~\cite{asl,views}. For space reasons, we restrict the
exposition in this paper to \emph{heap assertions} and models, and to
sets of \emph{tokens} as capabilities. The parametric treatment of
\colosl assertions can be found in the companion technical
report~\cite{colosl-tr14}. We assume infinite disjoint sets
$\set{PVar}$, $\set{LVar}$, and $\set{Token}$ of program variables,
logical variables, and tokens, respectively.

\begin{definition}[Assertion syntax]
  \label{def:assertions}
  The assertions of \colosl are elements of $\Assertions$ described by
  the grammar below, where $\li x$ ranges over program variables, $x$
  over logical variables, and $\token a$ over tokens.
  \begin{align*}
    E &::= \li x ||| x ||| 0, 1, \ldots ||| E_1 + E_2 ||| \cdots\\
    \p{A} &::=\m{false} \mid E_1 = E_2 ||| \emp ||| E_1 |-> E_2 \mid [\token a]\\
    P, Q  &::= 
    \p{A} \mid P \Rightarrow Q \mid \exsts{x} P \mid
     P * Q \mid P --* Q \mid P \sepish Q% \mid P \intersect Q
     \mid \shared{P}{I} \\
    I &::= \emptyset ||| \interAss{\token a}{\vec{y}}{P}{Q}, I
  \end{align*}
\end{definition}

The syntax follows from standard separation logic, with the exception
of shared-state assertions, whose notation is borrowed from previous
rely-guarantee-based formalisms. Predicates and connectives from the
first row have their standard classical meaning, and spatial
predicates and connectives have been informally introduced in the
previous section.
\azaleacomment{The intersection connective $\intersect$ is new. We should explain that.}
\azaleacomment{As is, I hate this distinction between heaps and stack. Too much clutter. But at the very least we need to state that this division is not necessary and stacks could have been captured as part of the underlying heap SA. That is, for simplicity in this paper we have instantiated our heap SA as a standard heap+stack.}
\paragraph{Program states}
To interpret formulas in our assertion language, we build models using
three ingredients. The first is a standard \emph{stack}, assigning
values to program variables:
\[
\set{Stack} == \set{PVar} --> \set{Val}
\]

The next ingredient are \emph{logical states}, which are used to
describe resources held locally as well as those shared with other
threads. 

\begin{definition}[Logical states]
  A \emph{logical state} is a pair $(h, \ca{})$ of a heap $h \in\Heaps$ (\textit{i.e.} a finite partial functions from addresses
  to values) and a capability $\ca{} \in\Caps$.
  \begin{align*}
    \Heaps &== \set{Loc} --`_{\m{fin}} \set{Val}&
    \Caps &== \powerset(\set{Token})&
    \LStates &== \Heaps\times \Caps
  \end{align*}
  We write $\unitL$ for the logical state $(\unitH, \unitCap)$. The
  \emph{composition of logical states}
  $
  \composeL : \LStates \times \LStates \rightharpoonup \LStates
  $
  is defined as:
  \[
  (h,\ca{}) \composeL (h', \ca{}') \eqdef
  (h\composeH h', \ca{}\composeCap \ca{}')
  \]
\end{definition}
\azaleacomment{Our \Heaps\ should be defined as $\set{Loc} --`_{\m{fin}} \set{Val} \times \set{Stack}$. In generalised \colosl\ we don't have a stack parameter. So it is important that stacks are part of \Heaps\ parameter.}
Although, for this presentation, we build logical states out of heaps
and sets of tokens, in general any pair of separation algebras
(\textit{i.e.}, cancellative partial commutative monoids~\cite{asl})
would do~\cite{colosl-tr14}.

In the following, we write $l_1\leq l_2$ when there exists $l$ such
that $l\composeL l_1 = l_2$. When that is the case, we also write $l_2
- l_1$ to denote the unique (by cancellativity) such $l$. When $l_1$
and $l_2$ are compatible according to $\composeL$, we write
$l_1\compatL l_2$.

The last ingredient are \emph{action models}, used to interpret
interference assertions.

\begin{definition}[Action models]
An \emph{action model} is a partial function from capabilities to
their semantic actions, expressed as relations between the logical
states:
\[
	\amod{} \in \AMods \eqdef \Caps \rightharpoonup \pset{\LStates \times \LStates}
\]
We write $\unitAM$ for an action model with empty domain.
\end{definition}


\begin{definition}[Worlds]
  A \emph{world} is a 5-tuple consisting of a stack, a logical state
  representing the thread-local state, a second logical state
  representing the shared state, a global action model and a local
  action model. Later in \S\ref{subsec:localGlobalActionModels}, we
  justify the need for both local and global action models. An extra
  \emph{well-formedness} condition is imposed on worlds, that ensures
  that the local and shared states are always compatible, and that the
  updates permitted by the action models are well-behaved with respect
  to future extensions of the shared state:
  \[
  \Worlds \eqdef \{w\in
  \set{Stack}\times\LStates\times\LStates\times\AMods\times\AMods ||| \p{wf}(w)\}
  \]
  The \emph{composition of worlds} is defined as
  \begin{align*}
    &\qquad (s,l,l_s,\amod{},\amod{\ell}) \composeW
    (s',l',l_s',\amod{}',\amod{\ell}') \\
    &\eqdef
    \begin{cases}
      (s,l\composeL l', l_s, \amod{}, \amod{\ell}) &
      \begin{array}[t]{L}
        \text{if }
        s =s'\text{, }
        l_s = l_s' \text{, }
        \amod{} = \amod{}' \text{, and } \amod{\ell} = \amod{\ell}'\\[-.7ex]
        \text{and }\p{wf}((s,l\composeL l', l_s, \amod{}, \amod{\ell}))
      \end{array}\\
      \textit{undefined}&\text{otherwise}
    \end{cases}
  \end{align*}
\end{definition}


\azaleacomment{Yuck! This is totally mismatching the generalised definition of \colosl\ in the tech report. If one wants to use program variables, then they should instantiate their own model of program vars as part of the monoid, or otherwise. This is really horrible. I strongly dislike this. I am not willing to change the tech report now. We have precedents for this: iCAP, CAP, HOCAP.}
\paragraph{Semantics}
We are now ready to give the semantics of \colosl assertions, defined
as a forcing relation $|=$ between worlds and formulas. We use two
auxiliary forcing relations, each between stack and logical state
pairs and formulas. One of them, also written $|=$, interprets atomic
formulas, while the other $|=_l$ interprets assertions about the
shared state, given an original shared state $l$. Logical connectives
are interpreted uniformly in all cases, hence we write $|=_{?}$ for
either $|=$ or $|=_{l}$ for some $l$ (in which case subsequent
occurences of $|=_{?}$ refer to the same $|=_l$), and then write $u$
for elements of either $\Worlds$ or $LStates$, and $\gray$ for either
$\composeW$ or $\composeL$.

\azaleacomment{I find this very confusing even though we have discussed it. Especially since in the semantics below you have pairs, quadruples and quintuples as elements of the interpretation. Can you give the type signature of semantics?}

\begin{definition}[Assertion semantics]
  Given a logical environment $\lenv\in\LEnv == \set{LVar} -->
  \set{Val}$, the semantics of \colosl assertions is as follows, where
  $\semI[(.,.)]{.}$ denotes the semantics of interference assertions
  described in \defin~\ref{def:interferenceSemantics}:
\[
\begin{array}{R>{\null}lcl}
  (s,l),\lenv &|= \m{false}
  &\text{iff}& \text{never}\\
  (s,l),\lenv &|= E_1 = E_2
  &\text{iff}& [|E_1|]_{s,\lenv} = [|E_2|]_{s,\lenv}\\
  (s,l), \lenv &|= \emp &\text{iff}& l = \unitL\\
  (s,l), \lenv &|= E_1|->E_2 
  &\text{iff}&
  l =
  ([[|E_1|]_{s,\lenv}: [|E_2|]_{s,\lenv}],\unitCap)\\
  (s,l), \lenv &|= [\token a]
  &\text{iff}&
  l = (\unitH, \{\token a\})\\
  (s,l,l_s,\amod{},\amod{\ell}), \lenv &|= \p{A} &\text{iff}& (s,l),\lenv |= \p{A}\\
  (s,l_s,\amod{},\amod{\ell}), \lenv &|=_{l} \p{A} &\text{iff}&(s,l_s), \lenv |= \p{A}\\
  (s,l,l_s,\amod{},\amod{\ell}), \lenv &|= \shared P I &\text{iff}&
  l = \unitH\text{ and }
  \exsts{l_s',r}
  l_s = l_s'\composeL r
  \text{ and}\\
  &&&(s,l_s',\amod{},\amod{\ell}), \lenv |=_{l_s} P\text{ and }\\
  &&&\extendsAM{\amod{}, \amod{\ell}}{l_s'}{r}{\semI[s,\lenv]{I}}\\
  (s,l_s,\amod{},\amod{\ell}), \lenv &|=_{l} \shared P I &\text{iff}&
  (s,l_s,l,\amod{},\amod{\ell}), \lenv |= \shared P I\\
  u,\lenv &|=_{?} P => Q
  &\text{iff}& u,\lenv |=_{?} P\text{ implies }u,\lenv |=_{?} Q\\
  u,\lenv &|=_{?} \exsts x P
  &\text{iff}& \exsts v u, [\lenv|||x:v] |=_{?} P\\
  u, \lenv &|=_{?} P_1 * P_2 &\text{iff}&
  \exsts{u_1,u_2} u = u_1\gray u_2\text{ and}\\
  &&& u_1, \lenv |=_{?} P_1 \text{ and }u_2, \lenv |=_{?} P_2\\
  u, \lenv &|=_{?} P --* Q &\text{iff}&
  \for{u'} u', \lenv |=_{?} P \text{ and }
  u \sharp u'\\
  &&&\text{ implies }u\gray u', \lenv |=_{?} Q\\
  u, \lenv &|=_{?} P_1 ** P_2 &\text{iff}&
  \exsts{u',u_1,u_2} u = u'\gray u_1\gray u_2\\
  &&&\text{ and }
  u'\gray u_1, \lenv |=_{?} P_1 \text{ and }\\
  &&&u'\gray u_2, \lenv |=_{?} P_2
\end{array}
\]
\end{definition}

\azaleacomment{Why did you comment out the semantics of intersection $\intersect$?}

The semantics of separation logic predicates and connectives is
standard and depends only on the local state.  $\shared{P}{I}$ states
that $P$ holds for only a sub-state $l_s'$ of the global shared state
$l_s'\composeL r$. The interference associated with $l_s'$ is given by
interference assertion $\semI[s,\lenv]{I}$ such that the global and
local action models $\amod{}$ and $\amod{\ell}$ are \emph{closed}
under $\semI[s,\lenv]{I}$ with respect to the subjective view $l_s'$ and
context $r$. This will be formalised in \S\ref{subsec:localGlobalActionModels}.
%Since shared state assertions are partial subjective description of the shared state, separating conjunction between them behaves as overlapping conjunction 

\begin{lemma}
  \label{lem:assertionFacts}
  The following formulas are valid according to the semantics above:
  \begin{align*}
  \shared{P * Q}{I} &=> \shared{P}{I}  \tag{\textsc{Forget}}\\
  \shared{P}{I_1} * \shared{Q}{I_2} &=> \shared{P \sepish Q}{I_1 \cup I_2} \tag{\textsc{Merge}}\\
  \shared{P}{I} &=> \shared{P}{I} * \shared P I \tag{\textsc{Split}}\\
  \shared{P * \shared{Q}{I'}}{I} &<=> \shared{P}{I} * \shared{Q}{I'}
  \end{align*}
\end{lemma}
\julescomment{TODO: Other interesting facts?}
\begin{proof}
  Immediate.
\end{proof}

\azaleacomment{I'm not sure the proof is so immediate at least in the case of merge. I needed a separate lemma to show action model containment. We should cite the tech report for the proof?}

\begin{definition}[Localised interference semantics]
  \label{def:interferenceSemantics}
  The semantics of an interference assertion $I$ is given by
  $
  \semI[(.,.)]{I} : \set{Stack}\times\LEnv -->
  \Caps -->  \powerset(\LStates \times \LStates)
  $
  defined as follows:
  \begin{align*}
  \semI[s,\lenv]{I}(\ca{}) &==
  \left\{
  \begin{array}{@{}l@{\ }|@{\ }r@{}}
    (p, q)&
    \begin{array}{@{}l@{}}
      \exsts{\interAss{\capAss{}}{\vec{y}}{P}{Q} \in I} \exsts{\vec{v}}\null\\
      \quad\ca{} = \capAss{} \land\exsts{r, \amod{}, \amod{\ell}}\\
      \quad (s,p,\amod{}, \amod{\ell}),[\lenv|||\vec y:\vec v] |=_{p \composeL r} P \land\null\\
      \quad (s,q,\amod{}, \amod{\ell}),[\lenv|||\vec y:\vec v] |=_{q \composeL r} Q
    \end{array}
  \end{array}
  \right\}
  \end{align*}
\end{definition}


\subsection{Action shifting}

\begin{figure}
\hrule\vspace*{5pt}
\[
\begin{array}{c }
\infer{
%	\shared{R}{ I \cup \left\{ \capAss{}: P \swap Q\right\}} \sentails 
%	\shared{R}{ I \cup \left\{ \capAss{}: \bigcup\limits_{i \in J} P * R_i \swap Q * R_i \right\}} 	
	\left( I \cup \left\{ \capAss{}: P \swap Q\right\}\right) \weakenI{R} \left( I \cup \left\{ \capAss{}: \bigcup\limits_{i \in J} P * R_i \swap Q * R_i \right\} \right) 	
}
{	
    R \entails \fenceAss{} 
	& \fenceAss{} \fences I \cup \left\{ \capAss{}: P \swap Q\right\}
	&\bigwedge\limits_{i \in J} \exact{R_i}\\
	& \fenceAss{} \sepish P \vdash \bigvee\limits_{i \in J} \fenceAss{} \sepish \left(P * R_i \right)
}
\\\\
\infer{
%	\shared{R}{ I \cup \left\{ \capAss{}: P \swap Q\right\}} \sentails 
%	\shared{R}{I} 	
	\left(I \cup \left\{ \capAss{}: P \swap Q\right\}\right) \weakenI{R} 
	I 	
}{
	R \entails \fenceAss{} 
	& \fenceAss{} \fences  I \cup \left\{ \capAss{}: P \swap Q\right\}
	&\exact{\fenceAss{} \intersect Q}\\
	& \fenceAss{} \intersect P \vdash \fenceAss{} \intersect Q
}\\\\
\infer{	
	\left(I \cup \left\{ \capAss{}: P \swap Q\right\}\right) \weakenI{R} 
	I 	
}{
	R \entails \fenceAss{} 
	& \fenceAss{} \fences  I \cup \left\{ \capAss{}: P \swap Q\right\}
	&F \sepish Q \entails \m{false}
}
\end{array}
\]
\hrule\vspace*{5pt}
\caption{Action shifting rules.}
\label{fig:shiftRules}
\end{figure}

We do not give the semantic model of interferences here. Instead, we
give rules that reduce it to logical entailments. We delay the
semantic definitions until \S\ref{sec:soundness}, in which we will
show that the rules we propose here are indeed sound.

\subsection{Rely, guarantee, stability}


TODO: include this: In particular,
an action whose precondition is satisfiable is always enabled from the
empty subjective assertion (which by definition is compatible with all
other states). 


\subsection{Proof rules}

Explain atomic rule. Others are standard.

